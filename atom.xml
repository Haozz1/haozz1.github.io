<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Haoz</title>
  
  <subtitle>按时吃饭</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-07-19T16:36:18.258Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Haoz</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记</title>
    <link href="http://yoursite.com/2022/07/19/%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/07/19/%E8%AE%B0/</id>
    <published>2022-07-18T18:37:35.000Z</published>
    <updated>2022-07-19T16:36:18.258Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p><strong><strong>2022-07-19</strong></strong><br>&nbsp;<br>抖音收藏了无数个城市的风景,我好想很羡慕那些慢下来却到处看看的人,蓝天白云河流山川大雪还有城市的夜景.<br>啊,我真的太羡慕了.</p></blockquote><hr><hr><blockquote><p><strong><strong>2022-07-18</strong></strong><br>&nbsp;<br>我也有法老王相助就好了!<br><img src="/2022/07/19/记/jimu.jpg"><br>关掉一切没用的消息来源果然爽快,不刷微博不看朋友圈,什么个人的事还是国家大事都与我无关.<br>简简单单的生活也好也坏,keep.<br>哦对了,今天下午去隔壁街做核酸的事情可能是近期最意外的开心了.</p></blockquote><hr><hr><blockquote><p><strong><strong>2022-07-07</strong></strong><br>&nbsp;<br>当觉着运气还不错的时候,倒霉事就开始来了.</p></blockquote><hr><hr><blockquote><p><strong><strong>2022-07-07</strong></strong><br>&nbsp;<br>打车去了两公里外的医院做核酸,晚上十一点的医院门口排的长队一点也看不到尽头,在路口看了十分钟人群还是选择了回家. 不过,这是我这两个多月以来去过的最远的地方了 :)</p><p>抖音竟然能一次性发那么多照片.. 刷到一条视频里有100张照片,我竟然一张张的看完了,可能是照片拍的好看,要么就是音乐太搭.<br>平静普通却隐藏着无穷的情感,痛苦或者快乐,图片文字音乐都可以.</p><p>又三点多了,是因为居家让我太放松了还是别的呢,好像很难睡着觉.</p><p><del>下面原本还有一大段话选择把它删了,因为好像没啥用.</del></p></blockquote><hr><hr><blockquote><p><strong><strong>2022-07-02</strong></strong><br>&nbsp;<br>世界纷纷扰扰喧喧闹闹什么是真实<br><img src="/2022/07/19/记/cloud.jpg"><br>如果真能穿越时空,每个时期都会永存 每个瞬间即永恒,chill~ man.<br>我最终还是选择了关掉了朋友圈,我希望他们都能开心快乐,但看到那些也确实会让我不开心,那就不如看不到.<br>电影中的那些情节也总会一件一件发生在我身上,那还是祝大家都能开心快乐吧~</p></blockquote><hr><hr><blockquote><p><strong><strong>2022-06-11</strong></strong><br>&nbsp;<br>我躲在断墙后,偷看两个少年徒手摘星,星星映在他们眼里,光却洒在了我身上.<br><img src="/2022/07/19/记/sun.jpg"><br>&lt;&lt;桶川跟踪狂杀人事件&gt;&gt;终于又翻了两章,其实一旦开始就很容易看上瘾,难得就是拿起书.<br>停止了幻想,最近也没有做梦,平淡的时光里日复一日的做着相同的事.</p></blockquote><hr><hr><blockquote><p><strong><strong>2022-06-11</strong></strong><br>&nbsp;<br>好久没下雨了<br><img src="/2022/07/19/记/rain.jpg"><br>不太好描述最近的状态,来自四面八方的压力比之前更大,因为我关掉了所有消息渠道而变得似乎没那么严重.原本这周正式复工了,周二去了趟公司发现只有三个人,昨天又收到了继续居家的通知,单调但简单的生活还可以继续维持一段时间.<br>思维变懒了,身体却没懒,外卖已经不想吃了,哪怕晚上狂风暴雨还是选择了出门吃饭,雨挺大,夹杂着闪电和雷声更显出了它的冷酷,不过躲在树枝下的黄色路灯还是被我发现,比起凉飕飕的风和雨水倒显得温暖了一些.<br>疫情反复无常这么看能正常出游都费劲了,就不要说恢复正常生活了.平常心吧,事情反正不会变得更糟 :)</p></blockquote><hr><hr><blockquote><p><strong><strong>2022-06-06</strong></strong><br>&nbsp;<br>北京天际线<br><img src="/2022/07/19/记/yun.jpg"></p></blockquote><p>Forgot thousand things everyday, make sure this is one of them :(</p><hr><hr><blockquote><p><strong><strong>2022-06-06</strong></strong><br>&nbsp;<br>把夏天关在了冰箱里<br><img src="/2022/07/19/记/xg.jpg"><br>最近的作息真的乱了套,之前熬夜看足球看csgo都要熬到每天的凌晨四五点,足球结束了csgo也结束了但作息却调整不过来了.端午假期的三天每天都要到四五点才能睡着,早上和中午又都要被快递电话吵醒,下楼拿完快递回来再接着睡,然而每次睡都只能睡一个小时,醒了之后以为终于精神了却还是迷迷糊糊只好再回床上.最后一天原本以为早早地睡觉可以主动调整生物钟,却又因为头疼四点多又醒来.<br>翻来覆去又到了六点,一直没睡着.外边的大风在呼呼作响,我打开了窗户让风进来,哆啦A梦的竹蜻蜓在加速旋转,它好像真的要飞起来了.桌上的日历本被风吹着翻到了三天前,又翻到了一周后.<br>北京终于恢复正常了,餐馆从今天开始也恢复堂食了,想念很久没吃过的烧烤和火锅.昨天晚上点了个烤鱼的外卖,现在的外卖包装令我惊奇,原以为需要自己准备锅来煮鱼,没想到还自带了锡纸锅和简易烤架,架好鱼点燃酒精燃料,鱼汤翻滚香气蔓延,也终于让我想起我其实很喜欢吃鱼.<br>裹在被窝里的我迷糊着敲着键盘趁着微弱的记忆写着最后的几行,闭上眼睛感受着风在身上略过,思绪却跟着日历本在过去的记忆和未来的期望中来回穿梭.<br>反正怎么都睡不着了,赶着去做最早的一波核酸吧.</p></blockquote><hr><hr><blockquote><p><strong><strong>2022-06-01</strong></strong><br>&nbsp;<br>拍到一朵心形状的云<br><img src="/2022/07/19/记/liuyi.jpg"><br>最近变得很浮躁<br>四月买的几本书只看了第一本的第一章,从那之后几次翻开书又合上总是看不进去. 攒了好久的电影和电视剧也是打开又关掉.<br>看到了一句话<br><code>你以为很多事就像打游戏一样可以重复 还有下一次, 但你错了 包括你儿时的单车或纸飞机 抄作业或买糖果 早就是此生的最后一次</code><br>六一快乐 :)</p></blockquote><hr><hr><blockquote><p><strong><strong>2022-05-30</strong></strong><br>&nbsp;<br>五月很漫长,也还是要过去了.<br><img src="/2022/07/19/记/summer.jpg"><br>回头看看这个月,前半段的煎熬后半段的安静,虽然很难但终于扛过来了.<br>每天上午的核酸终止时间提前到了十点,原本十一点都有些赶不上的我这下也终于彻底放弃了早起,还好小区门口多了个常态核酸的小房子,虽然人也不少但进行的很快,唯一难受的点就是天气变得很热了,热的排队的几分钟呼吸都困难.<br>很难理解这阵子发生的事情,其中最令我费解的就是因为我不想说话而生气的朋友,到头来反而成了我的错,我自己一边扛着煎熬,一边还要去解释原因还要去为生了气的朋友道歉,甚至还出现了那几天我真的谁都没说话的疑问.不过随它去吧,我已经没心思去解释了,也懒得去在乎别人的想法.<br>天气热的突然,每天西瓜和雪糕的诱惑让我坚持要下楼去超市,路上车还是不多,可能因为全体居家的原因工作也少了很多.看了眼手机,这一个月除了偶尔跟家里打个电话,也就是买菜群游戏群在弹提示,跟这些陌生人聊聊游戏聊聊足球然后买点菜丰富了我这一个月的生活.<br>Csgo Major结束了,英超和欧冠也结束了,我的主队基本颗粒无收.虽然很难过但也终于可以睡个好觉了.<br>中午吃点什么呢,先下楼买块雪糕吃吃吧.</p></blockquote><hr><hr><blockquote><p><strong><strong>2022-05-24</strong></strong><br>&nbsp;<br>最近拍了很多照片,有下楼做核酸时看到的蓝天白云,有在路上散步时看到迎风摆动的树枝,有下雨时在路上着急回家的人,也有卧室窗口看到的印满整片天空的晚霞.<br>我喜欢时不时就打开手机相册翻一翻,看过去拍到的照片不光能想起当时发生的事情,也能重新感受到当时的心情,这和普鲁斯特效应出奇的相似.绝大多数都是开心和兴奋的回忆,不然好像也不会在相册里留下痕迹.<br>我发现相册里最多的风景是拍的天空,晴空或者晚霞.然后是海,都是些广阔而自由的东西,也许是告别自由太久了,被各种想法和目的困住了双腿双脚,现在能做的除了拿起手机拍下来连停下来多看几分钟都变得很奢侈.<br>上周末终于解封了,自从居家了一周又封控了一周之后就再没出门散步,在家的几天运动了也随着精神的发霉而停止.中午出门走了走,外边的空气用它的热情疯狂的拥抱我,好像是在提醒我时间已经过去了太久,连天气和温度都变得陌生.周围的小吃店还没开门营业,理发店门口堆着旁边菜市场搬出来的坏掉的菜叶,停车场里车子停放的奇奇怪怪的样子倒还和五一假期看到时的一样.树枝好像更长了需要弯着腰才能过了,树下坐满了乘凉的人在互相分享着这一个月以来的新鲜事,路上挤满了的行人要么在往超市方向走要么拎着刚买完的新鲜蔬菜慢悠悠的回家,这些画面在已经2022年的北京显得很陌生,生活好像因为疫情真的放慢了下来.<br>我不需要囤菜,来商场更多的是无聊,来看看有什么很久没吃的东西或者就是单纯想来看看热闹.还没到午饭时间超市已经没多少蔬菜和水果了,冷柜里的一桶三元牛奶显得格外的孤单,我只好把它放进了我凭借速度才抢到的购物车里.<br>出了商场又往南走了走,小河边的健身器材都重新被利用了起来,可能都在避免聚集,下棋的大爷们却都还没出现.要是来些风就好了,也不至于需要用反衬的阳光来确定河水依旧在流淌.<br>再往南的北二环主路少了点昔日的焦急,偶尔路过的公交车在告诉着我虽然疫情严重但一切都仍平稳有序.远处的写字楼好像比平时黯淡了一些,没有了人气的钢筋水泥在这炎炎夏日略显得冰冷.<br>到了家,原本微凉的牛奶已经晒得有些烫手,只好再重新放回冰箱冰一冰.重新出门再进屋也感受到了屋里的杂乱,需要打扫下卫生好好收拾一下了.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;2022-07-19&lt;/strong&gt;&lt;/strong&gt;&lt;br&gt;&amp;nbsp;&lt;br&gt;抖音收藏了无数个城市的风景,我好想很羡慕那些慢下来却到处看看的人,蓝天白云河流山川大雪还有城市的夜景.&lt;br&gt;啊,我真的太</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://yoursite.com/tags/随笔/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus</title>
    <link href="http://yoursite.com/2022/06/01/Prometheus/"/>
    <id>http://yoursite.com/2022/06/01/Prometheus/</id>
    <published>2022-06-01T07:56:09.000Z</published>
    <updated>2022-06-01T08:26:54.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h1><h3 id="Prometheus-is-an-open-source-systems-monitoring-and-alerting-toolkit-originally-built-at-SoundCloud"><a href="#Prometheus-is-an-open-source-systems-monitoring-and-alerting-toolkit-originally-built-at-SoundCloud" class="headerlink" title="Prometheus is an open-source systems monitoring and alerting toolkit originally built at SoundCloud."></a>Prometheus is an open-source systems monitoring and alerting toolkit originally built at SoundCloud.</h3><p><strong><em>Document of Prometheus</em></strong> <a href="https://prometheus.io/docs/introduction/overview/" target="_blank" rel="noopener">https://prometheus.io/docs/introduction/overview/</a></p><p><strong><em>Download of Prometheus</em></strong> <a href="https://prometheus.io/download/" target="_blank" rel="noopener">https://prometheus.io/download/</a></p><hr><h2 id="1-Prometheus-install"><a href="#1-Prometheus-install" class="headerlink" title="1. Prometheus install"></a>1. Prometheus install</h2><p>下载并解压压缩文件之后,进入到Prometheus目录<br>查看或修改配置文件<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my global config</span></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">15s</span> <span class="comment"># Set the scrape interval to every 15 seconds. Default is every 1 minute.</span></span><br><span class="line">  <span class="attr">evaluation_interval:</span> <span class="string">15s</span> <span class="comment"># Evaluate rules every 15 seconds. The default is every 1 minute.</span></span><br><span class="line">  <span class="comment"># scrape_timeout is set to the global default (10s).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Alertmanager configuration</span></span><br><span class="line"><span class="attr">alerting:</span></span><br><span class="line">  <span class="attr">alertmanagers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">          <span class="comment"># - alertmanager:9093</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load rules once and periodically evaluate them according to the global 'evaluation_interval'.</span></span><br><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="comment"># - "first_rules.yml"</span></span><br><span class="line">  <span class="comment"># - "second_rules.yml"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A scrape configuration containing exactly one endpoint to scrape:</span></span><br><span class="line"><span class="comment"># Here it's Prometheus itself.</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">"prometheus"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># metrics_path defaults to '/metrics'</span></span><br><span class="line">    <span class="comment"># scheme defaults to 'http'.</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">["localhost:9090"]</span></span><br></pre></td></tr></table></figure></p><p>运行以下命令启动Prometheus: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./prometheus</span><br></pre></td></tr></table></figure><p>or<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./prometheus --config.file=prometheus.yml</span><br></pre></td></tr></table></figure></p><p>控制台会打印出一些日志<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ts=2022-06-01T06:23:12.752Z caller=main.go:488 level=info msg="No time or size retention was set so using the default time retention" duration=15d</span><br><span class="line">ts=2022-06-01T06:23:12.752Z caller=main.go:525 level=info msg="Starting Prometheus" version="(version=2.35.0, branch=HEAD, revision=6656cd29fe6ac92bab91ecec0fe162ef0f187654)"</span><br><span class="line">ts=2022-06-01T06:23:12.752Z caller=main.go:530 level=info build_context="(go=go1.18.1, user=root@cf6852b14d68, date=20220421-09:53:42)"</span><br><span class="line">ts=2022-06-01T06:23:12.752Z caller=main.go:531 level=info host_details="(Linux 5.4.0-1078-azure #81~18.04.1-Ubuntu SMP Mon Apr 25 23:16:13 UTC 2022 x86_64 TitanTest02 (none))"</span><br><span class="line">ts=2022-06-01T06:23:12.752Z caller=main.go:532 level=info fd_limits="(soft=1024, hard=1048576)"</span><br><span class="line">ts=2022-06-01T06:23:12.752Z caller=main.go:533 level=info vm_limits="(soft=unlimited, hard=unlimited)"</span><br><span class="line">ts=2022-06-01T06:23:12.754Z caller=web.go:541 level=info component=web msg="Start listening for connections" address=0.0.0.0:9090</span><br><span class="line">ts=2022-06-01T06:23:12.755Z caller=main.go:957 level=info msg="Starting TSDB ..."</span><br></pre></td></tr></table></figure></p><p>可以看到Prometheus已经启动并启用了端口9090. 浏览器打开相应的地址就可以看到Prometheus的界面了</p><img src="/2022/06/01/Prometheus/p.png"><hr><h2 id="2-Sql-Exporter"><a href="#2-Sql-Exporter" class="headerlink" title="2. Sql Exporter"></a>2. Sql Exporter</h2><p>Prometheus提供了多种Exporter,可以帮助从第三方系统导出现有指标作为Prometheus指标</p><p><strong><em>Exporters</em></strong>: <a href="https://prometheus.io/docs/instrumenting/exporters/#exporters-and-integrations" target="_blank" rel="noopener">https://prometheus.io/docs/instrumenting/exporters/#exporters-and-integrations</a></p><p>这里使用的是非官方的exporter <a href="https://github.com/free/sql_exporter/tree/caf149bcfa2ccacb873e82c7e6bb8014b6a2b81d" target="_blank" rel="noopener">https://github.com/free/sql_exporter/tree/caf149bcfa2ccacb873e82c7e6bb8014b6a2b81d</a></p><p>和install Prometheus相似,修改sql_exporter.yml和*.collector.yml文件并启动exporter:</p><p>sql_exporter.yml:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="comment"># Subtracted from Prometheus' scrape_timeout to give us some headroom and prevent Prometheus from timing out first.</span></span><br><span class="line">  <span class="attr">scrape_timeout_offset:</span> <span class="string">500ms</span></span><br><span class="line">  <span class="comment"># Minimum interval between collector runs: by default (0s) collectors are executed on every scrape.</span></span><br><span class="line">  <span class="attr">min_interval:</span> <span class="string">0s</span></span><br><span class="line">  <span class="comment"># Maximum number of open connections to any one target. Metric queries will run concurrently on multiple connections,</span></span><br><span class="line">  <span class="comment"># as will concurrent scrapes.</span></span><br><span class="line">  <span class="attr">max_connections:</span> <span class="number">3</span></span><br><span class="line">  <span class="comment"># Maximum number of idle connections to any one target. Unless you use very long collection intervals, this should</span></span><br><span class="line">  <span class="comment"># always be the same as max_connections.</span></span><br><span class="line">  <span class="attr">max_idle_connections:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A SQL Exporter job is the equivalent of a Prometheus job: a set of related DB instances.</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># All metrics for the targets defined here get a `job="pricing_db"` label.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">mssql_standard</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Collectors (referenced by name) to execute on all targets in this job.</span></span><br><span class="line">    <span class="attr">collectors:</span> <span class="string">[mssql_standard]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Similar to Prometheus static_configs.</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">          <span class="comment"># Map of instance name (exported as instance label) to DSN</span></span><br><span class="line">          <span class="attr">'data.database.windows.net:1433':</span> <span class="string">'sqlserver://username:password@data.database.windows.net:1433'</span></span><br><span class="line">          <span class="attr">'data.database.windows.net:1433':</span> <span class="string">'sqlserver://username:password@data.database.windows.net:1433'</span></span><br><span class="line">        <span class="attr">labels:</span></span><br><span class="line">          <span class="attr">env:</span> <span class="string">'prod'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">          <span class="comment"># Map of instance name (exported as instance label) to DSN</span></span><br><span class="line">          <span class="attr">'data.database.windows.net:1433':</span> <span class="string">'sqlserver://username:password@data-ingestion-tool.database.windows.net:1433'</span></span><br><span class="line">        <span class="attr">labels:</span></span><br><span class="line">          <span class="attr">env:</span> <span class="string">'test'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Collector definition files.</span></span><br><span class="line"><span class="attr">collector_files:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"*.collector.yml"</span></span><br></pre></td></tr></table></figure></p><blockquote><p>static_configs中还使用了已经不建议使用的对多sql server target的监控<br>说明:<a href="https://github.com/free/sql_exporter/issues/6" target="_blank" rel="noopener">https://github.com/free/sql_exporter/issues/6</a></p></blockquote><hr><p>*.collector.yml:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A collector defining standard metrics for Microsoft SQL Server.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># It is required that the SQL Server user has the following permissions:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   GRANT VIEW ANY DEFINITION TO</span></span><br><span class="line"><span class="comment">#   GRANT VIEW SERVER STATE TO</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">collector_name:</span> <span class="string">mssql_standard</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Similar to global.min_interval, but applies to the queries defined by this collector only.</span></span><br><span class="line"><span class="comment">#min_interval: 0s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">metrics:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metric_name:</span> <span class="string">mssql_local_time_seconds</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">gauge</span></span><br><span class="line">    <span class="attr">help:</span> <span class="string">'Local time in seconds since epoch (Unix time).'</span></span><br><span class="line">    <span class="attr">values:</span> <span class="string">[unix_time]</span></span><br><span class="line">    <span class="attr">query:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">SELECT</span> <span class="string">DATEDIFF(second,</span> <span class="string">'19700101'</span><span class="string">,</span> <span class="string">GETUTCDATE())</span> <span class="string">AS</span> <span class="string">unix_time</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metric_name:</span> <span class="string">mssql_connections</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">gauge</span></span><br><span class="line">    <span class="attr">help:</span> <span class="string">'Number of active connections.'</span></span><br><span class="line">    <span class="attr">key_labels:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">values:</span> <span class="string">[count]</span></span><br><span class="line">    <span class="attr">query:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">SELECT</span> <span class="string">DB_NAME(sp.dbid)</span> <span class="string">AS</span> <span class="string">db,</span> <span class="string">COUNT(sp.spid)</span> <span class="string">AS</span> <span class="string">count</span></span><br><span class="line">      <span class="string">FROM</span> <span class="string">sys.sysprocesses</span> <span class="string">sp</span></span><br><span class="line">      <span class="string">GROUP</span> <span class="string">BY</span> <span class="string">DB_NAME(sp.dbid)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># Collected from sys.dm_os_performance_counters</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metric_name:</span> <span class="string">mssql_deadlocks</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">counter</span></span><br><span class="line">    <span class="attr">help:</span> <span class="string">'Number of lock requests that resulted in a deadlock.'</span></span><br><span class="line">    <span class="attr">values:</span> <span class="string">[cntr_value]</span></span><br><span class="line">    <span class="attr">query:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">SELECT</span> <span class="string">cntr_value</span></span><br><span class="line">      <span class="string">FROM</span> <span class="string">sys.dm_os_performance_counters</span> <span class="string">WITH</span> <span class="string">(NOLOCK)</span></span><br><span class="line">      <span class="string">WHERE</span> <span class="string">counter_name</span> <span class="string">=</span> <span class="string">'Number of Deadlocks/sec'</span> <span class="string">AND</span> <span class="string">instance_name</span> <span class="string">=</span> <span class="string">'_Total'</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metric_name:</span> <span class="string">mssql_user_errors</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">counter</span></span><br><span class="line">    <span class="attr">help:</span> <span class="string">'Number of user errors.'</span></span><br><span class="line">    <span class="attr">values:</span> <span class="string">[cntr_value]</span></span><br><span class="line">    <span class="attr">query:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">SELECT</span> <span class="string">cntr_value</span></span><br><span class="line">      <span class="string">FROM</span> <span class="string">sys.dm_os_performance_counters</span> <span class="string">WITH</span> <span class="string">(NOLOCK)</span></span><br><span class="line">      <span class="string">WHERE</span> <span class="string">counter_name</span> <span class="string">=</span> <span class="string">'Errors/sec'</span> <span class="string">AND</span> <span class="string">instance_name</span> <span class="string">=</span> <span class="string">'User Errors'</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metric_name:</span> <span class="string">mssql_kill_connection_errors</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">counter</span></span><br><span class="line">    <span class="attr">help:</span> <span class="string">'Number of severe errors that caused SQL Server to kill the connection.'</span></span><br><span class="line">    <span class="attr">values:</span> <span class="string">[cntr_value]</span></span><br><span class="line">    <span class="attr">query:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">SELECT</span> <span class="string">cntr_value</span></span><br><span class="line">      <span class="string">FROM</span> <span class="string">sys.dm_os_performance_counters</span> <span class="string">WITH</span> <span class="string">(NOLOCK)</span></span><br><span class="line">      <span class="string">WHERE</span> <span class="string">counter_name</span> <span class="string">=</span> <span class="string">'Errors/sec'</span> <span class="string">AND</span> <span class="string">instance_name</span> <span class="string">=</span> <span class="string">'Kill Connection Errors'</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metric_name:</span> <span class="string">mssql_page_life_expectancy_seconds</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">gauge</span></span><br><span class="line">    <span class="attr">help:</span> <span class="string">'The minimum number of seconds a page will stay in the buffer pool on this node without references.'</span></span><br><span class="line">    <span class="attr">values:</span> <span class="string">[cntr_value]</span></span><br><span class="line">    <span class="attr">query:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">SELECT</span> <span class="string">top(1)</span> <span class="string">cntr_value</span></span><br><span class="line">      <span class="string">FROM</span> <span class="string">sys.dm_os_performance_counters</span> <span class="string">WITH</span> <span class="string">(NOLOCK)</span></span><br><span class="line">      <span class="string">WHERE</span> <span class="string">counter_name</span> <span class="string">=</span> <span class="string">'Page life expectancy'</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metric_name:</span> <span class="string">mssql_batch_requests</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">counter</span></span><br><span class="line">    <span class="attr">help:</span> <span class="string">'Number of command batches received.'</span></span><br><span class="line">    <span class="attr">values:</span> <span class="string">[cntr_value]</span></span><br><span class="line">    <span class="attr">query:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">SELECT</span> <span class="string">cntr_value</span></span><br><span class="line">      <span class="string">FROM</span> <span class="string">sys.dm_os_performance_counters</span> <span class="string">WITH</span> <span class="string">(NOLOCK)</span></span><br><span class="line">      <span class="string">WHERE</span> <span class="string">counter_name</span> <span class="string">=</span> <span class="string">'Batch Requests/sec'</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metric_name:</span> <span class="string">mssql_log_growths</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">counter</span></span><br><span class="line">    <span class="attr">help:</span> <span class="string">'Number of times the transaction log has been expanded, per database.'</span></span><br><span class="line">    <span class="attr">key_labels:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">values:</span> <span class="string">[cntr_value]</span></span><br><span class="line">    <span class="attr">query:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">SELECT</span> <span class="string">rtrim(instance_name)</span> <span class="string">AS</span> <span class="string">db,</span> <span class="string">cntr_value</span></span><br><span class="line">      <span class="string">FROM</span> <span class="string">sys.dm_os_performance_counters</span> <span class="string">WITH</span> <span class="string">(NOLOCK)</span></span><br><span class="line">      <span class="string">WHERE</span> <span class="string">counter_name</span> <span class="string">=</span> <span class="string">'Log Growths'</span> <span class="string">AND</span> <span class="string">instance_name</span> <span class="string">&lt;&gt;</span> <span class="string">'_Total'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># Collected from sys.dm_io_virtual_file_stats</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metric_name:</span> <span class="string">mssql_io_stall_seconds</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">counter</span></span><br><span class="line">    <span class="attr">help:</span> <span class="string">'Stall time in seconds per database and I/O operation.'</span></span><br><span class="line">    <span class="attr">key_labels:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">value_label:</span> <span class="string">operation</span></span><br><span class="line">    <span class="attr">values:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">read</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">write</span></span><br><span class="line">    <span class="attr">query_ref:</span> <span class="string">mssql_io_stall</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metric_name:</span> <span class="string">mssql_io_stall_total_seconds</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">counter</span></span><br><span class="line">    <span class="attr">help:</span> <span class="string">'Total stall time in seconds per database.'</span></span><br><span class="line">    <span class="attr">key_labels:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">values:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">io_stall</span></span><br><span class="line">    <span class="attr">query_ref:</span> <span class="string">mssql_io_stall</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># Collected from sys.dm_os_process_memory</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metric_name:</span> <span class="string">mssql_resident_memory_bytes</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">gauge</span></span><br><span class="line">    <span class="attr">help:</span> <span class="string">'SQL Server resident memory size (AKA working set).'</span></span><br><span class="line">    <span class="attr">values:</span> <span class="string">[resident_memory_bytes]</span></span><br><span class="line">    <span class="attr">query_ref:</span> <span class="string">mssql_process_memory</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metric_name:</span> <span class="string">mssql_virtual_memory_bytes</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">gauge</span></span><br><span class="line">    <span class="attr">help:</span> <span class="string">'SQL Server committed virtual memory size.'</span></span><br><span class="line">    <span class="attr">values:</span> <span class="string">[virtual_memory_bytes]</span></span><br><span class="line">    <span class="attr">query_ref:</span> <span class="string">mssql_process_memory</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metric_name:</span> <span class="string">mssql_memory_utilization_percentage</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">gauge</span></span><br><span class="line">    <span class="attr">help:</span> <span class="string">'The percentage of committed memory that is in the working set.'</span></span><br><span class="line">    <span class="attr">values:</span> <span class="string">[memory_utilization_percentage]</span></span><br><span class="line">    <span class="attr">query_ref:</span> <span class="string">mssql_process_memory</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metric_name:</span> <span class="string">mssql_page_fault_count</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">counter</span></span><br><span class="line">    <span class="attr">help:</span> <span class="string">'The number of page faults that were incurred by the SQL Server process.'</span></span><br><span class="line">    <span class="attr">values:</span> <span class="string">[page_fault_count]</span></span><br><span class="line">    <span class="attr">query_ref:</span> <span class="string">mssql_process_memory</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># Collected from sys.dm_os_sys_memory</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metric_name:</span> <span class="string">mssql_os_memory</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">gauge</span></span><br><span class="line">    <span class="attr">help:</span> <span class="string">'OS physical memory, used and available.'</span></span><br><span class="line">    <span class="attr">value_label:</span> <span class="string">'state'</span></span><br><span class="line">    <span class="attr">values:</span> <span class="string">[used,</span> <span class="string">available]</span></span><br><span class="line">    <span class="attr">query:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">SELECT</span></span><br><span class="line">        <span class="string">(total_physical_memory_kb</span> <span class="bullet">-</span> <span class="string">available_physical_memory_kb)</span> <span class="string">*</span> <span class="number">1024</span> <span class="string">AS</span> <span class="string">used,</span></span><br><span class="line">        <span class="string">available_physical_memory_kb</span> <span class="string">*</span> <span class="number">1024</span> <span class="string">AS</span> <span class="string">available</span></span><br><span class="line">      <span class="string">FROM</span> <span class="string">sys.dm_os_sys_memory</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metric_name:</span> <span class="string">mssql_os_page_file</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">gauge</span></span><br><span class="line">    <span class="attr">help:</span> <span class="string">'OS page file, used and available.'</span></span><br><span class="line">    <span class="attr">value_label:</span> <span class="string">'state'</span></span><br><span class="line">    <span class="attr">values:</span> <span class="string">[used,</span> <span class="string">available]</span></span><br><span class="line">    <span class="attr">query:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">SELECT</span></span><br><span class="line">        <span class="string">(total_page_file_kb</span> <span class="bullet">-</span> <span class="string">available_page_file_kb)</span> <span class="string">*</span> <span class="number">1024</span> <span class="string">AS</span> <span class="string">used,</span></span><br><span class="line">        <span class="string">available_page_file_kb</span> <span class="string">*</span> <span class="number">1024</span> <span class="string">AS</span> <span class="string">available</span></span><br><span class="line">      <span class="string">FROM</span> <span class="string">sys.dm_os_sys_memory</span></span><br><span class="line"></span><br><span class="line"><span class="attr">queries:</span></span><br><span class="line">  <span class="comment"># Populates `mssql_io_stall` and `mssql_io_stall_total`</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">query_name:</span> <span class="string">mssql_io_stall</span></span><br><span class="line">    <span class="attr">query:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">SELECT</span></span><br><span class="line">        <span class="string">cast(DB_Name(a.database_id)</span> <span class="string">as</span> <span class="string">varchar)</span> <span class="string">AS</span> <span class="string">[db],</span></span><br><span class="line">        <span class="string">sum(io_stall_read_ms)</span> <span class="string">/</span> <span class="number">1000.0</span> <span class="string">AS</span> <span class="string">[read],</span></span><br><span class="line">        <span class="string">sum(io_stall_write_ms)</span> <span class="string">/</span> <span class="number">1000.0</span> <span class="string">AS</span> <span class="string">[write],</span></span><br><span class="line">        <span class="string">sum(io_stall)</span> <span class="string">/</span> <span class="number">1000.0</span> <span class="string">AS</span> <span class="string">io_stall</span></span><br><span class="line">      <span class="string">FROM</span></span><br><span class="line">        <span class="string">sys.dm_io_virtual_file_stats(null,</span> <span class="literal">null</span><span class="string">)</span> <span class="string">a</span></span><br><span class="line">      <span class="string">INNER</span> <span class="string">JOIN</span> <span class="string">sys.master_files</span> <span class="string">b</span> <span class="string">ON</span> <span class="string">a.database_id</span> <span class="string">=</span> <span class="string">b.database_id</span> <span class="string">AND</span> <span class="string">a.file_id</span> <span class="string">=</span> <span class="string">b.file_id</span></span><br><span class="line">      <span class="string">GROUP</span> <span class="string">BY</span> <span class="string">a.database_id</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Populates `mssql_resident_memory_bytes`, `mssql_virtual_memory_bytes`, `mssql_memory_utilization_percentage` and</span></span><br><span class="line">  <span class="comment"># `mssql_page_fault_count`.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">query_name:</span> <span class="string">mssql_process_memory</span></span><br><span class="line">    <span class="attr">query:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">SELECT</span></span><br><span class="line">        <span class="string">physical_memory_in_use_kb</span> <span class="string">*</span> <span class="number">1024</span> <span class="string">AS</span> <span class="string">resident_memory_bytes,</span></span><br><span class="line">        <span class="string">virtual_address_space_committed_kb</span> <span class="string">*</span> <span class="number">1024</span> <span class="string">AS</span> <span class="string">virtual_memory_bytes,</span></span><br><span class="line">        <span class="string">memory_utilization_percentage,</span></span><br><span class="line">        <span class="string">page_fault_count</span></span><br><span class="line">      <span class="string">FROM</span> <span class="string">sys.dm_os_process_memory</span></span><br></pre></td></tr></table></figure></p><blockquote><p>这里提供的是对SQL Server的一些系统metrics</p></blockquote><p>修改后,启动sql exporter<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./sql_exporter</span><br><span class="line"></span><br><span class="line">I0601 06:58:45.515826   32145 main.go:52] Starting SQL exporter (version=0.5, branch=master, revision=fc5ed07ee38c5b90bab285392c43edfe32d271c5) (go=go1.11.3, user=root@f24ba5099571, date=20190114-09:24:06)</span><br><span class="line">I0601 06:58:45.515996   32145 config.go:18] Loading configuration from sql_exporter.yml</span><br><span class="line">I0601 06:58:45.516658   32145 config.go:131] Loaded collector "mssql_standard" from mssql_standard.collector.yml</span><br><span class="line">I0601 06:58:45.516750   32145 main.go:67] Listening on :9399</span><br></pre></td></tr></table></figure></p><p>sql exporter启动并使用了9399端口</p><p>修改Prometheus.yml,添加sql server target,并重启Prometheus<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">"prometheus"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># metrics_path defaults to '/metrics'</span></span><br><span class="line">    <span class="comment"># scheme defaults to 'http'.</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">["localhost:9090"]</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">"sql_exporter"</span></span><br><span class="line">    <span class="attr">honor_timestamps:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">["localhost:9399"]</span></span><br></pre></td></tr></table></figure></p><img src="/2022/06/01/Prometheus/sqlp.png"><p>在Prometheus <a href="http://localhost:9090/targets" target="_blank" rel="noopener">http://localhost:9090/targets</a> 上就可以看到已经启动的sql exporter,可以在 <a href="http://localhost:9399/metrics" target="_blank" rel="noopener">http://localhost:9399/metrics</a> 看到已经收到的SQL Server metrics<br><img src="/2022/06/01/Prometheus/sqlm.png"></p><hr><h2 id="3-Zookeeper-Exporter"><a href="#3-Zookeeper-Exporter" class="headerlink" title="3. Zookeeper Exporter"></a>3. Zookeeper Exporter</h2><p>zookeeper从3.6版本之后就提供了Prometheus相关的配置</p><p>安装zookeeper 3.6或更新的版本,将关于Prometheus相关的配置打开<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://prometheus.io Metrics Exporter</span></span><br><span class="line"><span class="string">metricsProvider.className=org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider</span></span><br><span class="line"><span class="comment">#metricsProvider.httpHost=0.0.0.0</span></span><br><span class="line"><span class="string">metricsProvider.httpPort=7000</span></span><br><span class="line"><span class="string">metricsProvider.exportJvmInfo=true</span></span><br></pre></td></tr></table></figure></p><p>在Prometheus.yml中添加zookeeper target并重启Prometheus<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">zookeeper</span></span><br><span class="line">  <span class="attr">honor_timestamps:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">1m</span></span><br><span class="line">  <span class="attr">scrape_timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">metrics_path:</span> <span class="string">/metrics</span></span><br><span class="line">  <span class="attr">scheme:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">follow_redirects:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">enable_http2:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">file_sd_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">files:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">targets/zookeeper.json</span></span><br><span class="line">    <span class="attr">refresh_interval:</span> <span class="string">5m</span></span><br></pre></td></tr></table></figure></p><blockquote><p>此处使用了- files来配置zookeeper,使得对zookeeper的配置与Prometheus.yml解耦</p></blockquote><p>在Prometheus根目录/targets下的zookeeper.json<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"labels"</span>: &#123;</span><br><span class="line">            <span class="attr">"environment"</span>: <span class="string">"zookeeper01"</span>,</span><br><span class="line">            <span class="attr">"job"</span>: <span class="string">"zookeeper"</span>,</span><br><span class="line">            <span class="attr">"alert"</span>: <span class="string">"false"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"targets"</span>: [</span><br><span class="line">            <span class="string">"ip1:7000"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"labels"</span>: &#123;</span><br><span class="line">            <span class="attr">"environment"</span>: <span class="string">"zookeeper02"</span>,</span><br><span class="line">            <span class="attr">"job"</span>: <span class="string">"zookeeper"</span>,</span><br><span class="line">            <span class="attr">"alert"</span>: <span class="string">"false"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"targets"</span>: [</span><br><span class="line">            <span class="string">"ip2:7000"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><img src="/2022/06/01/Prometheus/zkp.png"><p>启动zookeeper之后,在 <a href="http://localhost:9090/targets" target="_blank" rel="noopener">http://localhost:9090/targets</a> 可以看到新的zookeeper target,同样的在 <a href="http://ip1:7000/metrics" target="_blank" rel="noopener">http://ip1:7000/metrics</a> 可以看到zookeeper的metrics<br><img src="/2022/06/01/Prometheus/zkm.png"></p><hr><h2 id="4-Grafana"><a href="#4-Grafana" class="headerlink" title="4. Grafana"></a>4. Grafana</h2><p>将收集到的metrics转化为更直观的可视化dashboard.</p><p>不在赘述Grafana的安装,只说一下Grafana中dashboard的创建,已zookeeper为例.</p><p>Grafana提供了大量的dashboard模板 <a href="https://grafana.com/grafana/dashboards/" target="_blank" rel="noopener">https://grafana.com/grafana/dashboards/</a> ,找到zookeeper的dashboard <a href="https://grafana.com/grafana/dashboards/10465" target="_blank" rel="noopener">https://grafana.com/grafana/dashboards/10465</a> 并记下 ID <code>10465</code></p><p>在Grafana中添加新的datasource<br><img src="/2022/06/01/Prometheus/pdata.png"><br><img src="/2022/06/01/Prometheus/pdata2.png"><br><img src="/2022/06/01/Prometheus/pdata3.png"><br>import zookeeper dashboard<br><img src="/2022/06/01/Prometheus/dash.png"><br><img src="/2022/06/01/Prometheus/dash2.png"></p><p>然后在dashboard中就可以看到关于zookeeper的metrics了<br><img src="/2022/06/01/Prometheus/dash3.png"></p><p>为dashboard添加新的filter<br>在dashboard中点击右上角齿轮dashboard settings,选择Variables添加environment<br><img src="/2022/06/01/Prometheus/va.png"><br><img src="/2022/06/01/Prometheus/va2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Prometheus&quot;&gt;&lt;a href=&quot;#Prometheus&quot; class=&quot;headerlink&quot; title=&quot;Prometheus&quot;&gt;&lt;/a&gt;Prometheus&lt;/h1&gt;&lt;h3 id=&quot;Prometheus-is-an-open-source-syst</summary>
      
    
    
    
    
    <category term="Prometheus" scheme="http://yoursite.com/tags/Prometheus/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>clickhouse集群相关</title>
    <link href="http://yoursite.com/2021/09/09/clickhouse%E9%9B%86%E7%BE%A4%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2021/09/09/clickhouse%E9%9B%86%E7%BE%A4%E7%9B%B8%E5%85%B3/</id>
    <published>2021-09-09T15:41:49.000Z</published>
    <updated>2021-09-09T15:56:49.495Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-安装一个2节点2实例的集群"><a href="#1-安装一个2节点2实例的集群" class="headerlink" title="1. 安装一个2节点2实例的集群"></a>1. 安装一个2节点2实例的集群</h3><h3 id="2-2节点4实例的集群"><a href="#2-2节点4实例的集群" class="headerlink" title="2. 2节点4实例的集群"></a>2. 2节点4实例的集群</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-安装一个2节点2实例的集群&quot;&gt;&lt;a href=&quot;#1-安装一个2节点2实例的集群&quot; class=&quot;headerlink&quot; title=&quot;1. 安装一个2节点2实例的集群&quot;&gt;&lt;/a&gt;1. 安装一个2节点2实例的集群&lt;/h3&gt;&lt;h3 id=&quot;2-2节点4实例的集群</summary>
      
    
    
    
    
    <category term="clickhouse" scheme="http://yoursite.com/tags/clickhouse/"/>
    
  </entry>
  
  <entry>
    <title>文</title>
    <link href="http://yoursite.com/2021/06/20/%E6%91%98%E6%8A%84/"/>
    <id>http://yoursite.com/2021/06/20/%E6%91%98%E6%8A%84/</id>
    <published>2021-06-20T11:59:46.000Z</published>
    <updated>2022-06-21T18:16:58.603Z</updated>
    
    <content type="html"><![CDATA[<p><strong><strong>文字是个很奇妙的东西,它可能无法准确的描述你在某一刻的心情,但却能让你读到它的时候感受笔者融入在里面的到无穷的力量或者无尽的感情.</strong></strong></p><a id="more"></a><hr><blockquote><p><strong><strong>2022-06-20 摘自 &lt;&lt;种种可能&gt;&gt;</strong></strong><br>&nbsp;<br>我偏爱写诗的荒谬<br>胜过不写诗的荒谬<br>&nbsp;</p></blockquote><hr><hr><blockquote><p><strong><strong>2022-05-22 摘自微博</strong></strong><br>&nbsp;<br>小圆,最近过得好吗,好久没有跟你说说话了.<br>今天是我独自居家隔离的第39天,也是我经历过最漫长的一次倒春寒.<br>很奇怪,有时我拉开窗帘看到外面阳光晴好,室内却依旧冷飕飕的,更不用说阴雨狂风吹得玻璃哐哐作响的日子了.以至于我现在还是空调电热毯羽绒被齐上阵,包括毛绒绒的厚睡衣和地板袜.<br>偶尔感受到春天到来,是因为核酸检测碰巧安排在温暖的中午.以前我出门时仿佛没有耳机就不会走路,现在不了,现在我兜里只揣一瓶酒精喷雾,张开耳朵想听听人们聊天的声音、走路的声音,还有鸟扑扇羽毛的声音.<br>我竟然还掏出手机对着小区里一棵很丑的树反复拍照,可惜在拍出满意的照片前就被志愿者赶回了家里.<br>除了核酸检测点,这39天里我去得最多的地方分别是厨房、客厅和卧室,而我听过最多的声音分别是清晨急促的敲门声、通过大喇叭反复播放的人声,还有拧开燃气灶时点火针啪啪作响的声音.<br>在此之前我从没正经做过一顿饭,当下却成了罪无可赦.但幸好我还有两个锅,一个是朋友之前来我家做饭时带来的,还有一个是去年收到的礼物.有它们,虽然厨艺不佳,倒也不至于在2022年的都市被饿死.<br>生理上我活了下来,也没有被病毒侵害,但依旧感觉有什么在流逝,逐渐变得干涸.我从平静到急躁到消沉,大脑比被棉签捅了几十次的口腔和鼻腔还麻木,没有心情再点开一部电影翻开一页书.<br>键盘噼里啪啦地响,没打下一个有用的字.<br>我疯狂在想等结束时要抛下一切去逛去跑去拥抱,好像那样才能撬开囚禁的灵魂.有干柴掉进我身体里烧愈烈的火,找不到源头也无法熄灭,燥得我干裂上火.<br>直到昨天,火势突然平息,原来用水龙头不行,要用整片翻浪的海.<br>我想我确实应该感谢你,无限被拉长的漠然的知觉,此刻重新回归本线,日复一日沙砾磨钝的时针嘀嗒,终于拨正误差.<br>春天望着窗台无法触碰到我,未可知的已经不重要了.<br>因为你确定要带我去找回夏天.<code></code><br>&nbsp;</p></blockquote><p>和上一条来自同一个博主,我不认识她所说的小圆,没听过她们的故事,可不知道怎么的,平静的句子里总能感受到狂热的感情.</p><hr><hr><blockquote><p><strong><strong>2021-05-01 摘自微博</strong></strong><br>&nbsp;<br>小圆,最近很忙吧,忙里偷闲中我去了趟重庆.<br>在北京住着的时候其实从没有跟你处在同一城市的实感,直到有一天我被堵在路上,透过出租车的后窗看天边的云好像才明白了原因.你应该见惯了吧,北京的云总是很厚,比天暗,傍晚的时候就沉甸甸地挂在不太高的地方,像远山,压住了百年红墙黄瓦和无数正在挣扎的梦想.<br>到重庆我才感觉像又见了你一次,因为你跟这里的云一样.大部分时候都雾一般浮在江边的苍郁山头和高高的玻璃大楼上,很轻很薄却有力量,可以遮住太阳,晴天就松松软软鼓成一团,随时可以捏来一角尝尝味道.<br>云和你走路都乘风,14岁时那双长着小小翅膀的鞋子,像是一直穿在你脚上.<br>重庆的楼很高很密,走在高大楼宇间曲折坡道上的每个人都很小,快乐却一下开阔起来.路过南开的时候看到正在上体育课的中学生,转着身子聊天或是把自己摔在软垫上,叫不出名字的树落下大片葱葱的影子,却怎么都遮不住操场上大把可以用来浪费的自在好日光,我在围栏边的树荫下看了一会儿,走的时候说真羡慕啊,不知道是替你觉得还是替自己觉得.<br>你是怎样离开重庆的呢,我时常听到飞机轰隆掠过的声音,跟几年前应该没有什么区别,伴着解放碑未落的暖黄色灯光一起落进我的梦里.我梦见你还很小,对这个世界的一切都还懵懵懂懂,书包摊在操场旁的乒乓球台上,你轻巧坐在上面,晃着腿问我有没有作业要跟你一起写.<br>而阳台抛出的那只纸飞机,早就飞过了乒乓球台和嘉陵江,飞向一千公里外的北京,飞向一万公里外的波士顿.<br>你好像越来越远了,但没关系,见不到你的时候我就来重庆看看云,谁都抓不住的渺渺的云.<br>&nbsp;</p></blockquote><p>读到这段话的时候我也刚刚在重庆玩了一圈回到北京,感触很深倒不是因为我们的旅途相似,而是被其中蕴含的思念所感染.<br>那一天北京的云真的很好看,天也很蓝很干净,回想起一周前我在重庆的日子却因为接连几天的阴霾错过了云和蓝天.<br>匆匆三天,我虽然也路过了南开看到了同样的山头和玻璃大楼却无法感受到如文字中所描述的感情,可能太过匆忙,要是也慢下来好好看一看就好了,看一看在上体育课的学生和教室窗户反射出的温暖的灯光.这看似简简单单的几个字记录了笔者无穷的记忆和记忆所能勾起的无穷的思念吧.<br>科技的发达让无论隔着距离多远、时差多久的人们通过网络见面通过飞机相遇,但其中的思念却无法因科技而削减一分.<br>我没有相似的经历和远在几万公里外的朋友,但不知道为什么会深深陷入到这几句话中,也许是我很久没有停下来看看蓝天和白云了,也许是我很羡慕有一个虽远隔万里却仍在思念的人吧.</p><hr><hr><blockquote><p><strong><strong>2021-09-09 &lt;&lt;银翼杀手&gt;&gt;</strong></strong><br>&nbsp;<br>I’ve seen things you people wouldn’t believe.Attack ships on fire off the shoulder of Orion.I’ve watched c-beams glitter in the dark near the Tannhauser Gate.All those … moments will be lost in time, like tears…in rain.<br>我所见过的事物,你们人类绝对无法置信,我目睹战舰在猎户悬臂起火燃烧,我看着C射线在唐怀瑟之门附近的黑暗中闪烁,所有这些时刻,终将流逝在时光中,亦如眼泪,消失在雨中.<br>&nbsp;</p></blockquote><p>这可能是我听过的最浪漫的台词了,它甚至不需要用任何镜头去描述那广袤的深空,只是Roy短短的几句关于自己回忆的话就把人类永远无法看到的画面展示在了眼前.<br>而复制人Roy的这番话也让我们重新认识到生命的意义不在于时间上的延续,而在于其瞬间爆发出来的光彩和由之而来的感性体验.</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;strong&gt;文字是个很奇妙的东西,它可能无法准确的描述你在某一刻的心情,但却能让你读到它的时候感受笔者融入在里面的到无穷的力量或者无尽的感情.&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="随笔" scheme="http://yoursite.com/tags/随笔/"/>
    
  </entry>
  
  <entry>
    <title>天宫</title>
    <link href="http://yoursite.com/2021/05/02/%E5%A4%A9%E5%AE%AB/"/>
    <id>http://yoursite.com/2021/05/02/%E5%A4%A9%E5%AE%AB/</id>
    <published>2021-05-02T02:33:45.000Z</published>
    <updated>2021-05-03T08:25:12.131Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><strong><em>“不知天上宫阙</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><strong><em>今夕是何年”</em></strong></p><img src="/2021/05/02/天宫/fashe.png">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;strong&gt;&lt;em&gt;“不知天上宫阙&lt;/em&gt;&lt;/strong&gt;</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://yoursite.com/tags/随笔/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架下的Log</title>
    <link href="http://yoursite.com/2020/07/02/JsavSpring%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84Log/"/>
    <id>http://yoursite.com/2020/07/02/JsavSpring%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84Log/</id>
    <published>2020-07-02T06:17:55.000Z</published>
    <updated>2021-04-22T04:43:17.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于Spring的log"><a href="#关于Spring的log" class="headerlink" title="关于Spring的log"></a>关于Spring的log</h1><p>Spring框架默认使用Logback用于日志。除了Spring自己框架使用了日志以外，我们在业务代码里也有使用log<br>的需求，因此时常需要获得一个log实例，获得一个log实例的方式很多，根据使用的不同的包，有很多种方<br>式，举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CommonsLog</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.apache.commons.logging.Log log =org.apache.commons.logging.LogFactory.getLog(LogExample<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="meta">@Flogger</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> com.google.common.flogger.FluentLogger log =com.google.common.flogger.FluentLogger.forEnclosingClass();</span><br><span class="line"><span class="meta">@JBossLog</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.jboss.logging.Logger log =org.jboss.logging.Logger.getLogger(LogExample<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="meta">@Log</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.util.logging.Logger log =java.util.logging.Logger.getLogger(LogExample<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"><span class="meta">@Log</span>4j</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.apache.log4j.Logger log =org.apache.log4j.Logger.getLogger(LogExample<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="meta">@Log</span>4j</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.apache.logging.log4j.Logger log =org.apache.logging.log4j.LogManager.getLogger(LogExample<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.slf4j.Logger log =org.slf4j.LoggerFactory.getLogger(LogExample<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="meta">@XSlf</span>4j</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.slf4j.ext.XLogger log =org.slf4j.ext.XLoggerFactory.getXLogger(LogExample<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>这些不同的log提供的功能都大同小异，对我们来说，只是格式化有点差异而已。</p><p>值得一提的是，lombok这个插件为我们提供了直接生成log的便利，当我们在类上标注上面代码框中的注解<br>时，会自动为我们生成一个log实例供我们使用，不同的注解生成对应库的log，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CommonsLog</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//就相当于：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogExample</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.apache.commons.logging.Log log</span><br><span class="line">= org.apache.commons.logging.LogFactory.getLog(LogExample<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般系统出了bug，我们极大依赖于日志，但我在log的使用过程中，发现有这么几个问题：</p><ol><li>log过少<br>即该打log的地方没有打log，导致完全不知道系统中发生了什么，只能根据异常去倒查，异常实际上丢<br>失了一些信息，比如调用参数信息等，debug很困难。</li><li>log过多<br>像我做的一些模块，之前没有经验，喜欢把参数信息和返回值都输出，有时候就会日志洪泛，像我们这<br>块儿，返回值有时候就是一些文章内容什么的，一下刷十几屏，淹没了有效信息。</li><li>log在平时看的时候过多，在debug时过少<br>这是上两个的结合体了，有时候debug需要的信息，日常没出错时不需要，但我们也没法断定说这什么<br>时候出错，什么时候不出错。所以有些地方的日志就变成了不出错时太多，出错时太少。</li><li>有些框架日志明显不需要，比如我们连接eureka的时候，每 5 分钟发一次心跳包，info级别日志，几天不<br>看，这个心跳包日志就完全刷屏了，看着就很烦，如下图：</li></ol><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">2019-04-29 16:24:07.337 INFO 1 --- [trap-executor-0]</span><br><span class="line">c.n.d.s.r.aws.ConfigClusterResolver : Resolving eureka endpoints</span><br><span class="line">via configuration</span><br><span class="line">2019-04-29 16:29:07.337 INFO 1 --- [trap-executor-0]</span><br><span class="line">c.n.d.s.r.aws.ConfigClusterResolver : Resolving eureka endpoints</span><br><span class="line">via configuration</span><br><span class="line">2019-04-29 16:34:07.338 INFO 1 --- [trap-executor-0]</span><br><span class="line">c.n.d.s.r.aws.ConfigClusterResolver : Resolving eureka endpoints</span><br><span class="line">via configuration</span><br><span class="line">2019-04-29 16:39:07.339 INFO 1 --- [trap-executor-0]</span><br><span class="line">c.n.d.s.r.aws.ConfigClusterResolver : Resolving eureka endpoints</span><br><span class="line">via configuration</span><br><span class="line">2019-04-29 16:44:07.339 INFO 1 --- [trap-executor-0]</span><br><span class="line">c.n.d.s.r.aws.ConfigClusterResolver : Resolving eureka endpoints</span><br><span class="line">via configuration</span><br><span class="line">2019-04-29 16:49:07.340 INFO 1 --- [trap-executor-0]</span><br><span class="line">c.n.d.s.r.aws.ConfigClusterResolver : Resolving eureka endpoints</span><br><span class="line">via configuration</span><br></pre></td></tr></table></figure><h5 id="日志输出的过多或者不够，会造成出现问题就要改代码、重新打包上传、再部署、再运行，这样的一个步骤，"><a href="#日志输出的过多或者不够，会造成出现问题就要改代码、重新打包上传、再部署、再运行，这样的一个步骤，" class="headerlink" title="日志输出的过多或者不够，会造成出现问题就要改代码、重新打包上传、再部署、再运行，这样的一个步骤，"></a>日志输出的过多或者不够，会造成出现问题就要改代码、重新打包上传、再部署、再运行，这样的一个步骤，</h5><p>debug之后又要原路改回去。这样的事情我干过不少次。</p><p>所以引出了最近的几点思考，试简单总结如下：</p><p>日志分级</p><p>一般来讲，日志分为 5 级，trace、debug、info、warn、error，从下到上依次严重，我们在代码里对应的一般<br>就是log.trace(),log.debug()这样方法。</p><p>我们把debug需要的那部分信息通过log.debug()输出，正常日志通过info输出，这样就把不同级别的日志区<br>分开了，当我们需要debug时，代码不需要改动，只需要在参数中改变日志的level，就能看到debug日志，修<br>改完之后把debug日志关闭即可。这样就避免了频繁改变文件打包。</p><p>###<strong>Spring</strong> 的 <strong>log</strong> 日志级别设置</p><p>spring默认使用logback记录日志，日志级别通过logging.level.xxx参数设置。其中logging.level.是<br>通用前缀，xxx是具体包名。如：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.level.com.mycompany.tahiti.attachment.aop.ServiceLogger: debug</span><br></pre></td></tr></table></figure><p>是指com.mycompany.tahiti.attachment.aop.ServiceLogger这个包里生成的log使用debug级别。<br>而其他的log仍然使用默认的级别。如果要更改默认级别，可以使用以下命令修改：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.level.root=debug</span><br></pre></td></tr></table></figure><p>但在Spring中特别不建议这么做，因为我们Spring框架中也会同样输出debug日志，于是日志被各种debug信息<br>占满，完全没法看了。一般还是针对需要debug的那几个包设置debug级别就足够了。</p><p>这个参数可以直接加在application.yaml文件中，也可以加在application.apprities文件里，当我们<br>使用k8s时，还可以直接在k8s中增加args，如下图：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">template:</span><br><span class="line">spec:</span><br><span class="line">containers:</span><br><span class="line">args: ["--logging.level.root=info","--arg2=value2"]</span><br></pre></td></tr></table></figure><h2 id="所以我们上面提出的第四个问题也解决了，我们先找到框架中输出这个心跳包的类，然后直接将其日志级别设"><a href="#所以我们上面提出的第四个问题也解决了，我们先找到框架中输出这个心跳包的类，然后直接将其日志级别设" class="headerlink" title="所以我们上面提出的第四个问题也解决了，我们先找到框架中输出这个心跳包的类，然后直接将其日志级别设"></a>所以我们上面提出的第四个问题也解决了，我们先找到框架中输出这个心跳包的类，然后直接将其日志级别设</h2><p>置为warn。</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.level.com.netflix.discovery.shared.resolver.aws.ConfigClusterResolver: warn</span><br></pre></td></tr></table></figure><p>这样这个包的info信息就不生成了。</p><p>如果我们自己的log也想使用这个机制，建议使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@lombok</span>.extern.apachecommons.CommonsLog</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>或者直接手写一个log：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.apache.commons.logging.Log log =org.apache.commons.logging.LogFactory.getLog(LogExample<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>其他的log包可能有的不能和spring的配置协作，未验证，因此最好不用。如果再观察一下配置文件的解析，发<br>现配置文件是由:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.logging.LoggingApplicationListener</span><br></pre></td></tr></table></figure><p>这个包来解析的。先是解析配置文件，建立了一个class的fullname到level的map，将这个map注册到<br>LogFactory中，我们上面的log是通过LogFactory静态方法取得的，这样就可以确保获得的log有正确的<br>level。这可以说是factory的经典应用了。</p><p><strong>log exception</strong></p><p>另外，当我们记录exception时，有时候会写这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    dosth();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        log.error(<span class="string">"sth bad happened"</span>);</span><br><span class="line">        e.printStack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样造成了一个隐含问题，e.printStack()是将数据输出到stdout中，当log的输出源也是stdout时，这<br>样没有问题，当log的输出源被改为文件后，这两个输出就不在一起了。因此，建议使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.error(<span class="string">"sth bad happened"</span>, e);</span><br></pre></td></tr></table></figure></p><h3 id="log-与-AOP"><a href="#log-与-AOP" class="headerlink" title="log 与 AOP"></a><strong>log</strong> 与 <strong>AOP</strong></h3><p>有时候，我们需要记录系统进行了哪些操作，比如想记录每一次对controller的调用，那么，我们要在每个方法<br>里加一个log.info(“xxx方法被调用”)，这样显然很麻烦，也影响代码的整洁美观。利用SpringAOP，我们<br>可以建立一个这样的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@CommonsLog</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLogger</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(*com.mycompany.tahiti.attachment.service.impl.AttachmentServiceImpl2.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"action()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">logRequest</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        log.info(String.format(<span class="string">"--------%s方法被调用"</span>,</span><br><span class="line">        joinPoint.getSignature()));</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(String.format(<span class="string">"共收到%d个参数%s"</span>,</span><br><span class="line">            joinPoint.getArgs().length,</span><br><span class="line">            joinPoint.getArgs().length == <span class="number">0</span>? <span class="string">""</span> : <span class="string">"，以下是详细参数信息："</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i != joinPoint.getArgs().length; ++i) &#123;</span><br><span class="line">                Object arg = joinPoint.getArgs()[i];</span><br><span class="line">                <span class="keyword">if</span> (Collection<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">arg</span>.<span class="title">getClass</span>())) </span>&#123;</span><br><span class="line">                    log.debug(String.format(<span class="string">"参数%d是容器类，共有%d个元素"</span>, i,((Collection) arg).size()));</span><br><span class="line">                    log.debug(String.format(<span class="string">" %s"</span>, ((Collection&lt;?&gt;)arg).stream().map(Object::toString).collect(Collectors.joining(<span class="string">","</span>))));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Map<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">arg</span>.<span class="title">getClass</span>())) </span>&#123;</span><br><span class="line">                    log.debug(String.format(<span class="string">"参数%d是Map类，共有%d个元素"</span>, i,((Map) arg).size()));</span><br><span class="line">                    StringBuilder sb = <span class="keyword">new</span> StringBuilder();((Map&lt;?, ?&gt;) arg).forEach((k, v) -&gt;sb.append(<span class="string">"key="</span>).append(k).append(<span class="string">"value="</span>).append(v).append(<span class="string">"; "</span>));</span><br><span class="line">                    log.debug(String.format(<span class="string">" %s"</span>, sb.toString()));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(String.format(<span class="string">"参数%d为：%s"</span>, i,arg.toString()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Object retValue = joinPoint.proceed(joinPoint.getArgs());</span><br><span class="line">        log.info(String.format(<span class="string">"------%s方法返回"</span>,</span><br><span class="line">        joinPoint.getSignature()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Collection<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">retValue</span>.<span class="title">getClass</span>())) </span>&#123;</span><br><span class="line">                log.debug(String.format(<span class="string">"返回值是容器类，共有%d个元素"</span>,((Collection) retValue).size()));</span><br><span class="line">                log.debug(String.format(<span class="string">" %s"</span>, ((Collection&lt;?&gt;)retValue).stream().map(Object::toString).collect(Collectors.joining(<span class="string">","</span>))));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Map<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">retValue</span>.<span class="title">getClass</span>())) </span>&#123;</span><br><span class="line">                log.debug(String.format(<span class="string">"返回值是Map类，共有%d个元素"</span>, ((Map)retValue).size()));</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();((Map&lt;?, ?&gt;) retValue).forEach((k, v) -&gt;sb.append(<span class="string">"key="</span>).append(k).append(<span class="string">"value="</span>).append(v).append(<span class="string">"; "</span>));</span><br><span class="line">                log.debug(String.format(<span class="string">" %s"</span>, sb.toString()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.debug(String.format(<span class="string">"返回值为：%s"</span>,retValue.toString()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> retValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以保证每一个方法调用时都能够产生日志，不用每次手写日志。</p><h3 id="Log-与时区问题"><a href="#Log-与时区问题" class="headerlink" title="Log 与时区问题"></a><strong>Log</strong> 与时区问题</h3><p>我们经常发现我们的日志中的时间和北京时间相差八小时，大多数时候这一点我们自己看的时候在脑子里做个<br>时间转换就可以了，但这样还是容易让人疑惑和烦躁，因此我们需要某种方式来统一时间。</p><p>在linux中，当地时间由/etc/localtime确定的，而这个文件实际上是一个软链，链接<br>到/var/db/timezone/zoneinfo/Asia/Shanghai。因此，如果要改变linux的标准时间，只需要改变这个<br>软链接的指向即可。</p><p>我们现在主要用Docker进行部署，一般来讲，Python语言的项目打的包会有一个完整的linux环境，因为它依赖<br>的东西太多了，pip install甚至还要求docker镜像里有完整的开发环境，所以一个包经常有1.2G以上。但<br>java的docker就精简很多，甚至最常用的ls命令都没有打包到java:8这个基础镜像里，因此一个包经常只有<br>100M左右。我们分别以这两种语言的docker包为例，实例如何正确显示当地时间。</p><ol><li>Java<br>只需要在Dockerfile中添加一个环境变量，因为java的极简包里什么都没有，也不通过/etc/localtime<br>来确定时间。</li></ol><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk: 8 -alpine</span><br><span class="line">WORKDIR /app</span><br><span class="line">ENV TZ Asia/Shanghai # 就是这一句</span><br><span class="line">COPY target/ROOT.jar.</span><br><span class="line">ENTRYPOINT ["java", "-XX:+UnlockExperimentalVMOptions", "-</span><br><span class="line">XX:+UseCGroupMemoryLimitForHeap", "-jar", "ROOT.jar"]</span><br></pre></td></tr></table></figure><ol start="2"><li>python项目<br>在Dockerfile中直接更改/etc/localtime的软链。</li></ol><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM rappdw/docker-java-python:latest</span><br><span class="line">RUN mkdir -p ~/.pip</span><br><span class="line">RUN echo "[global]\n\</span><br><span class="line">trusted-host = mirrors.aliyun.com\n\</span><br><span class="line">index-url = http://mirrors.aliyun.com/pypi/simple" &gt; ~/.pip/pip.conf</span><br><span class="line">COPY requirements.txt ./</span><br><span class="line">RUN pip3 install --no-cache-dir -r requirements.txt</span><br><span class="line">COPY ./ ./</span><br><span class="line">RUN ln -fs /usr/share/zoneinfo/Asia/Shanghai /etc/localtime </span><br><span class="line"><span class="meta">#</span><span class="bash">主要是这一句</span></span><br><span class="line">RUN chmod a+x run.sh</span><br><span class="line">ENTRYPOINT ["/run.sh"]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于Spring的log&quot;&gt;&lt;a href=&quot;#关于Spring的log&quot; class=&quot;headerlink&quot; title=&quot;关于Spring的log&quot;&gt;&lt;/a&gt;关于Spring的log&lt;/h1&gt;&lt;p&gt;Spring框架默认使用Logback用于日志。除了Spri</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化与Json</title>
    <link href="http://yoursite.com/2020/05/22/Jsava%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8EJson/"/>
    <id>http://yoursite.com/2020/05/22/Jsava%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8EJson/</id>
    <published>2020-05-22T06:16:30.000Z</published>
    <updated>2021-04-22T04:43:17.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java序列化与Json的三个库"><a href="#java序列化与Json的三个库" class="headerlink" title="java序列化与Json的三个库"></a>java序列化与Json的三个库</h1><h3 id="如果一个运行时的数据需要被持久化，或者说需要通过网络进行通信，那么就涉及到对象的序列化问题。比如"><a href="#如果一个运行时的数据需要被持久化，或者说需要通过网络进行通信，那么就涉及到对象的序列化问题。比如" class="headerlink" title="如果一个运行时的数据需要被持久化，或者说需要通过网络进行通信，那么就涉及到对象的序列化问题。比如"></a>如果一个运行时的数据需要被持久化，或者说需要通过网络进行通信，那么就涉及到对象的序列化问题。比如</h3><p>说你在程序中写了一个sql，大概是这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT into student (student_id,`name`) values ( 121212 ,null)</span><br></pre></td></tr></table></figure><p>这个sql要传输到数据库，就必须进行序列化，比如说，null为什么会被识别为Null类型，而不是字符串”null”，<br>121212 为什么被识别为一个数字，而不是字符串。这就依赖于序列化和反序列化的约定。<br>序列化和反序列化在网络编程中更是无处不在。比如现在流行的前后端分离项目，后端接口向前端返回一个对<br>象，在spring boot框架下经常会写成这样代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/student&quot;)</span><br><span class="line">public class StudentController &#123;</span><br><span class="line">@GetMapping(&quot;/random&quot;)</span><br><span class="line">public Student random()&#123;</span><br><span class="line">return new Student( 121212 ,&quot;章银莱&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不做其他设置，前端将收到这样的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;studentId&quot;: 121212</span><br><span class="line">&quot;name&quot;: &quot;章银莱&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就应该好奇，为什么返回了一个json，而不是xml，不是yaml。答案是springboot默认调用jackson，将我<br>们的类对象转换成了一个json字符串。</p><p><strong>java</strong> 对序列化的原生支持</p><p>以前，java提供了一个标记接口，java.io.Serializable，任何实现了这个接口的类，都可以使用java自己<br>的序列化机制，实际上，因为这个接口是个标记接口，在大多数情况下，你什么都不用做。如果一个类要完整<br>的序列化，那么他的包含的所有字段都必须实现该序列化接口，不然就会出现异常。<br>java通过一个序列化序号来识别一个对象，也就是我们经常在实现了java.io.Serializable接口的类里看<br>到这个字段的原因：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID = 1L;</span><br></pre></td></tr></table></figure><p>如果不提供的话，java会用某种默认生成机制生成。在反序列化时，如果序列化号对不上，反序列化会失败。<br>java的默认序列化策略有很多问题：</p><ol><li>序列化的声明过于繁琐。字段必须也实现该接口，否则序列化会失败；父类必须也实现该接口，否则父<br>类的部分不会被序列化。有时候父类我们是改变不了的，那就只能接受无法序列化的结果。</li><li>仅适用于java平台相关语言。其他语言没法直接反序列化，或许通过一些中间件可以支持，但是在有些<br>复杂。在前后端分离的大趋势下，这个限制已经令人无法忍受。</li><li>对修改不太友好。假如说我们没有指定序列化号，那么默认的序列号生成策略会考虑到类的现有字段，<br>假如说你对类的字段进行了修改，那序列化号会发生改变。导致反序列化失败。类的改名也有一样的负<br>面影响。<br>限制众多，显然我们需要更方便、通用性、兼容性更好的序列化方式。</li></ol><h2 id="json-or-xml"><a href="#json-or-xml" class="headerlink" title="json or xml"></a>json or xml</h2><h3 id="序列化并不是某一个具体的行为，而是一类行为的统称。我个人认为，序列化的最终目的和最终结果，是将丰"><a href="#序列化并不是某一个具体的行为，而是一类行为的统称。我个人认为，序列化的最终目的和最终结果，是将丰" class="headerlink" title="序列化并不是某一个具体的行为，而是一类行为的统称。我个人认为，序列化的最终目的和最终结果，是将丰"></a>序列化并不是某一个具体的行为，而是一类行为的统称。我个人认为，序列化的最终目的和最终结果，是将丰</h3><h3 id="富多样的数据转换成一串二进制流，毕竟无论是存储在硬盘中以序列化，还是通过网络接口通信，最后的物理"><a href="#富多样的数据转换成一串二进制流，毕竟无论是存储在硬盘中以序列化，还是通过网络接口通信，最后的物理" class="headerlink" title="富多样的数据转换成一串二进制流，毕竟无论是存储在硬盘中以序列化，还是通过网络接口通信，最后的物理"></a>富多样的数据转换成一串二进制流，毕竟无论是存储在硬盘中以序列化，还是通过网络接口通信，最后的物理</h3><h3 id="设备都只能识别和传输二进制。所以，一个靠谱的序列化方案，显然需要做到二进制层面的一致。那么就有了"><a href="#设备都只能识别和传输二进制。所以，一个靠谱的序列化方案，显然需要做到二进制层面的一致。那么就有了" class="headerlink" title="设备都只能识别和传输二进制。所以，一个靠谱的序列化方案，显然需要做到二进制层面的一致。那么就有了"></a>设备都只能识别和传输二进制。所以，一个靠谱的序列化方案，显然需要做到二进制层面的一致。那么就有了</h3><h3 id="两种序列化的风格，一种是直接序列化为二进制流，另一种是现将纷繁复杂的数据转化为字符串，再将字符串"><a href="#两种序列化的风格，一种是直接序列化为二进制流，另一种是现将纷繁复杂的数据转化为字符串，再将字符串" class="headerlink" title="两种序列化的风格，一种是直接序列化为二进制流，另一种是现将纷繁复杂的数据转化为字符串，再将字符串"></a>两种序列化的风格，一种是直接序列化为二进制流，另一种是现将纷繁复杂的数据转化为字符串，再将字符串</h3><h3 id="编码为二进制流。"><a href="#编码为二进制流。" class="headerlink" title="编码为二进制流。"></a>编码为二进制流。</h3><p>java.io.Serializable采用了第一种方案。但很多更流行的序列化方案都采取了第二种风格。比如最经常<br>使用的json和xml。xml确实有它的优势，但作为资源传递的媒介来说，一堆什么DTD，XSD的规范，可能绕几<br>个月也不一定绕清楚xml的所有规范，另外废话也太多，网络传输中会比json占用更多的宽带。<br>相比之下，json就更有优势。JavaScript原生支持，规范要求应当使用unicode，编码方式默认使用utf-8，字符<br>串必须用双引号，key只能是字符串，必须用双引号，等等。加上spring默认使用json作为REST的资源表述方<br>式，至少在java web开发领域，json几乎已经一统天下。<br>json相比java.io.Serializable有很多优势：</p><ol><li>独立于java语言，可以非常便利地支持多语言。</li><li>不怕类名、类字段修改。因为只要修改对不上，这个字段的值将被直接置为null，而多余的字段将会被直<br>接丢弃。至少不会引发异常——其实还可以通过可选字段名的扩展来实现字段名修改前后的兼容。</li><li>序列化支持非常广泛。因为是将字段直接映射为key:value这种格式，不需要其父类、包含的所有字段<br>实现什么特定接口。<br>所以，在目前的编程环境下，已经不太常见java.io.Serializable这种东西，最多的是看到json大行其<br>道。<br>扩展阅读：数据类型和Json格式，json的标准定义</li></ol><h2 id="look-into-json"><a href="#look-into-json" class="headerlink" title="look into json"></a>look into json</h2><p>一个 <strong>example</strong> 类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.NoArgsConstructor;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.time.LocalDateTime;</span><br><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class Student &#123;</span><br><span class="line">private String id;</span><br><span class="line">private String name;</span><br><span class="line">private Gender gender;</span><br><span class="line">private ZonedDateTime birthday;</span><br><span class="line">private Integer age;</span><br><span class="line">private Teacher teacher;</span><br><span class="line">public enum Gender &#123;</span><br><span class="line">MALE,</span><br><span class="line">FEMALE,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用的三个 <strong>java</strong> 处理 <strong>json</strong> 库</p><p>google的Gson，alibaba的fastJson，还有springBoot默认的jackson。性能如何，这里就不测试了，对于非极端<br>环境下，作为这种非常优秀且使用广泛的库，基本也不需要我们担心这个问题。<br>引入的pom如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">&lt;project.reporting.outputEncoding&gt;UTF-</span><br><span class="line">8 &lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">&lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">&lt;jackson.version&gt;2.9.8&lt;/jackson.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.55&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.8.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.16.20&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jackson-core&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>可见jackson需要引用的pom最多，这有时候也不太方便。三个库的基本用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Gson gson = new GsonBuilder().create();</span><br><span class="line">ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">//fastJson都是静态方法，所以不需要实例化一个解析器</span><br><span class="line">Student student = new Student(&quot;1&quot;, &quot;刘&quot;, Student.Gender.MALE,</span><br><span class="line">ZonedDateTime.now(ZoneId.of(&quot;Asia/Shanghai&quot;)), 18 , teacher);</span><br><span class="line">String fastJsonStr = JSON.toJSONString(student);</span><br><span class="line">String gsonStr = gson.toJson(student);</span><br><span class="line">String jacksonStr = mapper.writeValueAsString(student);</span><br><span class="line">Student student1 = JSON.parseObject(fastJsonStr, Student.class);</span><br><span class="line">Student student2 = gson.fromJson(gsonStr, Student.class);</span><br><span class="line">Student student3 = mapper.readValue(jacksonStr, Student.class);</span><br></pre></td></tr></table></figure><p>特殊类型会被怎么处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">日期会被怎么处理</span><br><span class="line">假如我们有一个LocalDateTime的类，默认策略下，三个库对其序列化的支持如下：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Gson:&#123;&quot;date&quot;:&#123;&quot;year&quot;:2019,&quot;month&quot;:4,&quot;day&quot;:1&#125;,&quot;time&quot;:</span><br><span class="line">&#123;&quot;hour&quot;:16,&quot;minute&quot;:6,&quot;second&quot;:47,&quot;nano&quot;:247000000&#125;&#125;</span><br><span class="line">Jackson:</span><br><span class="line">&#123;&quot;year&quot;:2019,&quot;month&quot;:&quot;APRIL&quot;,&quot;dayOfMonth&quot;:1,&quot;dayOfWeek&quot;:&quot;MONDAY&quot;,&quot;dayOfYear&quot;</span><br><span class="line">:91,&quot;hour&quot;:16,&quot;minute&quot;:6,&quot;second&quot;:47,&quot;monthValue&quot;:4,&quot;nano&quot;:247000000,&quot;chrono</span><br><span class="line">logy&quot;:&#123;&quot;id&quot;:&quot;ISO&quot;,&quot;calendarType&quot;:&quot;iso8601&quot;&#125;&#125;</span><br><span class="line">FastJson:2019-04-01T16:06:</span><br><span class="line">如果我们有一个ZonedDateTime类，默认策略下，三个库对其序列化支持如下：</span><br><span class="line">Gson:&#123;&quot;dateTime&quot;:&#123;&quot;date&quot;:&#123;&quot;year&quot;:2019,&quot;month&quot;:4,&quot;day&quot;:2&#125;,&quot;time&quot;:</span><br><span class="line">&#123;&quot;hour&quot;:17,&quot;minute&quot;:25,&quot;second&quot;:25,&quot;nano&quot;:721000000&#125;&#125;,&quot;offset&quot;:</span><br><span class="line">&#123;&quot;totalSeconds&quot;:28800&#125;,&quot;zone&quot;:&#123;&quot;id&quot;:&quot;Asia/Shanghai&quot;&#125;&#125;</span><br><span class="line">JackSon: 请各位自行测试，长到令人崩溃，大概整整两页</span><br><span class="line">FastJson:2019-04-02T17:25:25.721+08:00[Asia/Shanghai]</span><br><span class="line">可以看到gson和jackson对于时间的记录比较完整，而fastJson就有数据的丢失，但绝绝大部分情况下，</span><br><span class="line">好像也不会有什么影响，而且fastJson看起来更舒服。</span><br><span class="line">然而，jackson在反序列化自己序列化的时间的时候，会出现错误，解决方法在下面。</span><br><span class="line">枚举怎么处理(默认场景)</span><br><span class="line">三个类十分统一，都将结果转化为：&quot;gender&quot;:&quot;MALE&quot;</span><br><span class="line">null字段怎么处理(默认场景)</span><br><span class="line">Gson和fastJson：直接忽略</span><br><span class="line">jackson：写入一个null字段。</span><br><span class="line">到底哪一种处理方式更好。显然是见仁见智的事情了。</span><br></pre></td></tr></table></figure><p>面对泛型</p><p>根据上面的扩展阅读，一个JSON文本是一个对象（即Map）或者数组（即Array）的序列化结果。因此，我们<br>在任何时候，都可以将一个json文本反序列化一个map或一个array(List, etc…)。比如下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String fastJsonStr = JSON.toJSONString(student,</span><br><span class="line">SerializerFeature.WriteMapNullValue);</span><br><span class="line">String gsonStr = gson.toJson(student);</span><br><span class="line">String jacksonStr = mapper.writeValueAsString(student);</span><br><span class="line">Object object1 = JSON.parseObject(fastJsonStr, Map.class);</span><br><span class="line">Object object2 = gson.fromJson(gsonStr, Map.class);</span><br><span class="line">Object object3 = mapper.readValue(jacksonStr, Map.class);</span><br></pre></td></tr></table></figure><h3 id="甚至在默认情况下，比如下面的代码："><a href="#甚至在默认情况下，比如下面的代码：" class="headerlink" title="甚至在默认情况下，比如下面的代码："></a>甚至在默认情况下，比如下面的代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object object2 = gson.fromJson(gsonStr, Object.class);</span><br><span class="line">Object object3 = mapper.readValue(jacksonStr, Object.class);</span><br></pre></td></tr></table></figure><p>这两个类都会直接将结果转化为一个map，如果要将其转为我们需要的类，则必须给他传入一个类型信息。<br>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student student1 = JSON.parseObject(fastJsonStr, Student.class);</span><br><span class="line">Student student2 = gson.fromJson(gsonStr, Student.class);</span><br><span class="line">Student student3 = mapper.readValue(jacksonStr, Student.class);</span><br></pre></td></tr></table></figure><p>这样对简单对象是可以，但当面对泛型时，json往往无能为力，比如将List<student>序列化后，很可能是<br>这样：</student></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">&quot;id&quot;: &quot;1&quot;,</span><br><span class="line">&quot;aaaName&quot;: &quot;刘&quot;,</span><br><span class="line">&quot;gender&quot;: &quot;MALE&quot;,</span><br><span class="line">&quot;birthday&quot;: &quot;2019-04-03T07:23:07.623Z&quot;,</span><br><span class="line">&quot;age&quot;: 18,</span><br><span class="line">&quot;teacher&quot;: &#123;</span><br><span class="line">&quot;students&quot;: null</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;id&quot;: &quot;2&quot;,</span><br><span class="line">&quot;aaaName&quot;: &quot;马&quot;,</span><br><span class="line">&quot;gender&quot;: &quot;MALE&quot;,</span><br><span class="line">&quot;birthday&quot;: &quot;2019-04-03T07:23:07.623Z&quot;,</span><br><span class="line">&quot;age&quot;: 18,</span><br><span class="line">&quot;teacher&quot;: &#123;</span><br><span class="line">&quot;students&quot;: null</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;id&quot;: &quot;3&quot;,</span><br><span class="line">&quot;aaaName&quot;: &quot;张&quot;,</span><br><span class="line">&quot;gender&quot;: &quot;FEMALE&quot;,</span><br><span class="line">&quot;birthday&quot;: &quot;2019-04-03T07:23:07.623Z&quot;,</span><br><span class="line">&quot;age&quot;: 18,</span><br><span class="line">&quot;teacher&quot;: &#123;</span><br><span class="line">&quot;students&quot;: null</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>将其反序列化时，如果想使用gson.fromJson(gsonStr, List<student>.class)就会出现问题。编译<br>器会提示无法获得List<student>的类型，因为java的泛型是java5才加入的，为了兼容老代码，采取运行时<br>擦除类型信息的方式实现。所以List<string>在运行时和List<integer>是一种类型，这造成了一些有意<br>思(也令人困惑)的现象，其中之一就是：<br>泛型类并没有自己独有的Class类对象。比如并不存在List<string>.class或是<br>List<integer>.class，而只有List.class；<br>为解决这个问题，三个库都提供了自己的解决方案，主要是运行时获得Type。<br>Gson解决方案</integer></string></integer></string></student></student></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Type studentListType = new TypeToken&lt;List&lt;Student&gt;&gt;() &#123;</span><br><span class="line">&#125;.getType();</span><br><span class="line">List&lt;Student&gt; students2 = gson.fromJson(gson.toJson(students),</span><br><span class="line">studentListType);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FastJson解决方案</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.fastjson.TypeReference</span><br><span class="line">List&lt;Student&gt; students2 =</span><br><span class="line">JSON.parseObject(JSON.toJSONString(students),</span><br><span class="line">new TypeReference&lt;List&lt;Student&gt;&gt;()</span><br><span class="line">&#123;&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jackson解决方案</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import com.fasterxml.jackson.core.type.TypeReference</span><br><span class="line">List&lt;Student&gt; students2 =</span><br><span class="line">mapper.readValue(mapper.writeValueAsString(students),</span><br><span class="line">new TypeReference&lt;List&lt;Student&gt;&gt;</span><br><span class="line">() &#123;&#125;);</span><br></pre></td></tr></table></figure><p>上述方法对于复杂泛型嵌套一样是可用的，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import lombok.Data;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">@Data</span><br><span class="line">public class Result&lt;T&gt; &#123;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private String result = &quot;result&quot;;</span><br><span class="line">private HashMap&lt;String, List&lt;T&gt;&gt; data = new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Student student = new Student(&quot;1&quot;, &quot;刘&quot;, Student.Gender.MALE,</span><br><span class="line">ZonedDateTime.now(ZoneId.of(&quot;Asia/Shanghai&quot;)), 18 , teacher);</span><br><span class="line">Student student22 = new Student(&quot;2&quot;, &quot;马&quot;, Student.Gender.MALE,</span><br><span class="line">ZonedDateTime.now(), 18 , teacher);</span><br><span class="line">Student student33 = new Student(&quot;3&quot;, &quot;张&quot;, Student.Gender.FEMALE,</span><br><span class="line">ZonedDateTime.now(), 18 , teacher);</span><br><span class="line">List&lt;Student&gt; students = Arrays.asList(student, student22, student33);</span><br><span class="line">Result&lt;Student&gt; studentResult = new Result&lt;&gt;();</span><br><span class="line">studentResult.getData().put(&quot;students&quot;, students);</span><br><span class="line">Result&lt;Student&gt; students1 = gson.fromJson(gson.toJson(studentResult), new</span><br><span class="line">TypeToken&lt;Result&lt;Student&gt;&gt;() &#123;</span><br><span class="line">&#125;.getType());</span><br><span class="line">Result&lt;Student&gt; students2 =</span><br><span class="line">JSON.parseObject(JSON.toJSONString(studentResult), new</span><br><span class="line">com.alibaba.fastjson.TypeReference&lt;Result&lt;Student&gt;&gt;() &#123;</span><br><span class="line">&#125;);</span><br><span class="line">Result&lt;Student&gt; students3 =</span><br><span class="line">mapper.readValue(mapper.writeValueAsString(studentResult), new</span><br><span class="line">com.fasterxml.jackson.core.type.TypeReference&lt;Result&lt;Student&gt;&gt;() &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>扩展阅读：java泛型</p><p>自定义处理</p><p>字段名自定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@com.alibaba.fastjson.annotation.JSONField(name = &quot;aName&quot;)</span><br><span class="line">@com.fasterxml.jackson.annotation.JsonProperty(&quot;aaName&quot;)</span><br><span class="line">@com.google.gson.annotations.SerializedName(&quot;aaaName&quot;)</span><br><span class="line">private String name;</span><br></pre></td></tr></table></figure><p>分别对应了三个库的字段名自定义。</p><p>日期格式自定义</p><p>在讨论这个问题之前，需要注意的是，只有fastJson可以不做任何处理地支持java8新增的各种时间类(虽然处理<br>结果未必是你想要的)，其他两个库都需要对解析器做一定的处理。<br>其中jackson需要引入新的pom：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>同时代码做以下调整：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = new ObjectMapper()</span><br><span class="line">.registerModule(new JavaTimeModule())</span><br><span class="line">.setTimeZone(TimeZone.getTimeZone(ZoneId.of(&quot;Asia/Shanghai&quot;)));</span><br></pre></td></tr></table></figure><p>而Gson的更复杂一点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Gson gson = new GsonBuilder().registerTypeAdapter(ZonedDateTime.class, new</span><br><span class="line">JsonSerializer&lt;ZonedDateTime&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public JsonElement serialize(ZonedDateTime src, Type typeOfSrc,</span><br><span class="line">JsonSerializationContext context) &#123;</span><br><span class="line">return new JsonPrimitive(src.toInstant().toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;).registerTypeAdapter(ZonedDateTime.class, new</span><br><span class="line">JsonDeserializer&lt;ZonedDateTime&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public ZonedDateTime deserialize(JsonElement json, Type typeOfT,</span><br><span class="line">JsonDeserializationContext context) throws JsonParseException &#123;</span><br><span class="line">String datetime = json.getAsJsonPrimitive().getAsString();</span><br><span class="line">return Instant.parse(datetime).atZone(ZoneId.of(&quot;Asia/Shanghai&quot;));</span><br><span class="line">&#125;</span><br><span class="line">&#125;).create();</span><br></pre></td></tr></table></figure><p>实际上是直接注册了自定义的类序列化工具，如何注册自定义的类序列化工具，这个在下面再详细分析。<br>更改过后，新的序列化结果是：<br>Gson:”2019-04-02T11:33:25.847Z”<br>Jackson:1554204805.<br>反序列化都能正常进行。<br>还可以通过注解简单定制序列化的行为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss.SSSZ&quot;, timezone =</span><br><span class="line">&quot;Asia/Shanghai&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@JSONField(format = &quot;yyyy-MM-dd HH:mm:ss.SSSZ&quot;)</span><br><span class="line">private ZonedDateTime birthday;</span><br></pre></td></tr></table></figure><p>其中Z是时区的意思，缺失的话反序列化就会出现问题，但即使如此，Fastjson在采用这种方式序列化之后，反<br>序列化时会仍然会丢失时区信息。<br>因为我们刚才的Gson实际上已经完成了完全的自定义序列化和反序列化，所以结果取决于自定义的行为是什<br>么。</p><p>不输出某个字段</p><p>FastJson： @JSONField(serialize = false)<br>Gson：直接在字段上加transient关键字，如private transient Gender gender;<br>但因为transient是java的关键字，也会影响java的java.io.Serializable接口，因此要慎用。更详细的情况<br>可参照Gson之排除字段的常见方式<br>jackson：@JsonIgnore</p><p><strong>null</strong> 值是否输出</p><p>Gson和FastJson默认不输出，因此使用下面的语句打开。<br>Gson:Gson gson = new GsonBuilder().serializeNulls().create()<br>FastJson:JSON.toJSONString(student, SerializerFeature.WriteMapNullValue);<br>Jackson默认输出，因此这样打开：<br>ObjectMapper mapper = new<br>ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL);</p><p>把多个字段映射为一个属性</p><p>比如我们从多个源接收数据，想将他们转为反序列化为同一个类，他们的主要字段相同，但字段名却不尽相<br>同。比如我们作为一家app公司，主要是免费加广告的方式发布app，现在有三家广告商，他们提供接口来获取<br>广告收入数据，大概格式都是从哪个时间到哪个时间，点击了多少次，收益多少这样的数据，但字段名不一<br>样，有些叫timeStart，有些叫beginTime，都是json现在传过来了，而我们想统一处理，这里举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;序号&quot;:1,&quot;名字&quot;:&quot;小刘&quot;,&quot;性别&quot;:&quot;Male&quot;,&quot;年龄&quot;:22,&quot;生日&quot;:&quot;2019-04-14&quot;&#125;</span><br><span class="line">&#123;&quot;age&quot;:22,&quot;birthday&quot;:&quot;2019-04-14&quot;,&quot;gender&quot;:&quot;Male&quot;,&quot;name&quot;:&quot;小</span><br><span class="line">刘&quot;,&quot;studentId&quot;:1&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Student &#123;</span><br><span class="line">private Integer studentId = 1 ;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private String name = &quot;小刘&quot;;</span><br><span class="line">private Gender gender = Gender.Male;</span><br><span class="line">private LocalDate birthday = LocalDate.now();</span><br><span class="line">private Integer age = 22 ;</span><br><span class="line">public enum Gender &#123;</span><br><span class="line">Male,</span><br><span class="line">Female</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>FastJson:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Student &#123;</span><br><span class="line">@JSONField(alternateNames = &quot;序号&quot;)</span><br><span class="line">private Integer studentId = 1 ;</span><br><span class="line">@JSONField(alternateNames = &quot;姓名&quot;)</span><br><span class="line">private String name = &quot;小刘&quot;;</span><br><span class="line">@JSONField(alternateNames = &quot;性别&quot;)</span><br><span class="line">private Gender gender = Gender.Male;</span><br><span class="line">@JSONField(alternateNames = &quot;年龄&quot;)</span><br><span class="line">private Integer age = 22 ;</span><br><span class="line">public enum Gender &#123;</span><br><span class="line">Male,</span><br><span class="line">Female</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则以上两个字符串反序列化结果一致。<br><strong>Gson:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Student &#123;</span><br><span class="line">@SerializedName(value = &quot;studentId&quot;, alternate = &quot;序号&quot;)</span><br><span class="line">private Integer studentId = 1 ;</span><br><span class="line">@SerializedName(value = &quot;name&quot;, alternate = &quot;姓名&quot;)</span><br><span class="line">private String name = &quot;小刘&quot;;</span><br><span class="line">@SerializedName(value = &quot;gender&quot;, alternate = &quot;性别&quot;)</span><br><span class="line">private Gender gender = Gender.Male;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 因为Gson对Date的自定义格式化比较复杂，为演示去掉了这个字段</span><br><span class="line">// private LocalDate birthday = LocalDate.now();</span><br><span class="line">@SerializedName(value = &quot;age&quot;, alternate = &quot;年龄&quot;)</span><br><span class="line">private Integer age = 22 ;</span><br><span class="line">public enum Gender &#123;</span><br><span class="line">Male,</span><br><span class="line">Female</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>jackson</strong> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">//@JsonSerialize(using = StudentSerializer.class)</span><br><span class="line">//@JsonDeserialize(using = StudentDeserializer.class)</span><br><span class="line">public class Student &#123;</span><br><span class="line">@JsonAlias(&quot;序号&quot;)</span><br><span class="line">private Integer studentId = 1 ;</span><br><span class="line">@JsonAlias(&quot;姓名&quot;)</span><br><span class="line">private String name = &quot;小刘&quot;;</span><br><span class="line">@JsonAlias(&quot;性别&quot;)</span><br><span class="line">private Gender gender = Gender.Male;</span><br><span class="line">@JsonAlias(&quot;年龄&quot;)</span><br><span class="line">private Integer age = 22 ;</span><br><span class="line">public enum Gender &#123;</span><br><span class="line">Male,</span><br><span class="line">Female</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完全自定义的序列化与反序列化</p><p>上面已经示例了Gson的自定义序列化与反序列化，即通过registerTypeAdapter方法来注册<br>JsonSerializer和JsonDeserializer。其实三个库都差不太多，都是手动实现序列化和反序列化，然后<br>通过某种方式注册到解析器里面去。<br><strong>FastJson</strong> ：</p><p>因为FastJson的序列化和反序列化都是静态方法，所以需要在需要序列化和反序列化的类上添加注解，或者在<br>每次序列化和反序列化时传入自定义配置。<br>首先，实现自定义序列化和反序列化类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class LocalDateSerializer implements ObjectSerializer &#123;</span><br><span class="line">public void write(JSONSerializer serializer, Object object,</span><br><span class="line">Object fieldName, Type fieldType, int features) &#123;</span><br><span class="line">SerializeWriter out = serializer.getWriter();</span><br><span class="line">if (object == null) &#123;</span><br><span class="line">serializer.getWriter().writeNull();</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">out.write(&quot;\&quot;活在当下\&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public class LocalDateDeserializer implements ObjectDeserializer &#123;</span><br><span class="line">//不管咋样，我都给你整成当前时间，反正是测试用</span><br><span class="line">public &lt;T&gt; T deserialze(DefaultJSONParser parser, Type type, Object</span><br><span class="line">fieldName) &#123;</span><br><span class="line">JSONLexer lexer = parser.getLexer();</span><br><span class="line">lexer.nextToken( 2 ); //随意设置一个int都可以，但不设置会出异常，不明原</span><br><span class="line">理</span><br><span class="line">return (T) LocalDate.now().plusDays( 1 );</span><br><span class="line">&#125;</span><br><span class="line">public int getFastMatchToken() &#123;</span><br><span class="line">//意义不明，打断点发现从来没被吊用过</span><br><span class="line">return 0 ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Student student = new Student();</span><br><span class="line">SerializeConfig config = new SerializeConfig();</span><br><span class="line">config.put(LocalDate.class, new LocalDateSerializer());</span><br><span class="line">String jsonStr = JSON.toJSONString(student, config);</span><br><span class="line">System.out.println(jsonStr);</span><br><span class="line">ParserConfig parserConfig = new ParserConfig();</span><br><span class="line">parserConfig.putDeserializer(LocalDate.class, new</span><br><span class="line">LocalDateDeserializer());</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student student1 = JSON.parseObject(jsonStr, Student.class);</span><br><span class="line">System.out.println(student1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;age&quot;:22,&quot;birthday&quot;:&quot;活在当下&quot;,&quot;gender&quot;:&quot;Male&quot;,&quot;name&quot;:&quot;小刘&quot;,&quot;studentId&quot;:1&#125;</span><br><span class="line">Student(studentId=1, name=小刘, gender=Male, birthday=2019-04-15, age=22)</span><br></pre></td></tr></table></figure><p>如果需要全局注册，则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SerializeConfig.getGlobalInstance().put(LocalDate.class, new</span><br><span class="line">LocalDateSerializer());</span><br><span class="line">ParserConfig.getGlobalInstance().putDeserializer(LocalDate.class, new</span><br><span class="line">LocalDateDeserializer());</span><br></pre></td></tr></table></figure><p>如果想只针对特定的字段进行定制，则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Student &#123;</span><br><span class="line">private Integer studentId = 1 ;</span><br><span class="line">private String name = &quot;小刘&quot;;</span><br><span class="line">private Gender gender = Gender.Male;</span><br><span class="line">@JSONField(serializeUsing = LocalDateSerializer.class, deserializeUsing</span><br><span class="line">= LocalDateDeserializer.class)</span><br><span class="line">private LocalDate birthday = LocalDate.now();</span><br><span class="line">private Integer age = 22 ;</span><br><span class="line">public enum Gender &#123;</span><br><span class="line">Male,</span><br><span class="line">Female</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@JSONField</strong> 的设置项非常丰富，基本全部是关于自定义的东西，详细了解一下应该很有收获。<br>另外：FastJson还有一类被称为Filter的类，也可以对结果进行一定的自定义，但并非完全的自定义。大部分是<br>用来判断哪些字段序列化哪些字段不序列化，或者改变序列化后某个字段的名字、值这样的。有兴趣可以了解<br>一下。<br><strong>Jackson</strong> ：<br>套路都一样，首先是实现自己的序列化和反序列化类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class StudentSerializer extends JsonSerializer&lt;Student&gt; &#123;</span><br><span class="line">@Override</span><br><span class="line">public void serialize(Student value, JsonGenerator jsonGenerator,</span><br><span class="line">SerializerProvider provider)</span><br><span class="line">throws IOException &#123;</span><br><span class="line">jsonGenerator.writeStartObject();</span><br><span class="line">jsonGenerator.writeNumberField(&quot;序号&quot;, value.getStudentId());</span><br><span class="line">jsonGenerator.writeStringField(&quot;名字&quot;, value.getName());</span><br><span class="line">jsonGenerator.writeStringField(&quot;性别&quot;,</span><br><span class="line">value.getGender().toString());</span><br><span class="line">jsonGenerator.writeStringField(&quot;年龄&quot;, value.getAge() + &quot;years-</span><br><span class="line">old&quot;);</span><br><span class="line">jsonGenerator.writeStringField(&quot;生日&quot;,</span><br><span class="line">value.getBirthday().toString());</span><br><span class="line">jsonGenerator.writeEndObject();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class StudentDeserializer extends JsonDeserializer&lt;Student&gt; &#123;</span><br><span class="line">@Override</span><br><span class="line">public Student deserialize(JsonParser jp, DeserializationContext ctxt)</span><br><span class="line">&#123;</span><br><span class="line">return new Student();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Student student = new Student();</span><br><span class="line">SimpleModule module = new SimpleModule();</span><br><span class="line">module.addSerializer(Student.class, new StudentSerializer());</span><br><span class="line">module.addDeserializer(Student.class, new StudentDeserializer());</span><br><span class="line">ObjectMapper mapper = new ObjectMapper().registerModule(module);</span><br><span class="line">String jsonStr = mapper.writeValueAsString(student);</span><br><span class="line">System.out.println(jsonStr);</span><br><span class="line">Student student2 = mapper.readValue(jsonStr, Student.class);</span><br><span class="line">System.out.println(student2);</span><br></pre></td></tr></table></figure><p>可以看到主要是注册module来实现自定义，更简单的办法是直接在类上添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@JsonSerialize(using = StudentSerializer.class)</span><br><span class="line">@JsonDeserialize(using = StudentDeserializer.class)</span><br><span class="line">public class Student &#123;</span><br></pre></td></tr></table></figure><h3 id="…"><a href="#…" class="headerlink" title="…"></a>…</h3><h3 id><a href="#" class="headerlink" title="}"></a>}</h3><h3 id="这两个注解同时可用于字段级别。"><a href="#这两个注解同时可用于字段级别。" class="headerlink" title="这两个注解同时可用于字段级别。"></a>这两个注解同时可用于字段级别。</h3><p>再看 <strong>Gson</strong> ：<br>可以看到，另外两个库都有通过注解自定义的方法，gson也有@JsonAdapter()注解，但gson用这个注解同<br>时来序列化与反序列化的自定义工作，鉴于一个类或者字段不可能标注两个同样的注解，因此Gson的序列化和<br>反序列化是写在同一个类里面的，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class StudentTypeAdapter extends TypeAdapter&lt;Student&gt; &#123;</span><br><span class="line">public void write(JsonWriter out, Student value) throws IOException &#123;</span><br><span class="line">out.beginObject();</span><br><span class="line">out.name(&quot;序号&quot;);</span><br><span class="line">out.value(value.getStudentId());</span><br><span class="line">out.name(&quot;姓名&quot;);</span><br><span class="line">out.value(value.getName());</span><br><span class="line">out.endObject();</span><br><span class="line">&#125;</span><br><span class="line">public Student read(JsonReader in) throws IOException &#123;</span><br><span class="line">Student student = new Student();</span><br><span class="line">student.setGender(Student.Gender.Female);</span><br><span class="line">in.beginObject();</span><br><span class="line">String fieldname = null;</span><br><span class="line">while (in.hasNext()) &#123;</span><br><span class="line">JsonToken token = in.peek();</span><br><span class="line">if (token.equals(JsonToken.NAME)) &#123;</span><br><span class="line">//get the current token</span><br><span class="line">fieldname = in.nextName();</span><br><span class="line">&#125;</span><br><span class="line">if (&quot;序号&quot;.equals(fieldname)) &#123;</span><br><span class="line">student.setStudentId(in.nextInt());</span><br><span class="line">&#125; else if (&quot;姓名&quot;.equals(fieldname)) &#123;</span><br><span class="line">student.setName(in.nextString());</span><br><span class="line">&#125; else in.skipValue();</span><br><span class="line">&#125;</span><br><span class="line">in.endObject();</span><br><span class="line">return student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后用@JsonAdapter(StudentTypeAdapter.class)注解即可。</p><p>面对循环引用</p><p>设想这样的实体类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Student &#123;</span><br><span class="line">private Integer studentId = 1 ;</span><br><span class="line">private String name = &quot;小刘&quot;;</span><br><span class="line">private Teacher teacher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Teacher &#123;</span><br><span class="line">private Integer teacherId = 2 ;</span><br><span class="line">private String name = &quot;老王&quot;;</span><br><span class="line">private Student student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个简化版的一对一家教的数据库表。常见于@OneToOne的场景下。<br>之后会有这样的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student student = new Student();</span><br><span class="line">Teacher teacher = new Teacher();</span><br><span class="line">student.setTeacher(teacher);</span><br><span class="line">teacher.setStudent(student);</span><br></pre></td></tr></table></figure><p>那么序列化时会发生什么问题？我们测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">Gson gson = new GsonBuilder().create();</span><br><span class="line">System.out.println(JSON.toJSONString(teacher));</span><br><span class="line">System.out.println(gson.toJson(teacher));</span><br><span class="line">System.out.println(mapper.writeValueAsString(teacher));</span><br></pre></td></tr></table></figure><p>FastJson的输出是：{“student”:{“name”:”小刘”,”studentId”:1,”teacher”:{“$ref”:”..”}}}<br>Gson和Jackson爆栈异常，其实我个人觉得爆栈异常更合理，这种互相持有引用的情况应该特殊处理，<br>fastJson替我们处理了有好有坏，比如其他语言可能无法反序列化这样它的序列化结果，因而引发异常。所以官<br>方也提供手动关闭的功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//全局关闭</span><br><span class="line">JSON.DEFAULT_GENERATE_FEATURE |=</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SerializerFeature.DisableCircularReferenceDetect.getMask();</span><br><span class="line">//单次关闭</span><br><span class="line">JSON.toJSONString(obj, SerializerFeature.DisableCircularReferenceDetect);</span><br></pre></td></tr></table></figure><p>那么假设我们真的要处理这样的情况，该如何是好呢？<br>一种方式是在某个类的对另一个类的引用上忽略另一个类，即不输出这个字段。这样断开循环引用。另外的方<br>式就是通过某种方式来指明引用方式：<br>jackson下最全的：Jackson – Bidirectional Relationships，其中和FastJson表现形式最接近的是<br>@JsonIdentityInfo方法。要注意的是@JsonIdentityInfo必须提供的参数是generator，其实是指定<br>了ID的生成策略，之后通过ID解除相互引用的问题。随便选择一个可用的即可，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Teacher &#123;</span><br><span class="line">private Integer teacherId = 2 ;</span><br><span class="line">private String name = &quot;老王&quot;;</span><br><span class="line">@JsonIdentityInfo(generator =</span><br><span class="line">ObjectIdGenerators.StringIdGenerator.class)</span><br><span class="line">private Student student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Student &#123;</span><br><span class="line">private Integer studentId = 1 ;</span><br><span class="line">private String name = &quot;小刘&quot;;</span><br><span class="line">@JsonIdentityInfo(generator =</span><br><span class="line">ObjectIdGenerators.StringIdGenerator.class)</span><br><span class="line">private Teacher teacher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Gson没有查到类似策略，似乎只能通过忽略字段来断开无限循环。<br>当然了，以上问题都可以通过完全自定义的序列化与反序列化完成工作</p><h2 id="三个库与Spring框架整合"><a href="#三个库与Spring框架整合" class="headerlink" title="三个库与Spring框架整合"></a>三个库与Spring框架整合</h2><p>目前Spring框架默认使用Jackson来序列化和反序列化json，如果细致一点观察Spring框架，会发现Spring框架<br>正是使用HttpMessageConverter来实现HTTP信息处理的，其他两个Gson库也提供了和Spring框架整合的能<br>力，得益于Spring框架本身的松耦合，替换HttpMessageConverter是轻而易举的：<br>FastJson：官方文档：集成Spring框架<br>Gson: Configure gson in spring using GsonHttpMessageConverter</p><p>如果已经决定替换掉jackson，那还应该在pom文件中去除jackson的引用，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;exclusions&gt;</span><br><span class="line">&lt;exclusion&gt;</span><br><span class="line">&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">&lt;/exclusion&gt;</span><br><span class="line">&lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="我该如何选择呢？"><a href="#我该如何选择呢？" class="headerlink" title="我该如何选择呢？"></a>我该如何选择呢？</h2><p>整体上讲，三个框架各有特点吧。jackson能被spring官方选中自然有他的道理，对标准的严格执行，强大的可<br>扩展性、稳定性，速度也很快，缺点是接口不那么易用，要引的包也着实有点多。Gson是谷歌的产品，我们单<br>位用的比较多，但被fastJson公然嘲讽速度慢：<br>Gson应该叫龟速Json。<br>fastJson速度快，接口简单，但批评者认为，使用Json本身就不是看中他的速度，而是他的兼容性和灵活性，<br>fastJson硬编码的东西多，灵活性不够，等等。见知乎讨论：fastjson这么快老外为啥还是热衷 jackson，但是它<br>确实很简单易用，速度也挺快。<br>从功能上来讲，三者可以说都是完备的。如果是我选择，想偷懒应该会用FastJson，想安全稳定面对特别复杂<br>的需求，应该还是用jackson。Gson……不知道为什么就是不太喜欢它……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java序列化与Json的三个库&quot;&gt;&lt;a href=&quot;#java序列化与Json的三个库&quot; class=&quot;headerlink&quot; title=&quot;java序列化与Json的三个库&quot;&gt;&lt;/a&gt;java序列化与Json的三个库&lt;/h1&gt;&lt;h3 id=&quot;如果一个运行时的数</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HttpClient的几个参数</title>
    <link href="http://yoursite.com/2020/05/09/HttpClient%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8F%82%E6%95%B0/"/>
    <id>http://yoursite.com/2020/05/09/HttpClient%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8F%82%E6%95%B0/</id>
    <published>2020-05-09T06:05:35.000Z</published>
    <updated>2021-04-22T04:43:17.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Apache-HttpClient的几个重要参数"><a href="#Apache-HttpClient的几个重要参数" class="headerlink" title="Apache HttpClient的几个重要参数"></a>Apache HttpClient的几个重要参数</h1><p>最近在业务中发现一些性能问题，主要是和HttpClient有关的，刚好在这里总结一下。</p><p>针对版本号如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="maxConnPerRoute-与-maxConnTotal"><a href="#maxConnPerRoute-与-maxConnTotal" class="headerlink" title="maxConnPerRoute 与 maxConnTotal"></a>maxConnPerRoute 与 maxConnTotal</h2><p>正如大家所知，HttpClient与目的主机进行HTTP通信，必须要进行TCP连接。而因为三次握手、四次挥手、滑动窗口机制，连接的建立和释放是颇为耗时的一件事情，因此，HttpClient实现了连接池。以便在请求同一个<code>host:port</code>时，会复用已经建立的连接。</p><p>那么显然，这个复用的连接针对同一个<code>host:port</code>才有意义，这就是<code>maxConnPerRoute</code>的含义，即允许同一个<code>host:port</code>最多有几个活跃连接。当设置为2时，意味着同时最多有两个到<code>host:port</code>的连接，如果有空闲连接，本次请求会使用已经建立的空闲连接，但如果没有，就会进入等待队列，等待到该<code>host:port</code>的连接可用。</p><p>而maxConnTotal更直接了，意思就是总共允许HttpClient建立多少个连接，超出以后所有的连接都会进入等待队列。</p><p>在<code>CloseableHttpClient</code>的实现类<code>InternalHttpClient</code>中，连接的管理是依靠<code>HttpClientConnectionManager</code>的实现类，默认为<code>PoolingHttpClientConnectionManager</code>。</p><p>具体的代码，从<code>httpclient.execute(...)</code>可以追溯到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> CloseableHttpResponse <span class="title">doExecute</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> HttpHost target,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> HttpRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> HttpContext context)</span> <span class="keyword">throws</span> IOException, ClientProtocolException</span>&#123;</span><br><span class="line">  <span class="comment">// 上半部分省略，try catch省略  </span></span><br><span class="line">  <span class="keyword">final</span> HttpRoute route = determineRoute(target, wrapper, localcontext);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.execChain.execute(route, wrapper, localcontext, execAware);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续追寻<code>execChain.execute(...)</code>，最终会进入<code>MainClientExec#exec(...)</code>中，有关建立连接的语句如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ConnectionRequest connRequest = connManager.requestConnection(route, userToken);</span><br><span class="line"><span class="keyword">final</span> HttpClientConnection managedConn = connRequest.get(timeout &gt; <span class="number">0</span> ? timeout : <span class="number">0</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p>而这个<code>ConnectionRequest</code>，则是定义于<code>PoolingHttpClientConnectionManager</code>中的一个匿名类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionRequest <span class="title">requestConnection</span><span class="params">(<span class="keyword">final</span> HttpRoute route,<span class="keyword">final</span> Object state)</span> </span>&#123;</span><br><span class="line">    Args.notNull(route, <span class="string">"HTTP route"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.log.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.log.debug(<span class="string">"Connection request: "</span> + format(route, state) + formatStats(route));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Future&lt;CPoolEntry&gt; future = <span class="keyword">this</span>.pool.lease(route, state, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConnectionRequest() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> future.cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> HttpClientConnection <span class="title">get</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">final</span> <span class="keyword">long</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">final</span> TimeUnit tunit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, ConnectionPoolTimeoutException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> leaseConnection(future, timeout, tunit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，他的get方法重载了，实际上调用了<code>leaseConnection</code>方法，那这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HttpClientConnection <span class="title">leaseConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> Future&lt;CPoolEntry&gt; future,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">long</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> TimeUnit tunit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, ConnectionPoolTimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> CPoolEntry entry;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        entry = future.get(timeout, tunit);</span><br><span class="line">        <span class="comment">// 以下省略</span></span><br><span class="line">        <span class="keyword">return</span> CPoolProxy.newProxy(entry);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> TimeoutException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConnectionPoolTimeoutException(<span class="string">"Timeout waiting for connection from pool"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个proxy可以先不去理会，可见最重要的还是这个future。那这个future是什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Future&lt;CPoolEntry&gt; future = <span class="keyword">this</span>.pool.lease(route, state, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>进到lease方法里，会发现他是直接构造了一个Future实例，那我们关注他的<code>get()</code>方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 这里的E实际类型就是CPoolEntry</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timeout, <span class="keyword">final</span> TimeUnit tunit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E entry = entryRef.get();</span><br><span class="line">    <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> entry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;<span class="comment">// 无限循环是为了一直尝试获取</span></span><br><span class="line">                <span class="keyword">final</span> E leasedEntry = getPoolEntryBlocking(route, state, timeout, tunit, <span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> (validateAfterInactivity &gt; <span class="number">0</span>)  &#123;</span><br><span class="line">               <span class="comment">// 检测一下是不是超时了，超时了就重来一次 </span></span><br><span class="line">                    <span class="keyword">if</span> (leasedEntry.getUpdated() + validateAfterInactivity &lt;= System.currentTimeMillis()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!validate(leasedEntry)) &#123;</span><br><span class="line">                            leasedEntry.close();</span><br><span class="line">                            release(leasedEntry, <span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> leasedEntry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException ex) &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以真正的获取的方法是<code>getPoolEntryBlocking(...)</code>，追踪之：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">getPoolEntryBlocking</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> T route, <span class="keyword">final</span> Object state,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">long</span> timeout, <span class="keyword">final</span> TimeUnit tunit,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> Future&lt;E&gt; future)</span> <span class="keyword">throws</span> IOException, InterruptedException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Date deadline = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 指获得连接要等待多久，这个timeout就是ConnectionTimeout。</span></span><br><span class="line">      <span class="comment">// 要追溯这个timeout是ConnectionTimeToLive</span></span><br><span class="line">        deadline = <span class="keyword">new</span> Date (System.currentTimeMillis() + tunit.toMillis(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获得一个特定路由的连接池，细节实际就是从可用队列里获得一个连接</span></span><br><span class="line">        <span class="keyword">final</span> RouteSpecificPool&lt;T, C, E&gt; pool = getPool(route);</span><br><span class="line">        E entry;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Asserts.check(!<span class="keyword">this</span>.isShutDown, <span class="string">"Connection pool shut down"</span>);</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="comment">// 尝试从其中获得可用的连接，这个操作在第一次执行时一定返回null</span></span><br><span class="line">                entry = pool.getFree(state);</span><br><span class="line">                <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 如果超时了，关闭这个入口。因为不可能无限保持TCP连接，至少这是个不好的操作</span></span><br><span class="line">              <span class="comment">// 所以超时了以后就关闭连接比较合理。这里的超时是指ConnectionTimeToLive</span></span><br><span class="line">                <span class="keyword">if</span> (entry.isExpired(System.currentTimeMillis())) &#123;</span><br><span class="line">                    entry.close();</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 如果已经被关闭，那就从可用队列里移除。</span></span><br><span class="line">                <span class="keyword">if</span> (entry.isClosed()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.available.remove(entry);</span><br><span class="line">                    pool.free(entry, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 这里一连串的if还是很严谨的</span></span><br><span class="line">            <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 被使用了，当然要移出可用队列</span></span><br><span class="line">                <span class="keyword">this</span>.available.remove(entry);</span><br><span class="line">              <span class="comment">// 加入已分配队列</span></span><br><span class="line">                <span class="keyword">this</span>.leased.add(entry);</span><br><span class="line">                onReuse(entry);</span><br><span class="line">                <span class="keyword">return</span> entry;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// New connection is needed。</span></span><br><span class="line">          <span class="comment">// 因为第一次的时候free一定是空的，所以会新建。</span></span><br><span class="line">          <span class="comment">// 根据默认设置，这里会得到2，一会会详细看一下这个方法</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> maxPerRoute = getMax(route);</span><br><span class="line">            <span class="comment">// Shrink the pool prior to allocating a new connection</span></span><br><span class="line">          <span class="comment">// 超出了最大允许的连接数，即maxPerRoute，就回收一下</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> excess = Math.max(<span class="number">0</span>, pool.getAllocatedCount() + <span class="number">1</span> - maxPerRoute);</span><br><span class="line">            <span class="keyword">if</span> (excess &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; excess; i++) &#123;</span><br><span class="line">                    <span class="keyword">final</span> E lastUsed = pool.getLastUsed();</span><br><span class="line">                    <span class="keyword">if</span> (lastUsed == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    lastUsed.close();</span><br><span class="line">                    <span class="keyword">this</span>.available.remove(lastUsed);</span><br><span class="line">                    pool.remove(lastUsed);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line"><span class="comment">// 如果这个route的已分配连接没有超过允许的最大连接，就分配。</span></span><br><span class="line">            <span class="keyword">if</span> (pool.getAllocatedCount() &lt; maxPerRoute) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> totalUsed = <span class="keyword">this</span>.leased.size();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> freeCapacity = Math.max(<span class="keyword">this</span>.maxTotal - totalUsed, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (freeCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> totalAvailable = <span class="keyword">this</span>.available.size();</span><br><span class="line">                    <span class="keyword">if</span> (totalAvailable &gt; freeCapacity - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!<span class="keyword">this</span>.available.isEmpty()) &#123;</span><br><span class="line">                            <span class="keyword">final</span> E lastUsed = <span class="keyword">this</span>.available.removeLast();</span><br><span class="line">                            lastUsed.close();</span><br><span class="line">                            <span class="keyword">final</span> RouteSpecificPool&lt;T, C, E&gt; otherpool = getPool(lastUsed.getRoute());</span><br><span class="line">                            otherpool.remove(lastUsed);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">// 真正新建一个connection，在这一步，为entry设置了超时时间。</span></span><br><span class="line">                  <span class="comment">// 这个超时时间在上面一个代码块中会用</span></span><br><span class="line">                    <span class="keyword">final</span> C conn = <span class="keyword">this</span>.connFactory.create(route);</span><br><span class="line">                    entry = pool.add(conn);</span><br><span class="line">                    <span class="keyword">this</span>.leased.add(entry);</span><br><span class="line">                    <span class="keyword">return</span> entry;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (future.isCancelled()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(<span class="string">"Operation interrupted"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 否则就将这个申请的请求加到等待队列里</span></span><br><span class="line">                pool.queue(future);</span><br><span class="line">                <span class="keyword">this</span>.pending.add(future);</span><br><span class="line">                <span class="keyword">if</span> (deadline != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    success = <span class="keyword">this</span>.condition.awaitUntil(deadline);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.condition.await();</span><br><span class="line">                    success = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (future.isCancelled()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(<span class="string">"Operation interrupted"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// In case of 'success', we were woken up by the</span></span><br><span class="line">                <span class="comment">// connection pool and should now have a connection</span></span><br><span class="line">                <span class="comment">// waiting for us, or else we're shutting down.</span></span><br><span class="line">                <span class="comment">// Just continue in the loop, both cases are checked.</span></span><br><span class="line">              <span class="comment">// 所以接下来就重试了，注意最上面那个for (;;)无限循环</span></span><br><span class="line">                pool.unqueue(future);</span><br><span class="line">                <span class="keyword">this</span>.pending.remove(future);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// check for spurious wakeup vs. timeout</span></span><br><span class="line">            <span class="keyword">if</span> (!success &amp;&amp; (deadline != <span class="keyword">null</span> &amp;&amp; deadline.getTime() &lt;= System.currentTimeMillis())) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">"Timeout waiting for connection"</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再来稍微看一下这个<code>final int maxPerRoute = getMax(route);</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">final</span> T route)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Integer v = <span class="keyword">this</span>.maxPerRoute.get(route);</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> v.intValue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defaultMaxPerRoute;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，先是从一个map里面查一下数据，如果没有的话就使用<code>defaultMaxPerRoute</code>。这两个值都可以由我们自行设置。</p><p>自此，我们理清楚了一个connection是怎么获得的。然后再来看这两个参数怎么设置。当一个请求到来之后，先会去解析他的<code>host:port</code>，之后尝试根据这个<code>host:port</code>去尝试获取连接，如果当前到<code>host:port</code>的连接数量少于<code>maxConnPerRoute</code>，并且该<code>HttpClient</code>中发出的所有连接数量小于<code>maxConnTotal</code>，那么连接可以分配，如果两个条件有一个不满足，请求就会进入等待队列。不断轮询。关于这两个值的大小设置，我们来看一下官方的解读：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ClientConnectionPoolManager&#125; maintains a pool of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> HttpClientConnection&#125;s and is able to service connection requests</span></span><br><span class="line"><span class="comment"> * from multiple execution threads. Connections are pooled on a per route</span></span><br><span class="line"><span class="comment"> * basis. A request for a route which already the manager has persistent</span></span><br><span class="line"><span class="comment"> * connections for available in the pool will be services by leasing</span></span><br><span class="line"><span class="comment"> * a connection from the pool rather than creating a brand new connection.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ClientConnectionPoolManager&#125; maintains a maximum limit of connection</span></span><br><span class="line"><span class="comment"> * on a per route basis and in total. Per default this implementation will</span></span><br><span class="line"><span class="comment"> * create no more than than 2 concurrent connections per given route</span></span><br><span class="line"><span class="comment"> * and no more 20 connections in total. For many real-world applications</span></span><br><span class="line"><span class="comment"> * these limits may prove too constraining, especially if they use HTTP</span></span><br><span class="line"><span class="comment"> * as a transport protocol for their services. Connection limits, however,</span></span><br><span class="line"><span class="comment"> * can be adjusted using &#123;<span class="doctag">@link</span> ConnPoolControl&#125; methods.</span></span><br><span class="line"><span class="comment"> * 上面这一段划重点，意思是默认值对于生产环境可能太小了，特别是当我们把HTTP当RPC用的时候</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Total time to live (TTL) set at construction time defines maximum life span</span></span><br><span class="line"><span class="comment"> * of persistent connections regardless of their expiration setting. No persistent</span></span><br><span class="line"><span class="comment"> * connection will be re-used past its TTL value.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The handling of stale connections was changed in version 4.4.</span></span><br><span class="line"><span class="comment"> * Previously, the code would check every connection by default before re-using it.</span></span><br><span class="line"><span class="comment"> * The code now only checks the connection if the elapsed time since</span></span><br><span class="line"><span class="comment"> * the last use of the connection exceeds the timeout that has been set.</span></span><br><span class="line"><span class="comment"> * The default timeout is set to 2000ms</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Contract</span>(threading = ThreadingBehavior.SAFE_CONDITIONAL)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolingHttpClientConnectionManager</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">HttpClientConnectionManager</span>, <span class="title">ConnPoolControl</span>&lt;<span class="title">HttpRoute</span>&gt;, <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然太小了，那就有调整的必要，调整主要有两种办法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CloseableHttpClient httpClient = HttpClientBuilder.create()</span><br><span class="line">            .setMaxConnTotal(<span class="number">400</span>).setMaxConnPerRoute(<span class="number">200</span>).build();</span><br></pre></td></tr></table></figure><p>不解释了。还有一种更详细的设置方式，就是既然connection的管理是依靠<code>PoolingHttpClientConnectionManager</code>，那我们给httpClient设置一个<code>PoolingHttpClientConnectionManager</code>，就可以完全掌握连接分配了，而<code>PoolingHttpClientConnectionManager</code>的设置项要更多一些。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PoolingHttpClientConnectionManager manager = <span class="keyword">new</span> PoolingHttpClientConnectionManager();</span><br><span class="line">manager.setDefaultMaxPerRoute(<span class="number">100</span>);</span><br><span class="line">manager.setMaxTotal(<span class="number">500</span>);</span><br><span class="line">manager.setMaxPerRoute(<span class="keyword">new</span> HttpRoute(</span><br><span class="line">  <span class="keyword">new</span> HttpHost(<span class="string">"https://www.baidu.com"</span>, <span class="number">443</span>)), <span class="number">200</span>);</span><br><span class="line">CloseableHttpClient httpClient = HttpClientBuilder.create()</span><br><span class="line">  .setConnectionManager(manager).build();</span><br></pre></td></tr></table></figure><p>这个可以对单独的route设置最大连接数量，并且<code>setConnectionManager(manager)</code>会覆盖<code>setMaxConnTotal(400).setMaxConnPerRoute(200)</code>。</p><p>上面的这个<code>connectionTimeToLive</code>可以用以下两种方法设置，所有的超时连接都不会被复用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">PoolingHttpClientConnectionManager manager = <span class="keyword">new</span> PoolingHttpClientConnectionManager(<span class="number">100</span>，TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">CloseableHttpClient httpClient = HttpClientBuilder.create()</span><br><span class="line">            .setConnectionTimeToLive(<span class="number">100</span>，TimeUnit.SECONDS).build();</span><br></pre></td></tr></table></figure><h2 id="RequestConfig-的-三个TimeOut"><a href="#RequestConfig-的-三个TimeOut" class="headerlink" title="RequestConfig 的 三个TimeOut"></a>RequestConfig 的 三个TimeOut</h2><p>每一个请求都可以带一个RequestConfig参数，对此次请求的一些参数进行设置。这里面比较重要的是三个timeout参数，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RequestConfig requestConfig = RequestConfig.custom()</span><br><span class="line">            .setConnectionRequestTimeout(<span class="number">30000</span>).setConnectTimeout(<span class="number">30000</span>)</span><br><span class="line">            .setSocketTimeout(<span class="number">30000</span>).build();</span><br><span class="line">HttpRequest request = <span class="keyword">new</span> HttpGet();<span class="comment">// 或者new HttpPost()等</span></span><br><span class="line">request.setConfig(requestConfig);</span><br><span class="line">httpclient.execute(request);</span><br></pre></td></tr></table></figure><p>这三个timeout到底是干什么的？</p><p>###ConnectionRequestTimeout</p><p>看了上一章关于Connection的解读，这个参数的概念就十分清晰了。但我们还是从源码里追溯一下：</p><p>其调用栈大概是：</p><p><code>Httpclient#execute(HttpRequest)</code>  –&gt; <code>InternalHttpClient#doExecute(HttpHost, HttpRequest, HttpContext)</code>  –&gt; <code>MainClientExec#execute(HttpRoute, HttpRequestWrapper, HttpClientContext, HttpExecutionAware)</code>  </p><p>这个connectionTimeOut真正起作用的地方在这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClientExec</span> <span class="keyword">implements</span> <span class="title">ClientExecChain</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CloseableHttpResponse <span class="title">execute</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> HttpRoute route,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> HttpRequestWrapper request,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> HttpClientContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> HttpExecutionAware execAware)</span> <span class="keyword">throws</span> IOException, HttpException </span>&#123;</span><br><span class="line">      <span class="comment">// 省略前后的无关语句</span></span><br><span class="line">     <span class="comment">// 在doExecute中，requestConfig参数被包装到context里面了</span></span><br><span class="line">      <span class="keyword">final</span> RequestConfig config = context.getRequestConfig();</span><br><span class="line">      <span class="comment">// 下面这个语句我们是熟悉的</span></span><br><span class="line">      <span class="keyword">final</span> ConnectionRequest connRequest = connManager.requestConnection(route, userToken);</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> timeout = config.getConnectionRequestTimeout();</span><br><span class="line">      managedConn = connRequest.get(timeout &gt; <span class="number">0</span> ? timeout : <span class="number">0</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">      <span class="comment">// 之后的省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后去追溯<code>connRequest.get</code>方法，最终还是追溯到<code>getPoolEntryBlocking</code>方法里面去了。就是timeout和deadline的那个关系，可以关注一下上面的代码块。意思就是在等待队列里等到deadline还没法获取connection，就会抛<code>TimeoutException</code>异常。</p><h3 id="ConnectTimeout"><a href="#ConnectTimeout" class="headerlink" title="ConnectTimeout"></a>ConnectTimeout</h3><p>还是从<code>MainClientExec#execute(HttpRoute, HttpRequestWrapper, HttpClientContext, HttpExecutionAware)</code>去追溯，会发现有这么一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!managedConn.isOpen()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.log.debug(<span class="string">"Opening connection "</span> + route);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 当连接未打开时，首先建立连接</span></span><br><span class="line">        establishRoute(proxyAuthState, managedConn, route, request, context);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> TunnelRefusedException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.log.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.log.debug(ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        response = ex.getResponse();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用栈是：<code>MainClientExec#establishRoute</code>  –&gt;  <code>PoolingHttpClientConnectionManager#connect(HttpClientConnection, HttpRoute, int, HttpContext context)</code>  –&gt;  <code>DefaultHttpClientConnectionOperator#connect(ManagedHttpClientConnection, HttpHost, InetSocketAddress, int, SocketConfig, HttpContext)</code></p><p>最后调用了<code>ConnectionSocketFactory#connectSocket(...)</code>方法，其实就是说这次建立连接的超时时间……好吧，是因为我懒得继续追溯源代码了。就这样敷衍了事吧。</p><h3 id="SocketTimeout"><a href="#SocketTimeout" class="headerlink" title="SocketTimeout"></a>SocketTimeout</h3><p>这个调用栈太深了，转来转去。我也懒得追踪了……总之意思就是连接多久不断开。当我们连接的是一个需要很长时间才能返回的Http接口时，将这个时间调的长一些以避免连接断开。但是这个也有副作用，就是假如设置了一个不合理的长时间，而被连接的服务出错或者挂掉了，那就会等待太久。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Apache-HttpClient的几个重要参数&quot;&gt;&lt;a href=&quot;#Apache-HttpClient的几个重要参数&quot; class=&quot;headerlink&quot; title=&quot;Apache HttpClient的几个重要参数&quot;&gt;&lt;/a&gt;Apache HttpCli</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM调试工具使用</title>
    <link href="http://yoursite.com/2020/05/07/JVM%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/05/07/JVM%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</id>
    <published>2020-05-07T06:03:53.000Z</published>
    <updated>2021-04-22T04:43:17.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM调试工具使用简介"><a href="#JVM调试工具使用简介" class="headerlink" title="JVM调试工具使用简介"></a>JVM调试工具使用简介</h1><p>JVM调试工具是解决线上问题的重要方法。一些常见的线上问题比如说运行时单线程耗时过长、GC无法申请到足够的空间而产生OOM错误。这些线上的错误十分恼人，目前我们对于响应时间过长的处理，大多数是增加log，然后分析哪一步耗时比较长，这种做法并不是总是管用，因为有些多线程的问题可能很难复现，比如死锁，第二是并不是所有的生产环境都跟现在一样自由，我们可以随意部署、重启。至于OOM的处理，我们一直就没有好的办法，现在只能说从数据方面找问题，看是不是数据有问题？或者通过阅读代码对数据量进行估算，这些方法一是非常耗时，二是并不准确。</p><p>因此，掌握一些通用的JVM调试工具还是非常必要的。</p><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>上面说到的两个问题，都与JVM的内存管理和线程运行有关系，JVM主要的调试工具和很大一部分参数，都是用来调整JVM的堆栈表现，因此，必须先了解JVM的内存模型，才能更好地理解之后调试工具的意义。</p><p>在深入了解JVM内存模型之前，有几个问题需要提前明确：</p><ol><li>JVM内存粗略分为堆内存、栈内存、本地内存三个部分。其中堆内存和栈内存都是使用虚拟机内存，而本地内存则直接使用了宿主机物理内存，JVM内存和虚拟机内存加起来受到物理内存和交换页的限制。在主机主要跑一个JAVA进程的时候，要注意不可能给JVM分配所有的内存，以免本地内存不够用而引发OOM。</li><li>JVM内存模型并非一成不变，随着JDK版本和垃圾回收机制的不同，JVM的内存实际状况都可能发生变化。比如说，在使用G1垃圾回收器的时候，堆内存就会被分为一块一块的，和使用其他回收期时堆内存连续分配有很大不同。并且自JDK1.8开始，原来存在于hotspot虚拟机中的永久代被移除，原来在永久代的方法区被移动到直接内存中，而运行时常量池被移动到堆中。</li><li>堆是JVM管理的最大一部分内存，远远超过栈空间的大小，在绝大多数情况下，也远超使用的本地内存的大小。因此，在JVM启动参数中，根据合理的评估准确设置堆内存大小，是JVM内存管理的一个重要手段。</li><li>根据IBM的研究，98%的java对象都在建立以后很快就死亡，没有活过下一次的垃圾回收。</li></ol><h3 id="内存模型简介"><a href="#内存模型简介" class="headerlink" title="内存模型简介"></a>内存模型简介</h3><p><img src="https://www.history-of-my-life.com/imgs-for-md/jvm-memory-20190811.jpg" alt="JVM内存模型"></p><p><strong>注意</strong>，上面的图是JDK1.7及之前的实现。但是大概意思是这样。</p><p>java运行时的数据区域包括程序计数器、java虚拟机栈、本地方法栈、java堆、方法区、运行时常量池和直接内存。</p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>虽然商用虚拟机在实现这个概念时可能比较复杂，但从概念上来理解，程序计数器就是指示下一条命令的地址的一个计数器而已。显然，因为每个栈有自己的运行进度，因此程序计数器显然是栈私有的。因为它基本上只记录一个地址，因此可想而知，它占得内存空间非常小，在我们讨论内存问题时，几乎可以忽略不计，因此，这个区也是唯一一个没有定义什么内存溢出错误的区。</p><h4 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h4><p>一看名字就知道是线程私有的。保存的主要是局部变量、操作数栈、动态链接、方法出口等。这些数据本身并不会占用太多空间，因为new出来的对象原则上仍然是在堆里面分配，根据一些大公司的研究，一般1M的默认栈空间大小足以负担1000-2000的栈深度，基本是够用了。</p><p>但是并不是说栈空间在所有情况下都不需要调整，与栈空间相关的异常有两个，一个是真的递归超过了最大栈空间，那就会出现StackOverflowError，如果允许虚拟机栈动态扩展，那么当其向堆扩展时发现没有空间，就会抛出OOM异常。其实这是一个问题的两个表现形式，都是栈空间用的太多了，只有一种情况除外，就是不停地申请线程，导致线程栈的数量太多而导致OOM，在这种情况下可能需要将栈空间调小一点。</p><p>与虚拟机栈相关的虚拟机参数有： </p><ul><li>-Xss 设置每个线程的栈大小，比如-Xss128k， -Xss1m</li></ul><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>当JVM调用本地方法时，即调用使用其他语言编写，并且编译为物理机上可运行的程序的接口时，就会用到本地方法栈。这只是个概念，一些虚拟机把这个栈和虚拟机栈合二为一了，也没什么问题，比如最常用的hotsopt虚拟机，下面的介绍也主要是基于这个虚拟机。</p><h4 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h4><p>对绝大多数应用来说，这是虚拟机管理的最大的一部分内存，所有线程共享，这个区域唯一的目的就是存放对象，从概念上来讲，所有new出来的对象都会在这里分配内存（有一些优化手段会改变这个事实，但从概念上仍然可以这么认为）。</p><p>堆内存的具体结构和垃圾回收的方式紧密相连。比如说，现在主流的分代垃圾回收方式，对新生代采取复制算法，对老年代采取标记-整理算法，因此新生代和老年代一般是两整块区域，而因为新生代采取了复制算法，因此又分为eden区（伊甸园）和两个survivor区，其比例大约是8:1:1。</p><p>在大部分情况下，新生代和老年代都是各自占据连续的一整块内存（逻辑上的一连续一整块，物理上未必），在采用了G1垃圾回收器的JVM虚拟机中，eden、survivor、old被划分成大小一样的一些块，一个块默认是1M大小，JVM用空闲列表来维护这些块，其内存构造又有所不同。</p><p>堆内存可以扩展，也可以不扩展。固定大小的堆比较稳定，稳定的堆对于维护稳定的老年代大小比较有利，在一定程度上可以减少GC的次数，但是固定大小的堆在实际利用率不高的情况下，会增加每次GC的时长。</p><p>与堆内存相关的虚拟机参数茫茫多，整理如下：</p><ul><li>-Xms 初始堆大小，比如 -Xms1024m。默认情况为物理内存的1/64，在使用容器时比较复杂。</li><li>-Xmx 最大堆大小，比如 -Xmx8196m。默认情况为物理内存的1/4，在使用容器时比较复杂。当-Xms=-Xmx的值时，堆不会进行扩展和收缩，是稳定的。</li><li>-Xmn 年轻代大小，比如-Xmn2g。整个堆大小=年轻代大小+年老代大小+永久代大小（要注意到1.8以后就没有永久代了），因此调整年轻代的大小，就会挤占老年代的空间，这个值对系统的影响比较大，需要根据情况进行设置，一般来说，年轻代大小是老年代大小1/2比较稳妥，在较老的JVM设置中，hotspot建议的值是<code>年轻代/堆总大小=3/8</code>。比如如果系统中充满了大量短命的大对象，那么增加年轻代的大小，甚至使其大于老年代，都是可以考虑的。</li><li>-XX:NewRatio 设置年轻代与老年代大小的比值，如-XX:NewRatio=4代表年轻代是老年代的1/4，在设置了Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</li><li>-XX:SurvivorRatio eden和survivor之间的大小比例，鉴于98%的对象都是朝生夕死，因此这个比值一般都设置成8:1:1，这也是默认值。</li></ul><p>在使用到容器时，JDK1.8_131之前的JVM不能识别容器对于硬件资源的限制，总是能读到物理机的内存，因此，在不设置-Xms和-Xmx时，容器中的JVM虚拟机会按照物理机内存的1/64和1/4去申请，很容易在超出限制后被杀掉。于是需要手动设置这两个值。</p><p>自动JDK1.8_131以后，JVM增加了一个实验特性，自动感知容器大小，需要加两个参数以开启，这两个参数如下：</p><ul><li>-XX:+UnlockExperimentalVMOptions 打开JDK的实验特性。<ul><li>-XX:+UseCGroupMemoryLimitForHeap 要求感知container的大小</li></ul></li></ul><p>同时，增加了一个参数来调整优化默认表现。</p><ul><li>-XX:MaxRAMFraction 比如-XX:MaxRAMFraction=1，表示JVM管理的堆大小是虚拟机内存的多少分之一，默认情况下是4。显然这个值太保守了，在很多情况下，我们的容器主要就跑一个JVM，只用1/4的内存还是太浪费了。于是一般需要调整这个值到2，但是随着容器内存的增大，1/2的浪费也不能接受了，但一旦申请成1，因为元空间的存在，就必然爆内存。</li></ul><p>针对这种情况，有两个解决方案，一个是手动设置-Xms和-Xmx。但这又太不灵活了，假如我改了容器的内存，就又要手改参数，所以最好是用容器的EntryPoint来解决这个问题。</p><p>第二种解决方案依赖于更高版本的JDK，至少在我们使用的JDK1.8_191中可以使用下列参数来配置：</p><ul><li><p>XX:+UseContainerSupport  作用如其名</p><ul><li>XX:MaxRAMPercentage 比如XX:MaxRAMPercentage=90.00，意思是使用容器内存的90%作为JVM管理的堆。具体使用多少还需要根据实际环境来调整。</li></ul></li></ul><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>它用于存储已被加载的虚拟机的类信息、常量、静态变量、即时编译器编译后的代码等数据。这些都是java加载时产生的一些数据。在JDK1.7以前，这个区在所谓的永久代，但是JDK1.8以后，这个区被移动到直接内存中去了，直接内存也有个好听的名字，叫元空间（metadataSpace）</p><p>一般来说，这个区域不怎么需要垃圾回收，垃圾回收的效果也不是很令人满意。但是在大量使用反射、动态代理或者字节码织入技术的框架中，因为可能生成比较多的动态类，这部分的空间也有可能面临压力，如果没有空间了，就会抛出异常。</p><p>现在因为这个区使用了直接内存，因此要牢记JVM内存+直接内存一起受到物理内存的限制，如果给JVM内存分配的空间过大，挤占了直接内存的大小，那么有可能会出现堆明明不怎么满，但却OOM的问题，或者出现因为内存换页，导致运行速度大幅下滑的问题。</p><p>在一些大量使用了NIO的框架中，也要注意直接内存的分配大小。</p><p>与此相关的参数包括：</p><ul><li>-XX:MaxDirectMemorySize 调整直接内存大小。</li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>JDK1.7之前，运行时常量池放在永久代，和方法区放在一起，JDK1.7之后，已经把运行时常量池移动到堆中了。经查询，网文中关于这一块的细节部分讲的不多，《深入理解JVM虚拟机》那么书又是基于1.7的。所以下面这段话请存疑地看。</p><p>JDK1.8以后，字符串常量移动到了堆中，但是基本类型包装类等运行时常量池还是在方法区，也就是在元空间。在java中，所有的基本类型包装类都有常量池，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然用到了常量池，而这个上限是可以通过虚拟机参数来调整的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.lang.Integer.IntegerCache.high=xxxx</span><br></pre></td></tr></table></figure><p>但是下限不可调整。</p><p>特别的，应该关注一下字符串常量池，目前它在堆中，而且可以通过<code>String.internal()</code>进行动态地添加，因此需要关注OOM问题。</p><h4 id="直接内存-元空间"><a href="#直接内存-元空间" class="headerlink" title="直接内存-元空间"></a>直接内存-元空间</h4><p>主要在JDK1.8以后用于存放方法区、字符串常量以外的常量池，以及被使用了NIO的框架使用。在设置JVM的堆内存时，应当考虑到元空间的大小，避免堆内存对着物理内存上限去设置，否则将会出现比较难以排查的OOM问题。</p><p>与此相关的JVM参数包括，注意这些参数只有在JDK1.8以上才可用</p><ul><li>-XX:MetaspaceSize=128m  元空间的初始化大小</li><li>-XX:MaxMetaspaceSize=512m 元空间的最大值</li></ul><h3 id="内存回收机制简介"><a href="#内存回收机制简介" class="headerlink" title="内存回收机制简介"></a>内存回收机制简介</h3><h4 id="啥样的对象算是死亡了"><a href="#啥样的对象算是死亡了" class="headerlink" title="啥样的对象算是死亡了"></a>啥样的对象算是死亡了</h4><h5 id="引用计数器"><a href="#引用计数器" class="headerlink" title="引用计数器"></a>引用计数器</h5><p>为每个对象维护一个引用计数器，引用计数器为0就认为死了。这个思想很常用，比如说Cpp的智能指针。但用在垃圾回收上有个很大的问题，就是循环引用时会导致发生循环引用的对象引用计数器永远不是0，实际上不能访问的对象也不能清除。</p><h5 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h5><p>即从一组根节点出发进行遍历，可达的对象我们都认为存活，不可达的对象当然就是死了。这个方法听起来不错，这一组根节点被称为<code>GC roots</code>。这个方法最重要的是定义<code>GC roots</code>有哪些。</p><ul><li><p>System Class（由bootstrap装载的类）</p><p>Class loaded by bootstrap/system class loader. For example, everything from the rt.jar like java.util.*</p></li><li><p>JNI Local（native code的局部变量）</p><p>Local variable in native code, such as user defined JNI code or JVM internal code.</p></li><li><p>JNI Global（native code的全局变量）</p><p>Global variable in native code, such as user defined JNI code or JVM internal code. </p></li><li><p>Thread Block（JVM虚拟机线程栈）</p><p>Object referred to from a currently active thread block. </p></li><li><p>Thread（状态不是TERMINTED的线程）</p><p>A started, but not stopped, thread. </p></li><li><p>Busy Monitor（被用作锁的对象）</p><p>Everything that has called wait() or notify() or that is synchronized. For example, by calling synchronized(Object) or by entering a synchronized method. Static method means class, non-static method means object. </p></li><li><p>Java Local（局部变量）</p><p>Local variable. For example, input parameters or locally created objects of methods that are still in the stack of a thread. </p></li><li><p>Native Stack（本地方法栈）</p><p>In or out parameters in native code, such as user defined JNI code or JVM internal code. This is often the case as many methods have native parts and the objects handled as method parameters become GC roots. For example, parameters used for file/network I/O methods or reflection. </p></li><li><p>Finalizable（在Finalizable队列中等待的对象）</p><p>An object which is in a queue awaiting its finalizer to be run. </p></li><li><p>Unfinalized（重写了finalize方法，但是还没有被finalize过的对象）</p><p>An object which has a finalize method, but has not been finalized and is not yet on the finalizer queue. </p></li><li><p>Unreachable（像是自定义的根这样的）</p><p>An object which is unreachable from any other root, but has been marked as a root by MAT to retain objects which otherwise would not be included in the analysis. </p></li><li><p>Java Stack Frame（虚拟机栈）</p><p>A Java stack frame, holding local variables. Only generated when the dump is parsed with the preference set to treat Java stack frames as objects. </p></li><li><p>Unknown</p><p>An object of unknown root type. Some dumps, such as IBM Portable Heap Dump files, do not have root information. For these dumps the MAT parser marks objects which are have no inbound references or are unreachable from any other root as roots of this type. This ensures that MAT retains all the objects in the dump.</p></li></ul><h5 id="Live-or-die"><a href="#Live-or-die" class="headerlink" title="Live or die?"></a>Live or die?</h5><p>还有一些对象，在内存充足的情况下允许他们存在，在内存不足时就可以回收，典型的比如说缓存。JDK也考虑到了这些用途，因此推出了集中不同强度的引用。</p><ul><li><p>强引用。只要引用存在，永远不会回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></li><li><p>软引用。在GC时，会将这些对象列入回收范围，但放在第二次回收中，如果第一次回收还没有足够的内存，才会回收他们。注意最好直接不要有其他引用引到<code>new Object()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> Object());</span><br><span class="line"><span class="comment">// 下面的写法就不好</span></span><br><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(o);</span><br><span class="line">o = <span class="keyword">null</span>;<span class="comment">// 如果忘记，就有一个强引用指向该object</span></span><br></pre></td></tr></table></figure></li><li><p>弱引用。只能存活到下一次GC，下一次GC必然会回收。(有趣的是，还有一个WeakHashMap类)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> Object());</span><br></pre></td></tr></table></figure></li><li><p>虚引用。这玩意对GC没有任何影响，也没法通过一个虚引用获得一个对象实例。为一个对象设置了虚引用后，该对象被回收时能收到一个系统通知而已。</p></li></ul><h5 id="可达性分析的实际操作问题与safepoint"><a href="#可达性分析的实际操作问题与safepoint" class="headerlink" title="可达性分析的实际操作问题与safepoint"></a>可达性分析的实际操作问题与safepoint</h5><p><a href="https://rednaxelafx.iteye.com/blog/1044951" target="_blank" rel="noopener">找出栈上的指针/引用</a></p><p>在上面我们看到，可达性分析法需要首先去枚举gc roots，因为gc roots除了静态变量这种在类加载时已经确定的部分以外，还有一些像在线程栈中的引用这些不断发生变化的部分，因此，每一次要进行可达性分析，从理论上讲都需要先枚举gc roots</p><p>这其实是一项比较耗费时间的工程，而且必须要停止虚拟机其他线程的运行。因为如果允许在枚举的时候gc roots还在不断发生变化，那枚举的结果显然不准。这个暂停的动作，在hotspot虚拟机中称为Stop The World（STW）</p><p>那么有没有办法加速这个过程呢？有，首先，对于那些在类加载时期就已经能确定的引用，我们当然可以用一些数据结构把它记录下来，而对于运行时的一些数据，实际上也可以在某些位置把相关栈帧里的引用数据保留下来，gc roots的枚举速度就会提升。显然商用的虚拟机都这么做了（不然其实我也想不出来这些优化），保存这些gc roots位置的数据结构，称为OopMap（HotSpot的称呼）。</p><p>但这里就有个新问题，能引起栈帧变化的指令非常多，如果每一条指令都生成一个OopMap，那虚拟机的效率得低成什么样子。因此，JVM实际上只在特殊的指令处生成OopMap，这些指令处就称为“safePoint”，safepoint的选择，既要避免每一条指令来一下，也要避免太长时间到达不了safepoint，因此，在一些执行时间较长的任务前后进行保存似乎是个好主意，这样至少避免了长时间无法到达safepoint，这就包括：</p><ul><li><p>循环的末尾</p></li><li><p>方法返回前</p></li><li><p>调用方法的call指令之后</p></li><li><p>可能抛出异常的位置</p></li></ul><p>在这样的指令处，java可能会生成一个操作码，指令线程主动去更新自己的OopMap。在等待所有线程到达自己的safepoint时，JVM一般是设置一个GC的标志位，线程会轮询这个标志位，发现标志位被置位后，就自己等待，所有线程都等待后，就是Stop the word，标记GC roots开始。</p><h5 id="可达性分析的实际操作问题与JNI"><a href="#可达性分析的实际操作问题与JNI" class="headerlink" title="可达性分析的实际操作问题与JNI"></a>可达性分析的实际操作问题与JNI</h5><p>上面又出现了一个新问题，那就是OopMap的维护，需要JVM的参与，实际上在java的字节码中加了一点料。但是当使用JNI的时候，那些本地方法的调用并不需要JVM的参与，他们怎么去维护这个OopMap呢？当然其实可以不维护，采取每次全扫一遍本地方法栈的方式来解决问题。</p><p>但是Hotspot虚拟机选择了另一种方式，即所有经过JNI调用边界的引用，都必须通过一个中间对象——“句柄”（handler），JNI要调用java API的时候也需要用句柄包装指针。而句柄表是可以由JVM维护的，这样需要知道JNI方法使用的java对象只需要扫描句柄表就可以了。</p><p>带来的代价是JNI调用需要进行句柄的中转，效率有所下降。</p><h4 id="几种不同的思想"><a href="#几种不同的思想" class="headerlink" title="几种不同的思想"></a>几种不同的思想</h4><h5 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记 - 清除"></a>标记 - 清除</h5><p>就是对所有已死亡的对象进行标记，然后把他们从内存中清除出去。标记的办法着实也不怎么高效，因为要标记已死亡对象，所以需要遍历堆内存的对象头，而清除出去主要是维护空闲列表，这两者消耗都比较大。</p><p>而且，这还很容易造成内存碎片，导致在内存明明还有很多空间时，大内存无法分配，而频繁引起GC，甚至Full GC。</p><h5 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记 - 整理"></a>标记 - 整理</h5><p>就是对所有还存活的对象进行标记，然后把他们移动到内存的一端去，之后将指示空闲内存开始位置的指针直接移动到最后一个存活对象尾部。这样就避免了内存碎片。</p><h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h5><p>从概念上讲，是将内存分为相等大小的两个部分，当一个部分满了以后，就将这个部分的存活对象移动到另外一个部分去。这样最大的问题是内存使用率太低。但是根据前面的介绍，其实98%左右的对象都是朝生夕死，那么实际上真正需要复制的对象大多数情况下都非常少，所以，商用的虚拟机比如hotspot，在使用复制算法时并没有真的把空间分成相等的两个大小，而是分为eden、from survivor、to survivor三个区域，同时只使用eden和其中一个survivor，当两个都到了回收阈值的时候，就把存活的对象复制到另一个survivor中去，再把eden和from survivor清空。</p><p>比如说，在极端情况下，存活的对象非常多，to survivor放不下怎么办。这时候一般会直接把一些对象放到老年代去。因此，实际上在每一次GC开始前，都会查看一下老年代的空间，看老年代是不是足够放下极端情况下的所有新生代对象，如果足够，那么这次新生代GC可以无风险进行，万一to survivor放不下了，反正老年代够，就扔进去好了。那如果老年代如果空间不足以放得下新生代所有对象呢？这就涉及到一个新的问题，就是full gc和冒险策略。当允许冒险时，只要老年代的空间大于以往放入老年代的平均空间，那就进行新生代GC，万一失败，就进行full gc，如果不允许冒险或者老年代的空间小于以往放入老年代的平均空间，就直接进行full gc。</p><p>一般将新生代的gc成为Minor GC，而带老年代一起的GC称为Full gc。</p><h5 id="分代算法"><a href="#分代算法" class="headerlink" title="分代算法"></a>分代算法</h5><p>因为新生代对象绝大多数都是朝生夕死，因此适合使用复制算法，但一些对象总是会逐渐稳定下来，那么这些对象来回复制的话代价就很高了，因此现在一般商用虚拟机都实现了分代算法，对新生代和老年代采取不同的回收策略，比如新生代用复制算法，老年代用标记-整理算法。</p><h5 id="分代算法引发的新问题与Remembered-Set"><a href="#分代算法引发的新问题与Remembered-Set" class="headerlink" title="分代算法引发的新问题与Remembered Set"></a>分代算法引发的新问题与Remembered Set</h5><p>‼️<strong>以下内容有很多自己的理解，如果错漏概不负责，请抱着审慎的态度阅读。</strong></p><p>如果每一次都做Full GC，那么我们的思路就比较简单，就是从GC roots开始遍历探寻可达性即可，标记所有的可达数据，标记为存活。之后开始整理就完了。</p><p>但如果是分代处理的话，就会有一些新问题。比如从GC roots遍历是个比较耗时的操作，特别是假如我们只想回收新生代的垃圾，那么遍历老年代就是一个不必要的开销，特别是老年代堆很大，遍历花费的时间还不少。于是，商用虚拟机在新生代收集时，都不扫描老年代的对象，即，从GC roots开始遍历时，一旦遇到老年代的对象，就直接打住（判断是不是老年代对象其实比较简单，老年代的内存空间有上下界），不再继续深入。这样就只遍历了新生代对象。</p><p>但这又有一个问题。假如GC roots连接了一个老年代对象，但这个老年代对象持有了一个新生代对象的引用，但是上面说的方式就扫描不到，这就会把一个实际存活的新生代对象漏掉。为了解决这个问题，又引入了一个新概念，就是Remembered Set。</p><p>每当老年代对象引用新生代对象时，在新生代旁边开辟一块单独的空间，把这个引用关系记录下来，当引用断开时，清除这个引用关系。于是，GC收集器就可以在不完整扫描老年代对象的情况下，直接去读取这些记录就知道新生代的哪些对象被老年代引用了。换言之，GC收集器将这个记录也作为GC roots就可以了。</p><p>这个记录就叫做Remembered Set。在一些文章中我们会看到Card Table这个概念，这是Remebered Set的一种具体实现。</p><p>可见，safe point和Remembered Set技术的主要思想都是用空间换时间，尽量减少GC时要扫描的范围。</p><h3 id="垃圾收集器的实现"><a href="#垃圾收集器的实现" class="headerlink" title="垃圾收集器的实现"></a>垃圾收集器的实现</h3><p>垃圾收集器有很多种不同的实现，没有一种垃圾收集器适应所有的应用场景，要合理选择垃圾收集器，就要首先了解关于垃圾收集器和GC的一些基本指标。</p><h4 id="两个需要注意的指标"><a href="#两个需要注意的指标" class="headerlink" title="两个需要注意的指标"></a>两个需要注意的指标</h4><p>除了垃圾回收要确实干净、安全以外。有两个有关时间的指标需要考量。</p><ul><li><p>吞吐量。</p><p>即JVM运行后，用于执行用户代码的时间和CPU消耗的总时间的比例，这个比例越高，说明CPU更多地用于用户代码执行，比如说JVM运行了100分钟，垃圾回收花掉了1分钟，那么吞吐量就是99%。</p></li><li><p>线程停顿时间</p><p>因为在枚举根节点等情况下，需要STW，因此用户线程会被停顿，这个停顿时间，当然我们希望是越短越好，这样就能尽量不影响用户操作了。</p></li></ul><p>不同的垃圾收集器侧重点不同，不同的应用的需求也不同。比如说，CPU运算密集型的应用（这种应用为啥要用java写），显然更关注吞吐量，希望有更多时间花在用户工作上。而一个服务器，更希望用户线程被停顿的时间越短越好，尽量不要影响用户操作比较好。</p><p>因此，不同的应用下选择合理的垃圾收集器，也是程序员的一种能力。</p><h4 id="两种需要理解的GC类别"><a href="#两种需要理解的GC类别" class="headerlink" title="两种需要理解的GC类别"></a>两种需要理解的GC类别</h4><p>根据 <code>JVM界唯一认证扛把子·他说的不一样的都是错的·真·R大</code> 的文章：<a href="https://www.zhihu.com/question/41922036/answer/93079526" target="_blank" rel="noopener">Major GC和Full GC的区别是什么？</a></p><blockquote><p>针对HotSpot VM的实现，它里面的GC其实准确分类只有两大种：</p><p>Major GC通常是跟full GC是等价的，收集整个GC堆。但因为HotSpot VM发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说“major GC”的时候一定要问清楚他想要指的是上面的full GC还是old GC。</p><p>最简单的分代式GC策略，按HotSpot VM的serial GC的实现来看，触发条件是：</p><p>HotSpot VM里其它非并发GC的触发条件复杂一些，不过大致的原理与上面说的其实一样。<br>当然也总有例外。Parallel Scavenge（-XX:+UseParallelGC）框架下，默认是在要触发full GC前先执行一次young GC，并且两次GC之间能让应用程序稍微运行一小下，以期降低full GC的暂停时间（因为young GC会尽量清理了young gen的死对象，减少了full GC的工作量）。控制这个行为的VM参数是-XX:+ScavengeBeforeFullGC。这是HotSpot VM里的奇葩嗯。可跳传送门围观：<a href="https://www.zhihu.com/question/48780091/answer/113063216" target="_blank" rel="noopener">JVM full GC的奇怪现象，求解惑？ - RednaxelaFX 的回答</a></p><p>并发GC的触发条件就不太一样。以CMS GC为例，它主要是定时去检查old gen的使用量，当使用量超过了触发比例就会启动一次CMS GC，对old gen做并发收集。</p></blockquote><h4 id="具体的垃圾收集器"><a href="#具体的垃圾收集器" class="headerlink" title="具体的垃圾收集器"></a>具体的垃圾收集器</h4><p>首先，这些垃圾收集器包括：</p><p><img src="https://img-blog.csdn.net/20160505170035450" alt="hotspot垃圾收集器"></p><p>红色区域表示新生代垃圾收集器，而绿色区域表示老年代垃圾收集器。其中有连线表示可以配合使用。</p><h5 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h5><p>就是单线程，Stop The World后实现垃圾收集。虽然说STW不太友好，单线的整体程效率也不高。但他因为简单，所有具有最高效率的单线程回收效率。所以至今仍然广泛用在java的Client模式（适用于GUI的开发）下，这个场景一般内存占用不大，收集几十兆上百兆的新生代还是没什么明显的停顿感。</p><ul><li><p>插播：Jvm的Client与Server模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ java -version</span><br><span class="line">java version &quot;1.8.0_131&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_131-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)</span><br></pre></td></tr></table></figure><p>在机器上运行<code>jave -version</code>就能看到模式，在最后一行。一般来说，Client模式启动更快，但启动后运行时和垃圾回收表现都稍差；Server编译更彻底，在启动时稍慢，但运行后速度和垃圾回收效果都比较好。一般可以简单认为，Client适合开发Gui，而Server适合做服务器。</p></li></ul><p>与Serial收集器相关的虚拟机参数包括：</p><ul><li>-XX:SurvivorRatio=8，意思是eden/survivor区的比例，默认为8，上面都说了无数次了。</li><li>-XX:MaxTenuringThreshold  这是与垃圾回收器紧密相关的一个参数，意思是当一个新生代的对象经过一次gc之后如果存活下来了，那么他的年龄会+1，当达到这个参数指定的年龄后，就会被移动到老年代。对象从survivor移动到老年代还有一个可能，就是当survivor区中同年龄的对象达到或超过一半survivor空间大小，那么大于等于此年龄的对象都会被移动到老年区。该参数只有用串行GC回收器才有效。</li><li>-XX:PretenureSizeThreshold=\<byte size> 意思是当对象大于这个值时直接在老年代分配，以避免大对象的来回复制。但有利有弊吧，因为老年代不经常被回收，所以如果短命大对象直接在老年代分配，会导致不断需要触发full gc，得不偿失。这个参数默认是0，也就是所有对象都在eden分配。</byte></li><li>-XX:HandlePromotionFailure 就是上面所说的复制算法的老年代担保是否允许冒险。但在JDK1.6以后，这个参数已经无效，JVM总是会选择冒险策略。</li></ul><p>触发时机：</p><p>eden区不够分配对象了。</p><h5 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h5><p>Serial收集器的多线程版本，复用了Serial的大多数代码，和相关虚拟机参数。</p><p>在单CPU环境下，其变现绝对不可能超过Serial，甚至双CPU也未必能超过，但多CPU下性能表现一般会更好。而且因为只有它能与CMS配合使用，因此在server模式下经常使用。</p><p>触发时机：</p><p>eden区不够分配对象了</p><h5 id="Parallel-Svavenge"><a href="#Parallel-Svavenge" class="headerlink" title="Parallel Svavenge"></a>Parallel Svavenge</h5><p>这也是个新生代的收集器，使用复制算法，并且多线程。看起来和parNew是一样的。但是他的关注点和ParNew不一样，这个垃圾收集器更加关注吞吐量。因此，他提供了两个参数来设置吞吐量和最大垃圾收集停顿时间。</p><ul><li>-XX:MaxGCPauseMills=100 意思是<strong>请求</strong>垃圾收集器每次垃圾回收时暂停的时间尽可能不超过这个值。但只是尽可能，不能完全保证，而且每次暂停时间短有可能造成GC的次数增多，造成吞吐量下降。</li><li>-XX:GCTimeRatio=99 就是CPU执行用户任务的时间/GC时间的值，数值越大，允许的GC时间就越短。比如99，就是说只允许1%的时间用于垃圾收集。但这个也只能是建议，不可能完全保证。</li><li>-XX:UseAdaptiveSizePolicy 当这个参数打开以后，就不用手动指定新生代大小、Eden和Survivor区的比例，晋升老年代的年龄值等细节参数了。虚拟机会动态监控系统运行状况，得到一个合适的值，并设置前两个参数，给虚拟机一个目标，虚拟机就会自动调整以上参数。</li></ul><p>触发时机：</p><p>eden区不够分配了</p><h5 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h5><p>Serial的老年代版本，主要意义除了和Serial一起用在client模式下以外，还有作为CMS收集器的后备方案。</p><p>触发时机：</p><ol><li>在Client模式下使用时，触发时机是老年代空间不足</li><li>作为CMS的后备方案时，触发时机是：当CMS收集器在并发清理环节浮动垃圾撑爆了剩余的老年代空间，就会抛出ConcurrentModeFailure。从而触发Serial Old收集。</li></ol><h5 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h5><p>是Parallel Svavenge收集器的老年代版本，和新生代的Parallel Svavenge收集器配合，能达到合理控制吞吐量的效果。</p><p>触发时机：</p><p>老年代空间不足。</p><h5 id="CMS（Concurrent-Mark-Swap）"><a href="#CMS（Concurrent-Mark-Swap）" class="headerlink" title="CMS（Concurrent Mark Swap）"></a>CMS（Concurrent Mark Swap）</h5><p><a href="https://www.jianshu.com/p/2a1b2f17d3e4" target="_blank" rel="noopener">简书：图解CMS垃圾回收机制，你值得拥有</a></p><p>从名字可以看出，这个收集器是基于标记-清除算法实现的，而且多线程。</p><p>这个收集器的不同之处，在于它以获取最短停顿时间为目标，并且实现了垃圾回收线程（的一些工作阶段）与用户的任务线程并发执行。</p><p>为了实现这个目标，它分为四个阶段：</p><ul><li>初始标记。即只标记与GC roots直接关联的对象，需要STW</li><li>并发标记。从初始标记中的结果进行可达性分析。不需要STW，可以和用户线程并发执行。</li><li>重新标记。这个过程也需要STW，这是为了修正在STW期间因为用户操作而变动的那一部分标记，速度比初始标记慢一点，但是比并发标记阶段要快得多。</li><li>并发清除。把标记出来的垃圾清除掉。这个也可以和用户线程并发。</li></ul><p>因为并发标记和并发清除阶段和用户线程并发了，因此暂停时间比较短。但是这个收集器也有几个缺点：</p><ul><li><p>它的单线程收集效率显然不如之前介绍的那些收集器。而且，因为在并发过程中，它也占用了CPU，因此在单CPU或者双CPU情况下，会导致有很大的CPU资源被用作垃圾回收，用户的代码能使用的CPU资源就会受到很大的挤占。</p></li><li><p>在并发清除阶段，因为与用户线程并发，因此还会生成新的垃圾，为了应对这些新建的对象，CMS收集器必须预留足够的空间给用户线程使用，因此不能像其他收集器一样等到老年代几乎填满了再进行收集，在JDK1.5的默认情况下，当老年代使用到68%，就会激活CMS收集器，后来提升到92%。如果CMS运行期间预留的空间不足以供用户线程新申请的对象使用，那么JVM就会启动Serial Old重新处理老年代的垃圾收集，这会非常慢。</p><p>与这个行为相关的参数为：</p><ul><li>-XX:CMSInitiatingOccupancyFranction。即设置上面的百分比。设置的值如果太高，就会经常导致并发收集失败，启用Serial Old，性能会下滑明显。</li></ul></li><li><p>CMS基于并发-清除算法，意味着内存碎片会增多。因此可能对大对象分配带来麻烦。因此，在进行Full GC时，就进行内存的整理，内存整理无法并发，因此必须STW，停顿时间会变长。</p></li></ul><p>而且仔细考虑CMS的并发清除阶段，实际上还有这样一个小问题：即并发清除阶段如果发生了young GC，有新对象进入了老年区，他们是没有被标记的白对象，会不会被清除？就是<a href="https://stackoverflow.com/questions/43789967/java-cms-gc-can-a-minor-gc-occur-between-final-remark-and-concurrent-sweep" target="_blank" rel="noopener">这个问题</a>所担心的情况。这个问题的解答是，因为CMS对老年区维护了可用空间的列表，因此只要保证新进入老年区的对象放到这些可用空间里，而并发清除不扫描这些可用内存区域即可（以上有自己的猜测在里面，不一定准确）。即：并发清除阶段扫描的时候只扫描在最终标记后标记为需要清理的空间。这也是为什么CMS不能等到老年区几乎填满才进行垃圾回收的原因。（深入理解JAVA虚拟机第二版P83）说的也就是这个问题。</p><p>与CMS相关的参数非常多，简单列几个如下：</p><ul><li><p>-XX:+UseConcMarkSweepGC  开启CMS</p></li><li><p>-XX:UseCMSCompactAtFullCollection 默认开启，用于FullGC时的内存整理。</p></li><li>-XX:CMSFullGCSBeforeCompaction=1 几次不带整理的FullGC后来一次整理的，默认值为0，意味着每次进入FullGC都进行碎片整理。</li><li>-XX:ParallelCMSThreads=20 CMS默认启动的回收线程数目是 (ParallelGCThreads + 3)/4) ，如果你需要明确设定，可以通过-XX:ParallelCMSThreads=20来设定,其中ParallelGCThreads是年轻代的并行收集线程数</li><li>-XX:+UseCMSInitiatingOccupancyOnly  </li><li>-XX:CMSInitiatingOccupancyFraction=92.0 老年代空间占用达到多少时进行一次老年代垃圾回收。</li></ul><p>触发时机：</p><ol><li>如果没有设置-XX:+UseCMSInitiatingOccupancyOnly，虚拟机会根据收集的数据决定是否触发。</li><li>老年代使用率达到阈值 <code>CMSInitiatingOccupancyFraction</code>，默认92%。</li><li>新生代的晋升担保失败。</li></ol><h4 id="上述几种收集器的可能组合"><a href="#上述几种收集器的可能组合" class="headerlink" title="上述几种收集器的可能组合"></a>上述几种收集器的可能组合</h4><p>摘自<a href="https://www.zhihu.com/question/41922036/answer/144566789" target="_blank" rel="noopener">知乎：Major GC和Full GC的区别是什么</a></p><ol><li>Serial GC算法：Serial Young GC ＋ Serial Old GC （实际上它是全局范围的Full GC）</li><li>Parallel GC算法：Parallel Young GC ＋ 非并行的PS MarkSweep GC / 并行的Parallel Old GC（这俩实际上也是全局范围的Full GC），选PS MarkSweep GC 还是 Parallel Old GC 由参数UseParallelOldGC来控制；</li><li><p>CMS算法：ParNew（Young）GC + CMS（Old）GC （piggyback on ParNew的结果／老生代存活下来的object只做记录，不做compaction）＋ Full GC for CMS算法（应对核心的CMS GC在老年代给浮动垃圾预留的内存不足导致并发清除失败后full gc，开销很大）；</p></li><li><p>下面即将介绍的，新生代和老年代一起搞了的，G1收集器。</p></li></ol><h4 id="G1（Garbage-First）垃圾优先收集器"><a href="#G1（Garbage-First）垃圾优先收集器" class="headerlink" title="G1（Garbage-First）垃圾优先收集器"></a>G1（Garbage-First）垃圾优先收集器</h4><p><a href="https://ylgrgyq.github.io/2016/07/03/garbage-first-collector-understanding/" target="_blank" rel="noopener">Garbage First Collector 理解</a></p><p>G1是一款比较新的垃圾收集器。在JDK8时，需要加参数<code>-XX:+UseG1GC</code>，在JDK11时，默认使用这款垃圾收集器。这款垃圾收集器与之前介绍的一些收集器相比，有以下特点：</p><ol><li><p>能够同时处理新生代和老年代。虽然在内部也区分了不同代的不同处理方式。这也不算最大的特点，因为之前的比如说Serial收集器，就可以同时收集新生代和老年代。</p></li><li><p>对内存逻辑结构的改变很大。不像之前的收集器处理的新生代和老年代是逻辑上连续的一整块内存，启用了G1垃圾收集器的JVM，从顶层来看，虽然仍然区分了新生代和老年代，也有eden、survivor和old区，但是在具体的分配上不再是各自连续的一整块，而是划分为一个一个的Region，每一个Region的大小是固定的，最小是1M，可以以2的倍数递增，最大是32M。同时，新增了一个Humongous区，用来存储大对象，所谓的大对象，是指超过region大小一半的对象。这么做是为了防止对大对象进行反复拷贝，其堆内存结构如下图：</p><p><img src="https://www.history-of-my-life.com/imgs-for-md/JVM-G1-20190809.png" alt="G1HeapLayOut"></p></li><li><p>从顶层来看，G1收集器是基于<code>标记-清除</code>的算法，因为它更像是发现哪些Region没有存活对象了，就把这些Region的空间标记为可用。但就细节而观察，又是基于复制算法，即将一些对象从这个Region复制到另外一个Region里面去，从而把其中一些Region空出来。</p></li><li><p>创造性地建立了可预测停顿时间的机制，可以指定在M毫秒的时间片段内，消耗在垃圾回收上的时间不得超过N毫秒。（当然也不一定会满足，只是尽量满足）。这种机制的实现，是依赖它维护了每个Region回收后能清理出的空间的大小（垃圾回收价值）的优先列表，在每次垃圾回收时未必都回收，而是根据允许的垃圾回收时间，优先回收价值大的Region。这就是所谓垃圾优先（Gabage First）名称的由来。</p></li></ol><p>在实际收集过程中，G1也分为四个阶段：</p><ol><li><p>初始标记</p><p>标记GC roots中直接关联的对象，需要STW。在这个阶段完成以后，之后的用户线程新建的对象会被放到一些确定这一次不会回收的Region里面去。</p></li><li><p>并发标记</p><p>进行可达性分析，找出存活的对象。因为G1甚至不是按照新生代老年代来回收垃圾，而是按照回收的价值来回收Region。因此上面所说的分代带来的老年代（不想浪费时间扫描的对象）引用新生代的问题在这里也会暴露出来。即我们不想回收的Region里（价值低的Region），存在指向我们想回收的Region里的对象。因此，G1为每一个Region都维护了一个Remembered Set。</p><p>这一阶段和用户的线程并发。这就导致了对象引用图有可能会发生变化。</p></li><li><p>最终标记</p><p>对并发过程中用户程序修改的对象图发生的变化情况进行修正，需要STW。</p></li><li><p>筛选回收</p><p>根据用户期望时间，查询Region垃圾回收价值优先队列，确定最终要回收哪些Region（筛选），并回收。</p></li></ol><p>G1垃圾收集器看起来和CMS垃圾收集器很像，在一些缺点上也比较像，就是肯定会有一些浮动垃圾，而且在CPU数量较少时也会有一些性能挤占问题。</p><p>相关参数：</p><ul><li>-XX:G1HeapRegionSize  设置Region大小，取值范围从1m到32m，必须以2的倍数递增。如果不指定，将会根据Heap的大小自动设置，以期达到2048块region。</li><li>-XX:MaxGCPauseMillis=n  每次GC的期待最大暂停时间，以ms为单位。</li><li>-XX:G1PrintRegionLivenessInfo debug参数，默认false。在清理阶段的并发标记环节,输出堆中的所有 regions 的活跃度信息</li><li>-XX:G1PrintHeapRegions    debug参数，默认false，G1将输出哪些regions被分配和回收的信息</li><li>-XX:G1RSetUpdatingPauseTimePercent  G1收集器在GC时，更新Rset的目标时间值。</li></ul><p>G1的特点与优势</p><ul><li>适合大堆，因为不像 CMS 和 Parallel GC 在对老代进行收集的时候需要将整个老代全部收集，G1 收集老代一次只收集老代的一部分 Region</li><li>G1 的 Heap 划分为多个 Region，Young Generation 和 Old Generation 都只是逻辑概念，不是物理上隔离又连续的空间</li><li>G1 的新老代划分不是固定的，一个新代的 Region 在被回收之后可以作为老代 Region 使用，Young Generation 和 Old Generation 大小也会随着系统运行而调整</li><li>G1 的新生代收集和 Parallel、CMS GC 一样是并发的 STW 收集，且每次 YGC 会将整个 Young Generation 收集</li><li>G1 的 Old Generation 收集每次只收集一部分 Old Region，且这部分 Old Region 是和 YGC 一起进行的，所以称为 Mixed GC</li><li>和 CMS 一样，G1 也有 fail-safe 的 FGC，单线程且会做 compaction</li><li>G1 的 Old Generation GC (Mixed GC) 也是自带 compaction 的</li><li>G1 没有永久代的概念</li></ul><p>触发时机：</p><p>因为G1可以同时支持新生代和老年代的收集，所以它的触发时机更复杂一些。</p><p>对年轻代来说，触发时机就是Eden区被沾满。</p><p>对老年代来说，和CMS类似，当Old Generation空间占用<strong>整个Heap</strong>比例超过目标值(-XX:InitiatingHeapOccupancyPercent, IHOP)后触发。</p><h4 id="CMS和G1的最终标记阶段都做了些什么"><a href="#CMS和G1的最终标记阶段都做了些什么" class="headerlink" title="CMS和G1的最终标记阶段都做了些什么"></a>CMS和G1的最终标记阶段都做了些什么</h4><p><a href="https://www.zhihu.com/question/37028283" target="_blank" rel="noopener">知乎:关于CMS、G1垃圾回收器的重新标记、最终标记疑惑</a></p><p>因为CMS和G1都有并发标记阶段，也就是说，因为允许可达性分析阶段和用户线程并行。那么就必然带来一个问题，在可达性分析时，一些引用关系已经发生了变化。这些变化主要包含这两种情况：</p><ol><li>新增了部分GC roots，这些GC roots引用了一些新建的对象。</li><li>一些已有的引用关系发生了变化。比如将一个引用赋值为null，或者将一个引用引用到另外一个对象上去。其实引用到另外一个对象上，也无外乎三种情况，第一种，是使一个引用指向null，这有可能造成一个对象成为垃圾，我们称这个操作为引用删除；第二种，是使一个引用指向另外一个已存在的对象，这其实对垃圾回收没有任何印象；第三种，是新建一个对象，让这个引用指向新建的对象，这等价于发生了两步操作，一步是使引用指向null，第二步是相当于GC roots引用了新建对象。</li></ol><p>综合起来看，总共就两类操作：</p><ol><li>新建引用-对象关联，有引用指向新建对象；</li><li>删除引用-对象关联，有对象在并发标记期间不再有引用指向了。</li></ol><p>而最终标记阶段就是为了处理这些问题，CMS和G1都使用了一种叫做Write Barrier的技术，来对初始标记以后发生的变化进行记录。在这个阶段，每一次引用变化都会经过Write Barrier，记录相关的变动，最后将这些记录合并到清理对象里面去就可以了。</p><p>回忆一下，CMS的并发清除阶段因为是将死亡对象的空间直接标记为可用，因此一定不能出现漏标的情况，如果漏标了存活对象，就会导致程序出现错误。（错标虽然会造成垃圾增多，但是下次收集就完了，不会造成程序错误）。因此，CMS的最终标记阶段关注的问题是：新建引用对象必须要记录下来，删除引用倒无所谓，大不了等下一次收集。</p><p>所以，CMS采用了叫做INC write barrier的技术，就是记录每次引用新建，在最终标记阶段还需要重新扫描一遍GC roots，因此这个remark时间还比较长，一般占到一次CMS两次STW总时间的80%。</p><p>而G1就略有不同，G1使用了 Snapshot-At-The-Beginning Write Barrier(SATB)，在初始标记阶段结束后会打上一个快照，之后所有的新分配的对象通通视为活跃，然后分配到这次保证不回收的Region里面去，反正是按Region回收嘛。它更关注引用的删除，以更加准确地评估垃圾回收的价值。</p><p>追根究底，似乎CMS和G1都不非要有重新标记阶段，因为只要保证新进入老年区/新分配的内存分配在此次不回收的内存区就完了，代价是更多的浮动垃圾。但实际上还是做了重新标记，可能是JVM的开发团队评估后认为这样性能还是更好。<strong>（这一段包含自己的猜测，请审慎阅读）</strong></p><h2 id="JVM调试工具"><a href="#JVM调试工具" class="headerlink" title="JVM调试工具"></a>JVM调试工具</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="工具箱里有什么"><a href="#工具箱里有什么" class="headerlink" title="工具箱里有什么"></a>工具箱里有什么</h4><p>JVM调试工具做的事情，就是监控虚拟机的性能，并且发现发生在运行时的故障比如说死锁、内存溢出等。大部分JVM工具以命令行工具的方式提供，也有一些可视化工具，比如JConsole和VisualVM。</p><p>其中，命令行工具有：</p><ul><li><p>jps</p><p>查看主机运行的JVM的ID（和操作系统的PID相同）以及运行参数</p></li><li><p>jstat</p><p>查看虚拟机的各项统计数据。主要是一些内存占用状况，GC的情况。</p></li><li><p>jinfo</p><p>查看虚拟机的各项配置信息，以及环境变量。</p></li><li><p>jmap</p><p>Java内存映像工具，即将JVM的一块内存以二进制的形式dump成为文件，方便用其他内存分析工具进行分析。还有个骚操作，直接将目前JVM的状态完整保存成一个可运行的jar，可以直接从当前状态运行。</p></li><li><p>jhat</p><p>用来读取jmap dump出来的内存文件，或者设置了<code>-XX:+HeapDumpOnOutOfMemoryError</code>的虚拟机在内存溢出时自动dump出来的内存文件。他会启动一个web server，用户可以用浏览器查看分析结果。</p></li><li><p>jstack</p><p>java堆栈跟踪工具。能够将JVM线程栈的运行情况打印出来，包括线程基本信息如tid等，还包括其所处的状态比如Waiting、Runable等，以及其持有的锁信息等。在追踪线上服务某些线程长时间卡顿时非常好用。</p></li><li><p>jcmd</p><p>一个多功能的工具，其功能覆盖了上面介绍的好几个工具，比如它也能导出堆、查看Java进程、导出线程信息、执行GC、还可以进行采样分析。自JDK1.7引入。</p></li></ul><p>可视化工具包括：</p><ul><li><p>Jconsole</p><p>在命令行运行会启动一个GUI界面，显示一些统计数据。</p></li><li><p>VisualVM</p><p>一个支持插件的可视化JVM性能检测工具，是随JDK发布的功能最强大的debug工具，并且官方称之为<code>All-In-One</code>，可见官方对其寄予厚望。</p></li></ul><h4 id="获得heap-Dump的几种方式"><a href="#获得heap-Dump的几种方式" class="headerlink" title="获得heap Dump的几种方式"></a>获得heap Dump的几种方式</h4><p>上面可以看到，很多调试工具都是围绕JVM内存管理展开的，也确实，OOM是我们经常遇到又让人非常恼火的错误。因此我们先介绍一下获得heap dump的几种方式。</p><ul><li><p>使用jmap</p><p><code>jmap -dump:live,format=b,file=d:\dump\heap.hprof &lt;pid&gt;</code></p></li><li><p>使用jcmd</p><p><code>jcmd &lt;pid&gt; GC.heap_dump d:\dump\heap.hprof</code></p></li><li><p>使用JVM参数获取dump文件</p><ul><li><p>-XX:+HeapDumpOnOutOfMemoryError</p><p>OOM时导出内存镜像。可能是比较常用的debug参数了，因为毕竟一般不OOM，我们也不太关注内存使用情况。</p></li><li><p>-XX:+HeapDumpBeforeFullGC</p><p>每次Full GC之前导出内存镜像。在性能调优的情况下可能用的比较多。</p></li><li><p>-XX:+HeapDumpAfterFullGC</p><p>当 JVM 执行 FullGC 后执行 dump。</p></li><li><p>-XX:+HeapDumpOnCtrlBreak</p><p>交互式的操作，当按下ctrl+break时产生镜像。可能在debug时经常会用到吧。</p></li><li><p>-XX:HeapDumpPath=d:\test.hprof</p><p>指定内存dump文件的保存位置。</p></li></ul></li></ul><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><p>注：因为不同JDK版本的问题，以下命令的细节可能有些变化，每个命令都可以用–help参数查看帮助，具体的表现请以自己的版本为准。以下的输出基于<code>JDK 1.8_131</code>， <code>&gt; ~</code>表示命令行的输入。因为在macOS下，1.8更高版本的调试工具无法正常使用，会抛以下异常，查了一些资料好像是官方bug，暂时也没办法，降到131后正常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Attaching to process ID 1014, please wait...</span><br><span class="line">Error attaching to process: sun.jvm.hotspot.debugger.DebuggerException: Can&apos;t attach symbolicator to the process</span><br><span class="line">sun.jvm.hotspot.debugger.DebuggerException: sun.jvm.hotspot.debugger.DebuggerException: Can&apos;t attach symbolicator to the process</span><br><span class="line">at sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal$BsdDebuggerLocalWorkerThread.execute(BsdDebuggerLocal.java:169)</span><br><span class="line">at sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal.attach(BsdDebuggerLocal.java:287)</span><br><span class="line">at sun.jvm.hotspot.HotSpotAgent.attachDebugger(HotSpotAgent.java:671)</span><br><span class="line">at sun.jvm.hotspot.HotSpotAgent.setupDebuggerDarwin(HotSpotAgent.java:659)</span><br><span class="line">at sun.jvm.hotspot.HotSpotAgent.setupDebugger(HotSpotAgent.java:341)</span><br><span class="line">at sun.jvm.hotspot.HotSpotAgent.go(HotSpotAgent.java:304)</span><br><span class="line">at sun.jvm.hotspot.HotSpotAgent.attach(HotSpotAgent.java:140)</span><br><span class="line">at sun.jvm.hotspot.tools.Tool.start(Tool.java:185)</span><br><span class="line">at sun.jvm.hotspot.tools.Tool.execute(Tool.java:118)</span><br><span class="line">at sun.jvm.hotspot.tools.JInfo.main(JInfo.java:138)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at sun.tools.jinfo.JInfo.runTool(JInfo.java:108)</span><br><span class="line">at sun.tools.jinfo.JInfo.main(JInfo.java:76)</span><br><span class="line">Caused by: sun.jvm.hotspot.debugger.DebuggerException: Can&apos;t attach symbolicator to the process</span><br><span class="line">at sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal.attach0(Native Method)</span><br><span class="line">at sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal.access$100(BsdDebuggerLocal.java:65)</span><br><span class="line">at sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal$1AttachTask.doit(BsdDebuggerLocal.java:278)</span><br><span class="line">at sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal$BsdDebuggerLocalWorkerThread.run(BsdDebuggerLocal.java:144)</span><br></pre></td></tr></table></figure><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jps --help</span><br><span class="line">usage: jps [--help]</span><br><span class="line">       jps [-q] [-mlvV] [&lt;hostid&gt;]</span><br></pre></td></tr></table></figure><p>具体效果请自测。-l参数输出主类的全限定名；-m输出main method的参数；-v输出jvm参数；输出通过flag文件传递到JVM中的参数(.hotspotrc文件或-XX:Flags=所指定的文件；</p><h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><p><a href="https://www.jianshu.com/p/c321d0808a1b" target="_blank" rel="noopener">简书：jinfo命令详解</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jinfo --help</span><br><span class="line">Usage:</span><br><span class="line">    jinfo [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jinfo [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    -flag &lt;name&gt;         to print the value of the named VM flag</span><br><span class="line">    -flag [+|-]&lt;name&gt;    to enable or disable the named VM flag</span><br><span class="line">    -flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value</span><br><span class="line">    -flags               to print VM flags</span><br><span class="line">    -sysprops            to print Java system properties</span><br><span class="line">    &lt;no option&gt;          to print both of the above</span><br><span class="line">    -h | -help           to print this help message</span><br></pre></td></tr></table></figure><p>这个命令可以查看和修改JVM的一些参数。具体效果自己测试吧，会打印出来一大堆。</p><h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>这个主要是输出一些内存相关的统计数据。有很多子参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jstat --help</span><br><span class="line">Usage: jstat --help|-options</span><br><span class="line">       jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br><span class="line"></span><br><span class="line">Definitions:</span><br><span class="line">  &lt;option&gt;      An option reported by the -options option</span><br><span class="line">  &lt;vmid&gt;        Virtual Machine Identifier. A vmid takes the following form:</span><br><span class="line">                     &lt;lvmid&gt;[@&lt;hostname&gt;[:&lt;port&gt;]]</span><br><span class="line">                Where &lt;lvmid&gt; is the local vm identifier for the target</span><br><span class="line">                Java virtual machine, typically a process id; &lt;hostname&gt; is</span><br><span class="line">                the name of the host running the target Java virtual machine;</span><br><span class="line">                and &lt;port&gt; is the port number for the rmiregistry on the</span><br><span class="line">                target host. See the jvmstat documentation for a more complete</span><br><span class="line">                description of the Virtual Machine Identifier.</span><br><span class="line">  &lt;lines&gt;       Number of samples between header lines.</span><br><span class="line">  &lt;interval&gt;    Sampling interval. The following forms are allowed:</span><br><span class="line">                    &lt;n&gt;[&quot;ms&quot;|&quot;s&quot;]</span><br><span class="line">                Where &lt;n&gt; is an integer and the suffix specifies the units as</span><br><span class="line">                milliseconds(&quot;ms&quot;) or seconds(&quot;s&quot;). The default units are &quot;ms&quot;.</span><br><span class="line">  &lt;count&gt;       Number of samples to take before terminating.</span><br><span class="line">  -J&lt;flag&gt;      Pass &lt;flag&gt; directly to the runtime system.</span><br><span class="line">  -? -h --help  Prints this help message.</span><br><span class="line">  -help         Prints this help message.</span><br></pre></td></tr></table></figure><h5 id="class"><a href="#class" class="headerlink" title="-class"></a>-class</h5><p>显示加载class的数量，及所占空间等信息，效果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jstat -class 1758</span><br><span class="line">Loaded       Bytes    Unloaded     Bytes      Time</span><br><span class="line"> 15704     28719.1           1       0.9     10.09</span><br></pre></td></tr></table></figure><h5 id="compiler"><a href="#compiler" class="headerlink" title="-compiler"></a>-compiler</h5><p>显示VM实时编译的数量等信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jstat -compiler 1758</span><br><span class="line">Compiled Failed Invalid    Time   FailedType   FailedMethod</span><br><span class="line">    7957      0       0    29.31           0</span><br></pre></td></tr></table></figure><h5 id="gc"><a href="#gc" class="headerlink" title="-gc"></a>-gc</h5><p>显示gc的消息，包括gc的次数、时间等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jstat -gc 1758</span><br><span class="line">S0C       S1C    S0U      S1U       EC       EU       OC         OU       MC         MU       CCSC       CCSU    YGC     YGCT    FGC    FGCT    CGC       CGCT      GCT</span><br><span class="line">0.0   14336.0    0.0   14336.0 139264.0 129024.0  89088.0    21987.5   80000.0   78249.0   10880.0    10193.5     14    0.170      0   0.000      8      0.030    0.199</span><br></pre></td></tr></table></figure><ul><li>S0C:  survivor0 capacity（单位kb）</li><li>S0U: survivor0 used</li><li>S1C:  survivor1 capacity</li><li>S1U: survivor1 used</li><li>EC:  Eden capacity</li><li>EU: Eden used</li><li>OC: old capacity</li><li>OU: old used</li><li>MC: method capacity</li><li>MU: method used</li><li>CCSC: 压缩类空间大小</li><li>CCSU: 压缩类空间使用大小</li><li>YGC: 年轻带垃圾回收次数</li><li>YGCT: 年轻代垃圾回收耗时</li><li>FGC: Full GC 次数</li><li>FGCT: Full GC耗时</li><li>CGC: Concurrent GC次数</li><li>CGCT: Concurrent GC耗时</li><li>GCT: GC总耗时</li></ul><h5 id="gccapacity"><a href="#gccapacity" class="headerlink" title="-gccapacity"></a>-gccapacity</h5><p>堆内存统计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jstat -gccapacity 57889</span><br><span class="line">NGCMN       NGCMX       NGC     S0C      S1C         EC   OGCMN       OGCMX        OGC         OC       MCMN        MCMX       MC     CCSMN      CCSMX      CCSC     YGC    FGC   CGC</span><br><span class="line">  0.0   2097152.0   149504.0    0.0   12288.0  137216.0     0.0    2097152.0    88064.0    88064.0       0.0   1118208.0   80000.0      0.0   1048576.0  10880.0     15      0     8</span><br></pre></td></tr></table></figure><p>部分和-gc重复的输出就不解释了，看一下不同的输出：</p><ul><li>NGCMN        新生代最小容量（单位kb）</li><li>NGCMX         新生代最大容量</li><li>NGC              当前新生代容量</li><li>OGCMN        老年代最小容量</li><li>OGCMX         老年代最大容量</li><li>MCMN           方法区最小容量</li><li>MCMX            方法区最大容量</li><li>CCSMN          压缩区最小容量</li><li>CCSMX           压缩去最大容量</li></ul><h5 id="gccause"><a href="#gccause" class="headerlink" title="-gccause"></a>-gccause</h5><p>最近一次GC统计和原因</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jstat -gccause 57889</span><br><span class="line">  S0       S1        E       O      M       CCS    YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT      LGCC               GCC</span><br><span class="line">0.00   100.00    52.99   27.49   97.66    93.52     15    0.167     0    0.000     8    0.022    0.189 G1 Evacuation Pause  No GC</span><br></pre></td></tr></table></figure><p>其中的S0什么的，都是指使用了多少。</p><h5 id="gcmetacapacity"><a href="#gcmetacapacity" class="headerlink" title="-gcmetacapacity"></a>-gcmetacapacity</h5><p>metaSpace中对象的信息和占用量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jstat -gcmetacapacity 57889</span><br><span class="line">MCMN       MCMX        MC       CCSMN      CCSMX       CCSC     YGC   FGC    FGCT    CGC    CGCT     GCT</span><br><span class="line">  0.0  1118208.0    80000.0        0.0  1048576.0    10880.0    15     0    0.000     8    0.022    0.189</span><br></pre></td></tr></table></figure><h5 id="gcnew"><a href="#gcnew" class="headerlink" title="-gcnew"></a>-gcnew</h5><p>年轻代对象的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jstat -gcnew 57889</span><br><span class="line">S0C    S1C    S0U     S1U    TT  MTT     DSS        EC       EU    YGC   YGCT</span><br><span class="line">0.0 12288.0   0.0  12288.0    5   15   8704.0  137216.0  72704.0    15  0.167</span><br></pre></td></tr></table></figure><ul><li>TT       对象在新生代存活的次数（年龄）</li><li><p>MTT    对象在新生代存活的最大次数</p></li><li><p>DSS     幸存者区所需空间大小</p></li></ul><h5 id="gcnewcapacity"><a href="#gcnewcapacity" class="headerlink" title="-gcnewcapacity"></a>-gcnewcapacity</h5><p>年轻代容量信息，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jstat -gcnewcapacity 57889</span><br><span class="line">NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC   CGC</span><br><span class="line">  0.0  2097152.0   149504.0      0.0      0.0 2097152.0  12288.0  2097152.0   137216.0    15     0     8</span><br></pre></td></tr></table></figure><h5 id="gcold"><a href="#gcold" class="headerlink" title="-gcold"></a>-gcold</h5><p>老年代对象信息，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jstat -gcold 57889</span><br><span class="line">     MC       MU      CCSC     CCSU       OC          OU        YGC    FGC    FGCT    CGC    CGCT     GCT</span><br><span class="line">80000.0  78128.8    10880.0  10174.9     88064.0     24207.3     15     0    0.000     8    0.022    0.189</span><br></pre></td></tr></table></figure><h5 id="gcoldcapacity"><a href="#gcoldcapacity" class="headerlink" title="-gcoldcapacity"></a>-gcoldcapacity</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jstat -gcoldcapacity 57889</span><br><span class="line">OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT    CGC    CGCT     GCT</span><br><span class="line">  0.0   2097152.0     88064.0     88064.0    15     0     0.000     8    0.022    0.189</span><br></pre></td></tr></table></figure><h5 id="gcutil"><a href="#gcutil" class="headerlink" title="-gcutil"></a>-gcutil</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jstat -gcutil 57889</span><br><span class="line">  S0       S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT</span><br><span class="line">0.00   100.00  55.97  27.49  97.66  93.52     15    0.167     0    0.000     8    0.022    0.189</span><br></pre></td></tr></table></figure><p>输出了数据后怎么分析，还是看自己需求。比如说我看了我们一个线上JVM的服务，YGC总共一百多次，FGC竟然运行了一千多次，显然是哪里出了问题，内存分配策略有问题。</p><h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p>这个命令用于打印指定java进程或者核心文件中所有java线程当前时刻正在执行的方法堆栈追踪情况，也就是线程的snapshot，生成线程的快照主要用于定位线程长时间出现停顿的原因，如死锁、等待外部资源等。jstack在分析死锁，阻塞等性能问题上非常有用，根据打印的堆栈信息可以定位到出问题的代码段。定位问题的思路根据要解决的问题而发生不同，比如可以首先找到java进程中最耗cpu的线程，再根据线程id在jstack的输出中定位，或者使用指定的线程名称定位。</p><p>输出特别有意思，比如说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jstack -l 57889</span><br><span class="line">2019-08-08 17:20:10</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (11.0.4+10-LTS mixed mode):</span><br><span class="line"></span><br><span class="line">Threads class SMR info:</span><br><span class="line">_java_thread_list=0x00007fc141522820, length=31, elements=&#123;</span><br><span class="line">0x00007fc14288d800, 0x00007fc14202c000, 0x00007fc142028800, 0x00007fc142894000,</span><br><span class="line">0x00007fc142897000, 0x00007fc143020800, 0x00007fc141821000, 0x00007fc142903000,</span><br><span class="line">0x00007fc1462d9000, 0x00007fc1463a5800, 0x00007fc144071000, 0x00007fc1450e7800,</span><br><span class="line">0x00007fc144ef4800, 0x00007fc141d54800, 0x00007fc14379a800, 0x00007fc143551800,</span><br><span class="line">0x00007fc145134800, 0x00007fc141fd4000, 0x00007fc141deb000, 0x00007fc144270000,</span><br><span class="line">0x00007fc144164800, 0x00007fc141bde000, 0x00007fc144156000, 0x00007fc141c6f800,</span><br><span class="line">0x00007fc146422800, 0x00007fc14657d800, 0x00007fc1440ca000, 0x00007fc14453e000,</span><br><span class="line">0x00007fc1450e6800, 0x00007fc145f02000, 0x00007fc14552d800</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=31 cpu=6.75ms elapsed=6997.49s tid=0x00007fc14288d800 nid=0x3303 waiting on condition  [0x000070000dfc6000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">at java.lang.ref.Reference.waitForReferencePendingList(java.base@11.0.4/Native Method)</span><br><span class="line">at java.lang.ref.Reference.processPendingReferences(java.base@11.0.4/Reference.java:241)</span><br><span class="line">at java.lang.ref.Reference$ReferenceHandler.run(java.base@11.0.4/Reference.java:213)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">- None</span><br><span class="line"></span><br><span class="line">... // 以下省略</span><br></pre></td></tr></table></figure><p>之后的输出就类似于上面最后一段的输出，解读如下：</p><ul><li><p>“Reference Handler” :     线程名称</p></li><li><p>daemon:                           守护线程 </p></li><li><p>prio:                                   线程优先级</p></li><li><p>os_prio:                            系统的线程优先级</p></li><li>cpu:                                   占用的CPU时间</li><li>elapsed:                           启动多久了</li><li>tid:                                    jvm中的线程标识符</li><li>nid:                                   系统中的本地线程标识符</li><li>waiting on condition:     等待条件满足</li><li>[0x000070000dfc6000]  线程的起始地址</li></ul><p>下面显示的是函数调用栈和持有锁的情况。</p><p>比如说下面这段代码，就一定会造成线程Waiting卡死，注：<strong>这是错误的写法，代码里不要用。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        executorService.execute(() -&gt; </span><br><span class="line">            System.out.println(<span class="string">"hello, I'm "</span> + Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//没有这一行的话下面的awaitTermination会等超时，详情见awaitTermination的注释</span></span><br><span class="line">  <span class="comment">// executorService.shutdown();   </span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executorService.awaitTermination(<span class="number">10</span>, TimeUnit.DAYS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后进程就hang住了。jstack查看一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jstack 9527</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.191-b12 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;Attach Listener&quot; #17 daemon prio=9 os_prio=31 tid=0x00007fe5e8a0b000 nid=0x2907 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;pool-1-thread-5&quot; #16 prio=5 os_prio=31 tid=0x00007fe5e92ff800 nid=0x5703 waiting on condition [0x000070000887a000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to wait for  &lt;0x0000000795c2d4b0&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">// 之后省略</span><br></pre></td></tr></table></figure><p>可以看到，线程池里面的线程处于等待之中，并且是在ThreadPoolExecutor中等待，等待的原因是从LinkedBlockingQueue中take时hang住了。首先我们从线程名中获得了等待线程的名字，知道他是线程池里面的线程，于是就缩小了出错的范围。然后又知道是线程池试图去取任务时发生了等待，那为什么线程池还要去取任务呢？因为我们没有shutdown()线程池。</p><p>再举个几乎必然会死锁的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    executorService.execute(<span class="keyword">new</span> DeadLock(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    executorService.execute(<span class="keyword">new</span> DeadLock(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executorService.awaitTermination(<span class="number">10</span>, TimeUnit.DAYS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> a, b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeadLock</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">200</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (Integer.valueOf(a)) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Integer.valueOf(b)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"我来了，又走了2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>Integer.valueof(a)</code>在a比较小时会使用缓存，因此实际上加锁的对象都是同一个对象。所以以上代码几乎必然发生死锁。jstack结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jstack 9527</span><br><span class="line">// 前半部分忽略。只看最后</span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;pool-1-thread-2&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007fb7173f0758 (object 0x00000007955c0430, a java.lang.Integer),</span><br><span class="line">  which is held by &quot;pool-1-thread-1&quot;</span><br><span class="line">&quot;pool-1-thread-1&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007fb7173f0808 (object 0x00000007955c0440, a java.lang.Integer),</span><br><span class="line">  which is held by &quot;pool-1-thread-2&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;pool-1-thread-2&quot;:</span><br><span class="line">at com.richinfoai.umbrella.pipeline.publicFacility.utlis.Pair.lambda$main$1(Pair.java:43)</span><br><span class="line">- waiting to lock &lt;0x00000007955c0430&gt; (a java.lang.Integer)</span><br><span class="line">- locked &lt;0x00000007955c0440&gt; (a java.lang.Integer)</span><br><span class="line">at com.richinfoai.umbrella.pipeline.publicFacility.utlis.Pair$$Lambda$2/2110121908.run(Unknown Source)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;pool-1-thread-1&quot;:</span><br><span class="line">at com.richinfoai.umbrella.pipeline.publicFacility.utlis.Pair.lambda$main$0(Pair.java:27)</span><br><span class="line">- waiting to lock &lt;0x00000007955c0440&gt; (a java.lang.Integer)</span><br><span class="line">- locked &lt;0x00000007955c0430&gt; (a java.lang.Integer)</span><br><span class="line">at com.richinfoai.umbrella.pipeline.publicFacility.utlis.Pair$$Lambda$1/204349222.run(Unknown Source)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure><p>下面再举个例子，线程执行时间很长的情况。（linux下模拟的，因为macOS下我竟然找了一下午都没有找到一个能显示线程ID和线程使用CPU状况的命令，linux下的<code>top -H 、ps -eLf</code>macOS下通通不支持。）测试机器状态如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ cat /proc/version</span><br><span class="line">Linux version <span class="number">3.10</span><span class="number">.0</span>-<span class="number">957</span>.el7.x86_64 (mockbuild<span class="meta">@kbuilder</span>.bsys.centos.org) </span><br><span class="line">  (gcc version 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC) ) #1 </span><br><span class="line">    SMP Thu Nov <span class="number">8</span> <span class="number">23</span>:<span class="number">39</span>:<span class="number">32</span> UTC <span class="number">2018</span></span><br></pre></td></tr></table></figure><p>我们在java中开个线程，运行一个无限循环。</p><p>代码很简单:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfinityLoop</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    System.out.println(i++);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们搞到测试机上跑起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ java -cp . InfinityLoop &gt; output.txt &amp;</span><br><span class="line">&gt; ~ jps</span><br><span class="line">14889 InfinityLoop</span><br><span class="line">&gt; ~ jstack 14889</span><br><span class="line">// 前后省略没用的输出</span><br><span class="line">&quot;main&quot; #1 prio=5 os_prio=0 tid=0x00007fe510009000 nid=0x3a2a runnable [0x00007fe519804000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">at java.io.FileOutputStream.writeBytes(Native Method)</span><br><span class="line">at java.io.FileOutputStream.write(FileOutputStream.java:326)</span><br><span class="line">at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:82)</span><br><span class="line">at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:140)</span><br><span class="line">- locked &lt;0x0000000080214020&gt; (a java.io.BufferedOutputStream)</span><br><span class="line">at java.io.PrintStream.write(PrintStream.java:482)</span><br><span class="line">- locked &lt;0x0000000080214000&gt; (a java.io.PrintStream)</span><br><span class="line">at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221)</span><br><span class="line">at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:291)</span><br><span class="line">at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:104)</span><br><span class="line">- locked &lt;0x0000000080214140&gt; (a java.io.OutputStreamWriter)</span><br><span class="line">at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:185)</span><br><span class="line">at java.io.PrintStream.write(PrintStream.java:527)</span><br><span class="line">- locked &lt;0x0000000080214000&gt; (a java.io.PrintStream)</span><br><span class="line">at java.io.PrintStream.print(PrintStream.java:597)</span><br><span class="line">at java.io.PrintStream.println(PrintStream.java:736)</span><br><span class="line">- locked &lt;0x0000000080214000&gt; (a java.io.PrintStream)</span><br><span class="line">at InfinityLoop.main(InfinityLoop.java:7)</span><br></pre></td></tr></table></figure><p>其nid即linux本地线程id为<code>0x3a2a</code>，转化为十进制为<code>14890</code>，我们继续排查。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ ps -mp 14889 -o THREAD,tid,time</span><br><span class="line">USER     %CPU PRI SCNT WCHAN  USER SYSTEM   TID     TIME</span><br><span class="line">root     99.8   -    - -         -      -     - 00:02:27</span><br><span class="line">root      0.0  19    - futex_    -      - 14889 00:00:00</span><br><span class="line">root     99.3  19    - -         -      - 14890 00:02:27</span><br><span class="line">root      0.0  19    - futex_    -      - 14891 00:00:00</span><br><span class="line">root      0.0  19    - futex_    -      - 14892 00:00:00</span><br><span class="line">root      0.0  19    - futex_    -      - 14893 00:00:00</span><br><span class="line">// 省略其他输出</span><br></pre></td></tr></table></figure><p>可见这个线程疯狂占内存了。当然，这也是我们期待的结果咯。一般排查的话应该是反过来，先ps看哪个线程耗资源比较大，然后去jstack查看具体的java线程，看其线程栈到底在做什么。</p><p>最后放一个Spring web请求的stack，实际任务只有一个，就是调用Spring Repository JPA保存一个entity，其线程栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">&quot;http-nio-8080-exec-1&quot; #30 daemon prio=5 os_prio=31 tid=0x00007fb2a94c3000 nid=0x5c03 runnable [0x0000700009cae000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">    at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">    at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)</span><br><span class="line">    at java.net.SocketInputStream.read(SocketInputStream.java:171)</span><br><span class="line">    at java.net.SocketInputStream.read(SocketInputStream.java:141)</span><br><span class="line">    at com.mysql.cj.protocol.ReadAheadInputStream.fill(ReadAheadInputStream.java:107)</span><br><span class="line">    at com.mysql.cj.protocol.ReadAheadInputStream.readFromUnderlyingStreamIfNecessary(ReadAheadInputStream.java:150)</span><br><span class="line">    at com.mysql.cj.protocol.ReadAheadInputStream.read(ReadAheadInputStream.java:180)</span><br><span class="line">    - locked &lt;0x0000000740afa5e0&gt; (a com.mysql.cj.protocol.ReadAheadInputStream)</span><br><span class="line">    at java.io.FilterInputStream.read(FilterInputStream.java:133)</span><br><span class="line">    at com.mysql.cj.protocol.FullReadInputStream.readFully(FullReadInputStream.java:64)</span><br><span class="line">    at com.mysql.cj.protocol.a.SimplePacketReader.readHeader(SimplePacketReader.java:63)</span><br><span class="line">    at com.mysql.cj.protocol.a.SimplePacketReader.readHeader(SimplePacketReader.java:45)</span><br><span class="line">    at com.mysql.cj.protocol.a.TimeTrackingPacketReader.readHeader(TimeTrackingPacketReader.java:52)</span><br><span class="line">    at com.mysql.cj.protocol.a.TimeTrackingPacketReader.readHeader(TimeTrackingPacketReader.java:41)</span><br><span class="line">    at com.mysql.cj.protocol.a.MultiPacketReader.readHeader(MultiPacketReader.java:54)</span><br><span class="line">    at com.mysql.cj.protocol.a.MultiPacketReader.readHeader(MultiPacketReader.java:44)</span><br><span class="line">    at com.mysql.cj.protocol.a.NativeProtocol.readMessage(NativeProtocol.java:549)</span><br><span class="line">    at com.mysql.cj.protocol.a.NativeProtocol.checkErrorMessage(NativeProtocol.java:725)</span><br><span class="line">    at com.mysql.cj.protocol.a.NativeProtocol.sendCommand(NativeProtocol.java:664)</span><br><span class="line">    at com.mysql.cj.protocol.a.NativeProtocol.sendQueryPacket(NativeProtocol.java:979)</span><br><span class="line">    at com.mysql.cj.protocol.a.NativeProtocol.sendQueryString(NativeProtocol.java:914)</span><br><span class="line">    at com.mysql.cj.NativeSession.execSQL(NativeSession.java:1150)</span><br><span class="line">    at com.mysql.cj.jdbc.ConnectionImpl.setAutoCommit(ConnectionImpl.java:2064)</span><br><span class="line">    - locked &lt;0x0000000740a6e9e8&gt; (a com.mysql.cj.jdbc.ConnectionImpl)</span><br><span class="line">    at com.zaxxer.hikari.pool.ProxyConnection.setAutoCommit(ProxyConnection.java:388)</span><br><span class="line">    at com.zaxxer.hikari.pool.HikariProxyConnection.setAutoCommit(HikariProxyConnection.java)</span><br><span class="line">    at org.hibernate.resource.jdbc.internal.AbstractLogicalConnectionImplementor.begin(AbstractLogicalConnectionImplementor.java:67)</span><br><span class="line">    at org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.begin(LogicalConnectionManagedImpl.java:263)</span><br><span class="line">    at org.hibernate.resource.transaction.backend.jdbc.internal.JdbcResourceLocalTransactionCoordinatorImpl$TransactionDriverControlImpl.begin(JdbcResourceLocalTransactionCoordinatorImpl.java:236)</span><br><span class="line">    at org.hibernate.engine.transaction.internal.TransactionImpl.begin(TransactionImpl.java:80)</span><br><span class="line">    at org.springframework.orm.jpa.vendor.HibernateJpaDialect.beginTransaction(HibernateJpaDialect.java:183)</span><br><span class="line">    at org.springframework.orm.jpa.JpaTransactionManager.doBegin(JpaTransactionManager.java:401)</span><br><span class="line">    at org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:378)</span><br><span class="line">    at org.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:474)</span><br><span class="line">    at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:289)</span><br><span class="line">    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:98)</span><br><span class="line">    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)</span><br><span class="line">    at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:139)</span><br><span class="line">    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)</span><br><span class="line">    at org.springframework.data.jpa.repository.support.CrudMethodMetadataPostProcessor$CrudMethodMetadataPopulatingMethodInterceptor.invoke(CrudMethodMetadataPostProcessor.java:135)</span><br><span class="line">    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)</span><br><span class="line">    at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:93)</span><br><span class="line">    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)</span><br><span class="line">    at org.springframework.data.repository.core.support.SurroundingTransactionDetectorMethodInterceptor.invoke(SurroundingTransactionDetectorMethodInterceptor.java:61)</span><br><span class="line">    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)</span><br><span class="line">    at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:212)</span><br><span class="line">    at com.sun.proxy.$Proxy79.save(Unknown Source)</span><br><span class="line">    at com.lifeStory.study.test.TestThreadLongTimeRun.longTimeRun(TestThreadLongTimeRun.java:20)</span><br><span class="line">    at com.lifeStory.study.controller.TestController.testThreadRunTooLong(TestController.java:26)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">    at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">    at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:189)</span><br><span class="line">    at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)</span><br><span class="line">    at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:102)</span><br><span class="line">    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895)</span><br><span class="line">    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:800)</span><br><span class="line">    at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)</span><br><span class="line">    at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1038)</span><br><span class="line">    at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942)</span><br><span class="line">    at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005)</span><br><span class="line">    at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:897)</span><br><span class="line">    at javax.servlet.http.HttpServlet.service(HttpServlet.java:634)</span><br><span class="line">    at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882)</span><br><span class="line">    at javax.servlet.http.HttpServlet.service(HttpServlet.java:741)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">    at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">    at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)</span><br><span class="line">    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">    at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92)</span><br><span class="line">    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">    at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93)</span><br><span class="line">    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">    at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200)</span><br><span class="line">    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199)</span><br><span class="line">    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)</span><br><span class="line">    at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490)</span><br><span class="line">    at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139)</span><br><span class="line">    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)</span><br><span class="line">    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)</span><br><span class="line">    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)</span><br><span class="line">    at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408)</span><br><span class="line">    at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)</span><br><span class="line">    at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:834)</span><br><span class="line">    at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1417)</span><br><span class="line">    at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)</span><br><span class="line">    - locked &lt;0x00000007a2ba9450&gt; (a org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">    at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure><p>在没有异常的情况下看看线程栈，也是个很爽的事情不是。</p><h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jmap -h</span><br><span class="line">Usage:</span><br><span class="line">    jmap [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jmap [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    &lt;none&gt;               to print same info as Solaris pmap</span><br><span class="line">    -heap                to print java heap summary</span><br><span class="line">    -histo[:live]        to print histogram of java object heap; if the &quot;live&quot;</span><br><span class="line">                         suboption is specified, only count live objects</span><br><span class="line">    -clstats             to print class loader statistics</span><br><span class="line">    -finalizerinfo       to print information on objects awaiting finalization</span><br><span class="line">    -dump:&lt;dump-options&gt; to dump java heap in hprof binary format</span><br><span class="line">                         dump-options:</span><br><span class="line">                           live         dump only live objects; if not specified,</span><br><span class="line">                                        all objects in the heap are dumped.</span><br><span class="line">                           format=b     binary format</span><br><span class="line">                           file=&lt;file&gt;  dump heap to &lt;file&gt;</span><br><span class="line">                         Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</span><br><span class="line">    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo</span><br><span class="line">                         to force a heap dump or histogram when &lt;pid&gt; does not</span><br><span class="line">                         respond. The &quot;live&quot; suboption is not supported</span><br><span class="line">                         in this mode.</span><br><span class="line">    -h | -help           to print this help message</span><br><span class="line">    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</span><br></pre></td></tr></table></figure><p>前面讲的几个dump内存的方法，其中一个就是jmap导出。那么具体怎么操作呢？</p><p>我们启动一个Spring Boot服务，试用一下jmap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jmap -heap 9527</span><br><span class="line">Attaching to process ID 9527, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.131-b11</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.// 使用了Thread Local Allocation Buffer</span><br><span class="line">Parallel GC with 4 thread(s)</span><br><span class="line">// JDK1.8 默认-XX:+UseParallelGC，即Parallel Scavenge + Parallel Old</span><br><span class="line">// 可以用jinfo pid或者java -XX:+PrintCommandLineFlags -version查看</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 0</span><br><span class="line">   MaxHeapFreeRatio         = 100</span><br><span class="line">   MaxHeapSize              = 2147483648 (2048.0MB)</span><br><span class="line">   NewSize                  = 44564480 (42.5MB)</span><br><span class="line">   MaxNewSize               = 715653120 (682.5MB)</span><br><span class="line">   OldSize                  = 89653248 (85.5MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)// 启动了G1垃圾收集器后会大有不同</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 187695104 (179.0MB)</span><br><span class="line">   used     = 43869272 (41.836997985839844MB)</span><br><span class="line">   free     = 143825832 (137.16300201416016MB)</span><br><span class="line">   23.372624573094885% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 14680064 (14.0MB)</span><br><span class="line">   used     = 14670504 (13.990882873535156MB)</span><br><span class="line">   free     = 9560 (0.00911712646484375MB)</span><br><span class="line">   99.93487766810826% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 18350080 (17.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 18350080 (17.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 90701824 (86.5MB)</span><br><span class="line">   used     = 24615232 (23.47491455078125MB)</span><br><span class="line">   free     = 66086592 (63.02508544921875MB)</span><br><span class="line">   27.138629538475435% used</span><br><span class="line"></span><br><span class="line">22509 interned Strings occupying 2756384 bytes.// 字符串常量池占比</span><br></pre></td></tr></table></figure><p>在启用了G1的JVM上这个输出结果有一定变化，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jmap -heap 91204</span><br><span class="line">Attaching to process ID 91204, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.131-b11</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Garbage-First (G1) GC with 4 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 40</span><br><span class="line">   MaxHeapFreeRatio         = 70</span><br><span class="line">   MaxHeapSize              = 2147483648 (2048.0MB)</span><br><span class="line">   NewSize                  = 1363144 (1.2999954223632812MB)</span><br><span class="line">   MaxNewSize               = 1287651328 (1228.0MB)</span><br><span class="line">   OldSize                  = 5452592 (5.1999969482421875MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 1048576 (1.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">G1 Heap:</span><br><span class="line">   regions  = 2048</span><br><span class="line">   capacity = 2147483648 (2048.0MB)</span><br><span class="line">   used     = 40702448 (38.81687927246094MB)</span><br><span class="line">   free     = 2106781200 (2009.183120727539MB)</span><br><span class="line">   1.8953554332256317% used</span><br><span class="line">G1 Young Generation:</span><br><span class="line">Eden Space:</span><br><span class="line">   regions  = 5// 也可以看出Eden区是按需将region标记为eden的</span><br><span class="line">   capacity = 73400320 (70.0MB)</span><br><span class="line">   used     = 5242880 (5.0MB)</span><br><span class="line">   free     = 68157440 (65.0MB)</span><br><span class="line">   7.142857142857143% used</span><br><span class="line">Survivor Space:</span><br><span class="line">   regions  = 10// 所以eden的region竟然比</span><br><span class="line">   capacity = 10485760 (10.0MB)</span><br><span class="line">   used     = 10485760 (10.0MB)</span><br><span class="line">   free     = 0 (0.0MB)</span><br><span class="line">   100.0% used</span><br><span class="line">G1 Old Generation:</span><br><span class="line">   regions  = 24</span><br><span class="line">   capacity = 50331648 (48.0MB)</span><br><span class="line">   used     = 24973808 (23.816879272460938MB)</span><br><span class="line">   free     = 25357840 (24.183120727539062MB)</span><br><span class="line">   49.61849848429362% used</span><br><span class="line"></span><br><span class="line">22611 interned Strings occupying 2766112 bytes.</span><br></pre></td></tr></table></figure><p>具体含义就不解释了。</p><p>第二个命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jmap -histo:live 91204 | less</span><br><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:         59859        8873752  [C</span><br><span class="line">   2:         18168        1598784  java.lang.reflect.Method</span><br><span class="line">   3:         58970        1415280  java.lang.String</span><br><span class="line">   4:         11160        1235200  java.lang.Class</span><br><span class="line">   5:         26752         856064  java.util.concurrent.ConcurrentHashMap$Node</span><br><span class="line">   6:          2739         628944  [B</span><br><span class="line">   7:         10297         586104  [Ljava.lang.Object;</span><br><span class="line">   8:         15701         502432  java.util.HashMap$Node</span><br><span class="line">   9:          5064         436984  [Ljava.util.HashMap$Node;</span><br><span class="line">  10:         19116         424272  [Ljava.lang.Class;</span><br></pre></td></tr></table></figure><p>感觉很爽是不是，哈哈。不加live会把已死亡对象也输出出来，格式是一样的。就不赘述了。</p><p>然后来试一下保存内存镜像的命令。我们来写个非常简单的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlowInfinityLoop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;ABC&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ABC());</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ABC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = UUID.randomUUID().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时加参数<code>-Xms20m -Xmx20m</code>，起来后这么操作一番：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jps</span><br><span class="line">24402</span><br><span class="line">24778 Launcher</span><br><span class="line">24780 Jps</span><br><span class="line"></span><br><span class="line">&gt; ~ jmap -heap 24794</span><br><span class="line">Attaching to process ID 24794, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.131-b11</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 8 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 0</span><br><span class="line">   MaxHeapFreeRatio         = 100</span><br><span class="line">   MaxHeapSize              = 20971520 (20.0MB)</span><br><span class="line">   NewSize                  = 6815744 (6.5MB)</span><br><span class="line">   MaxNewSize               = 6815744 (6.5MB)</span><br><span class="line">   OldSize                  = 14155776 (13.5MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 5767168 (5.5MB)</span><br><span class="line">   used     = 2119584 (2.021392822265625MB)</span><br><span class="line">   free     = 3647584 (3.478607177734375MB)</span><br><span class="line">   36.75259676846591% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 524288 (0.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 524288 (0.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 524288 (0.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 524288 (0.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 14155776 (13.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 14155776 (13.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line"></span><br><span class="line">2485 interned Strings occupying 181464 bytes.</span><br><span class="line"></span><br><span class="line">&gt; ~ jmap -dump:live,format=b,file=Desktop/heap.bin 24794// 相对路径</span><br><span class="line">Dumping heap to ~/Desktop/heap.bin ...</span><br><span class="line">Heap dump file created</span><br><span class="line"></span><br><span class="line">&gt; ~ jhat ~/Desktop/heap.bin</span><br><span class="line">Reading from ~/Desktop/heap.bin...</span><br><span class="line">Dump file created Sat Aug 17 17:40:52 CST 2019</span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving 15335 objects...</span><br><span class="line">Chasing references, expect 3 dots...</span><br><span class="line">Eliminating duplicate references...</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7000</span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure><h4 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h4><p>dump内存我们已经玩得可以了，接下来就是如何分析内存里有什么。jhat是个非常方便的工具，能够用来分析内存dump文件里的对象信息。我们就以上例中的<code>heap.bin</code>文件为例进行分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jhat -h</span><br><span class="line">Usage:  jhat [-stack &lt;bool&gt;] [-refs &lt;bool&gt;] [-port &lt;port&gt;] [-baseline &lt;file&gt;] [-debug &lt;int&gt;] [-version] [-h|-help] &lt;file&gt;</span><br><span class="line"></span><br><span class="line">-J&lt;flag&gt;          Pass &lt;flag&gt; directly to the runtime system. For</span><br><span class="line">  example, -J-mx512m to use a maximum heap size of 512MB</span><br><span class="line">-stack false:     Turn off tracking object allocation call stack.</span><br><span class="line">-refs false:      Turn off tracking of references to objects</span><br><span class="line">-port &lt;port&gt;:     Set the port for the HTTP server.  Defaults to 7000</span><br><span class="line">-exclude &lt;file&gt;:  Specify a file that lists data members that should</span><br><span class="line">  be excluded from the reachableFrom query.</span><br><span class="line">-baseline &lt;file&gt;: Specify a baseline object dump.  Objects in</span><br><span class="line">  both heap dumps with the same ID and same class will</span><br><span class="line">  be marked as not being &quot;new&quot;.</span><br><span class="line">-debug &lt;int&gt;:     Set debug level.</span><br><span class="line">    0:  No debug output</span><br><span class="line">    1:  Debug hprof file parsing</span><br><span class="line">    2:  Debug hprof file parsing, no server</span><br><span class="line">-version          Report version number</span><br><span class="line">-h|-help          Print this help and exit</span><br><span class="line">&lt;file&gt;            The file to read</span><br><span class="line"></span><br><span class="line">For a dump file that contains multiple heap dumps,</span><br><span class="line">you may specify which dump in the file</span><br><span class="line">by appending &quot;#&lt;number&gt;&quot; to the file name, i.e. &quot;foo.hprof#3&quot;.</span><br><span class="line"></span><br><span class="line">All boolean options default to &quot;true&quot;</span><br></pre></td></tr></table></figure><p>设置项很多，感觉比较有用的是<code>-execlude</code>和<code>-bashline</code>，其他的暂时没看出有多少用。</p><p>随便跑一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jhat ~/Desktop/heap.bin</span><br><span class="line">Reading from /Users/mateng/Desktop/heap.bin...</span><br><span class="line">Dump file created Sat Aug 17 17:40:52 CST 2019</span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving 15335 objects...</span><br><span class="line">Chasing references, expect 3 dots...</span><br><span class="line">Eliminating duplicate references...</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7000</span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure><p>登陆<code>localhost:7000</code>，如下：</p><p><img src="https://www.history-of-my-life.com/imgs-for-md/JVM-jhat-20190818.jpg" alt="JVM-jhat-20190818.jpg"></p><p>然后我们点击我们想观察的<code>ABC</code>这个类：</p><p>输出中大部分自己看一看含义就好，然后我们使劲往下翻。找到</p><blockquote><h2 id="Other-Queries"><a href="#Other-Queries" class="headerlink" title="Other Queries"></a>Other Queries</h2><p>Reference Chains from Rootset</p><ul><li><a href="http://localhost:7000/roots/0x7bec73328" target="_blank" rel="noopener">Exclude weak refs</a></li><li><a href="http://localhost:7000/allRoots/0x7bec73328" target="_blank" rel="noopener">Include weak refs</a></li></ul><p><a href="http://localhost:7000/reachableFrom/0x7bec73328" target="_blank" rel="noopener">Objects reachable from here</a></p></blockquote><p>点Exclude weak refs，然后再往下翻，找到下面这一块。</p><p>可以看到不同的线程对于这个类的实例的持有状况。</p><p><img src="https://www.history-of-my-life.com/imgs-for-md/JVM-jhat-local-references-20190818.png" alt="JVM-jhat-local-references-20190818.png"></p><p>可以确认第一个线程是main线程（直接点线程的超链就能看到线程的详细信息，其中有name）。那我们现在就不管了，我们可以看清楚，就是一个ArrayList持有了ABC的实例。这个比较好的就是能查看引用链条，方便看是哪里发生了内存泄露。</p><p>然后我们再回到最开始的页面，点<code>Show instance counts for all classes (excluding platform)</code>这个链接，可以看到下面的显示。</p><blockquote><p>Instance Counts for All Classes (excluding platform)</p><p>752 <code>instances</code> of class <code>com.lifeStory.study.ABC</code><br>0 <code>instances</code> of class <code>com.lifeStory.study.SlowInfinityLoop</code></p></blockquote><p>这个在排查OOM时还比较有用，比如说我们一个线上项目OOM后dump出来的文件显示结果如下：</p><p><img src="https://www.history-of-my-life.com/imgs-for-md/JVM-jhat-OOM-20190818.png" alt="JVM-jhat-OOM-20190818.png"></p><p>其中实例最多的都是fuseki的库，实际上这些对象我们只用了一小会，之后都不用了，但没有释放，显然是代码中相关作用域出问题了。修改之就可以了。</p><p>另外提示一下，分析堆的dump文件很耗内存，而且很耗时。上面这个文件，16G的堆文件，jhat在一台服务器上执行，吃了顿饭回来还等了一小会才分析完毕。</p><h4 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h4><p>照例来一发help</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&gt; ~ jvisualvm -h</span><br><span class="line">Usage: /Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/visualvm/platform/lib/nbexec &#123;options&#125; arguments</span><br><span class="line"></span><br><span class="line">General options:</span><br><span class="line">  --help                show this help</span><br><span class="line">  --jdkhome &lt;path&gt;      path to Java(TM) 2 SDK, Standard Edition</span><br><span class="line">  -J&lt;jvm_option&gt;        pass &lt;jvm_option&gt; to JVM</span><br><span class="line"></span><br><span class="line">  --cp:p &lt;classpath&gt;    prepend &lt;classpath&gt; to classpath</span><br><span class="line">  --cp:a &lt;classpath&gt;    append &lt;classpath&gt; to classpath</span><br><span class="line">Module reload options:</span><br><span class="line">  --reload /path/to/module.jar  install or reinstall a module JAR file</span><br><span class="line"></span><br><span class="line">其他模块选项:</span><br><span class="line">  --modules</span><br><span class="line">  --refresh                 刷新所有目录</span><br><span class="line">  --list                    打印所有模块, 模块版本和启用状态的列表</span><br><span class="line">  --install &lt;arg1&gt;...&lt;argN&gt; 将提供的 JAR 文件作为模块安装</span><br><span class="line">  --disable &lt;arg1&gt;...&lt;argN&gt; 禁用指定代码库名称的模块</span><br><span class="line">  --enable &lt;arg1&gt;...&lt;argN&gt;  启用指定代码库名称的模块</span><br><span class="line">  --update &lt;arg1&gt;...&lt;argN&gt;  更新所有模块或指定的模块</span><br><span class="line">  --update-all              更新所有模块</span><br><span class="line">  --extra-uc &lt;arg&gt;          添加额外的更新中心 (URL)</span><br><span class="line">  --openfile &lt;arg&gt;          打开由 &lt;arg&gt; 指定的文件，该文件可能是应用程序快照、NetBeans Profiler 快照或 HPROF 堆 dump。</span><br><span class="line">  --openjmx &lt;arg&gt;           打开 JMX 连接 (主机:端口) 指定的应用程序</span><br><span class="line">  --openpid &lt;arg&gt;           打开进程 id 为 &lt;arg&gt; 的应用程序</span><br><span class="line">  --openid &lt;arg&gt;            打开 id 为 &lt;arg&gt; 的应用程序</span><br><span class="line"></span><br><span class="line">Core options:</span><br><span class="line">  --laf &lt;LaF classname&gt; use given LookAndFeel class instead of the default</span><br><span class="line">  --fontsize &lt;size&gt;     set the base font size of the user interface, in points</span><br><span class="line">  --locale &lt;language[:country[:variant]]&gt; use specified locale</span><br><span class="line">  --userdir &lt;path&gt;      use specified directory to store user settings</span><br><span class="line">  --cachedir &lt;path&gt;     use specified directory to store user cache, must be different from userdir</span><br><span class="line">  --nosplash            do not show the splash screen</span><br></pre></td></tr></table></figure><p>因为visualVM是插件化的，装一堆插件上去会有很多功能。但暂时没有时间研究，就用最基本的就好了，最基本的用法在这里，注意这个应该是基于JDK1.8以下的版本：</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html" target="_blank" rel="noopener">使用 VisualVM 进行性能分析及调优</a>，看起来也不不难，基础知识上面已经有了。</p><h3 id="学会看GC日志"><a href="#学会看GC日志" class="headerlink" title="学会看GC日志"></a>学会看GC日志</h3><p>不同的垃圾收集器输出的日志不是完全一样的，但基本格式都差不太多，可以使用<code>-XX:+PrintGCDetails</code>参数来打开JVM的GC日志（堆内存上下限都设为20m），比如上面的<code>SlowInfinityLoop</code>，打开日志后输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 5632K-&gt;496K(6144K)] 5632K-&gt;956K(19968K), 0.0029640 secs] [Times: user=0.01 sys=0.01, real=0.00 secs] </span><br><span class="line"><span class="meta">#</span><span class="bash"> 省略28行基本一致的输出，Full GC是第29行</span></span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 480K-&gt;0K(4608K)] [ParOldGen: 13214K-&gt;11473K(13824K)] 13694K-&gt;11473K(18432K), [Metaspace: 8059K-&gt;8038K(1056768K)], 0.0417188 secs] [Times: user=0.23 sys=0.00, real=0.04 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 3072K-&gt;384K(4608K)] 14545K-&gt;11857K(18432K), 0.0012428 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </span><br><span class="line"><span class="meta">#</span><span class="bash"> 6次类似的输出，下面的Full GC是第36行</span></span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 448K-&gt;0K(5632K)] [ParOldGen: 13297K-&gt;13533K(13824K)] 13745K-&gt;13533K(19456K), [Metaspace: 8038K-&gt;8038K(1056768K)], 0.0230733 secs] [Times: user=0.17 sys=0.00, real=0.02 secs] </span><br><span class="line"><span class="meta">#</span><span class="bash"> 之后全部都是Full GC，总共到1864行，而且越到后来速度FullGC的间隔时间越短</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面这一次Full GC直接是eden区不够引起的，但是已经没可回收的内存了</span></span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 4096K-&gt;4096K(5632K)] [ParOldGen: 13823K-&gt;13823K(13824K)] 17919K-&gt;17919K(19456K), [Metaspace: 8038K-&gt;8038K(1056768K)], 0.0250757 secs] [Times: user=0.16 sys=0.00, real=0.02 secs] </span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时已经OOM了，跳出了循环，再进行了一次Full GC，可以看到堆内存基本被清空了。</span></span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 4096K-&gt;0K(5632K)] [ParOldGen: 13823K-&gt;1364K(13824K)] 17919K-&gt;1364K(19456K), [Metaspace: 8038K-&gt;8038K(1056768K)], 0.0087641 secs] [Times: user=0.04 sys=0.00, real=0.01 secs] </span><br><span class="line"><span class="meta">#</span><span class="bash"> 打出了堆信息</span></span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 5632K, used 185K [0x00000007bf980000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">  eden space 4096K, 4% used [0x00000007bf980000,0x00000007bf9ae638,0x00000007bfd80000)</span><br><span class="line">  from space 1536K, 0% used [0x00000007bfe80000,0x00000007bfe80000,0x00000007c0000000)</span><br><span class="line">  to   space 1024K, 0% used [0x00000007bfd80000,0x00000007bfd80000,0x00000007bfe80000)</span><br><span class="line"> ParOldGen       total 13824K, used 1364K [0x00000007bec00000, 0x00000007bf980000, 0x00000007bf980000)</span><br><span class="line">  object space 13824K, 9% used [0x00000007bec00000,0x00000007bed551d0,0x00000007bf980000)</span><br><span class="line"> Metaspace       used 8051K, capacity 8188K, committed 8448K, reserved 1056768K</span><br><span class="line">  class space    used 939K, capacity 984K, committed 1024K, reserved 1048576K</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打出了异常栈信息</span></span><br><span class="line">Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.util.Arrays.copyOf(Arrays.java:3332)</span><br><span class="line">at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)</span><br><span class="line">at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448)</span><br><span class="line">at java.lang.StringBuilder.append(StringBuilder.java:136)</span><br><span class="line">at java.util.UUID.toString(UUID.java:380)</span><br><span class="line">at com.lifeStory.study.ABC.&lt;init&gt;(SlowInfinityLoop.java:21)</span><br><span class="line">at com.lifeStory.study.SlowInfinityLoop.main(SlowInfinityLoop.java:13)</span><br></pre></td></tr></table></figure><p>以上面为例，GC的日志一般是这样的：</p><p>先输出这次是YGC还是FGC，之后输出GC发生的原因，之后输出此次GC所使用的垃圾收集器以及GC后内存的变化情况，之后输出这次GC消耗的时间。比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 5632K-&gt;496K(6144K)] 5632K-&gt;956K(19968K), 0.0029640 secs] [Times: user=0.01 sys=0.01, real=0.00 secs]</span><br></pre></td></tr></table></figure><p>GC指这次发生了<code>Young GC</code>，<code>Allocation Failure</code>指的是Eden区内存不够分配对象了，<code>PSYoungGen</code>是指使用的是<code>Parallel Svavenge</code>垃圾收集器，</p><p><code>PSYoungGen: 5632K-&gt;496K(6144K)</code>是指这次被回收的区前后内存的变化，格式是：<code>回收前内存-&gt;回收后内存(该区域总内存)</code></p><p>方括号外面的<code>5632K-&gt;956K(19968K)</code>是指，回收前堆内存、回收后堆内存，堆总内存。</p><p>之后消耗的时间。</p><p>我们这个进程运行起来后，用visualVM观察堆使用状况，如下图：</p><p><img src="https://www.history-of-my-life.com/imgs-for-md/JVM-visualVM-heapusage-loop-20190818.png" alt="JVM-visualVM-heapusage-loop-20190818.png"></p><p>有意思的是，明明我们这个代码看起来没什么可回收的了，就是一直在add，从没释放过什么东西，为啥这个还回收了这么多东西呢？另外，最后曲线趋向于平缓，又是什么阶段？</p><p>首先我们来看一下内存的详细情况：</p><p><img src="https://www.history-of-my-life.com/imgs-for-md/JVM-visualVM-heapDetails-loop-20190818.png" alt="JVM-visualVM-heapDetails-loop-20190818.png"></p><p>如果从进程一开始就盯着的话，会发现这个char[]一直在变来变去，每次GC他都少一大截。如果仔细追踪代码，会发现是UUID包内部使用的一个玩意。</p><p>至于最后的平稳阶段，是因为内存真的退无可退了，一直在疯狂FGC。</p><h3 id="题外话：OOM可以被catch"><a href="#题外话：OOM可以被catch" class="headerlink" title="题外话：OOM可以被catch"></a>题外话：OOM可以被catch</h3><p>只是没什么好的理由的话，为什么要catch Error？</p><h2 id="JVM与Container"><a href="#JVM与Container" class="headerlink" title="JVM与Container"></a>JVM与Container</h2><h3 id="内存到底怎么回事"><a href="#内存到底怎么回事" class="headerlink" title="内存到底怎么回事"></a>内存到底怎么回事</h3><p>之前在分析我们的一些业务代码时发现了一个小问题，那就是运行在docker容器里的JVM似乎并不能感知到K8S对于硬件资源的限制，因此在未手动指定堆大小的时候，默认会使用物理机的1/4作为堆的最大内存，1/64作为堆的初始化内存，这显然不是我们要的效果。</p><p>那么这个问题怎么解决，参考以下这两篇文章：</p><p><a href="https://medium.com/adorsys/jvm-memory-settings-in-a-container-environment-64b0840e1d9e" target="_blank" rel="noopener">JVM Memory Settings in a Container Environment</a></p><p><a href="https://merikan.com/2019/04/jvm-in-a-container/" target="_blank" rel="noopener">JVM in a Container</a></p><p>大概的解释就是，在JDK1.8_131以后，JVM增加了一个实验特性，可以感知container的硬件限制了，一般来说，需要做以下设置：<code>-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap -XX:MaxRAMFraction=2</code>，三个参数同时上。但这仍然存在很大的资源浪费，会浪费一半的container内存，内存越大浪费越严重。</p><p>在JDK1.8_131之前，或者在JDK1.8_131之后但不愿意浪费一半内存的，可以使用Docker的EntryPoint特性，构造一个这样的EntryPoint</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> -XX:MaxRAM to 70% of the cgroup <span class="built_in">limit</span></span></span><br><span class="line">docker run --rm -m 1g openjdk:8-jdk </span><br><span class="line">sh -c 'exec java -XX:MaxRAM=$(( $(cat /sys/fs/cgroup/memory/memory.limit_in_bytes) * 100 / 70 )) -XX:+PrintFlagsFinal -version'</span><br></pre></td></tr></table></figure><p>实际是手动读取了容器对硬件资源的限制，之后自己做了一个设置。</p><p>而在更高级别的JDK（实测JDK1.8_191即可，更低版本未测试），则可以使用以下参数：</p><p><code>-XX:+UseContainerSupport -XX:MaxRAMPercentage=70.00</code>，就能设置JVM使用container70%的内存。</p><p>下面我们用docker测一下，首先为了控制版本，我们先吧openjdk的tag打出来，虽然docker本身没有提供搜索tag的功能，但是官方给出了一个小脚本，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i=0</span><br><span class="line"></span><br><span class="line">while [ $? == 0 ]</span><br><span class="line">do</span><br><span class="line">   i=$((i+1))</span><br><span class="line">   curl https://registry.hub.docker.com/v2/repositories/library/$1/tags/?page=$i 2&gt;/dev/null|jq '."results"[]["name"]'</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>运行一下，要等很久才能输出所有结果，总共有2482行，查看一下，然后运行其中一个选定的版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 测试一下 131</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不加相关参数，可见堆内存并没有受到300M的限制，至于为啥是444.5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 是因为mac下的docker Desktop自己限制了自己用2G内存，而java默认用1/4</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ~  docker run --rm -it -m 300M openjdk:8u131-alpine java -XshowSettings:vm -version</span></span><br><span class="line">VM settings:</span><br><span class="line">    Max. Heap Size (Estimated): 444.50M</span><br><span class="line">// 之后还有部分输出省略，下同。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一种方式</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ~ docker run --rm -it -m 300M openjdk:8u131-alpine java -XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap -XX:MaxRAMFraction=2 -XshowSettings:vm -version</span></span><br><span class="line">VM settings:</span><br><span class="line">    Max. Heap Size (Estimated): 133.50M</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 131不支持UseContainerSupport参数</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ~ docker run --rm -it -m 300M openjdk:8u131-alpine java -XX:+UseContainerSupport -XX:MaxRAMPercentage=70.00 -XshowSettings:vm -version</span></span><br><span class="line">Unrecognized VM option 'UseContainerSupport'</span><br><span class="line">Error: Could not create the Java Virtual Machine.</span><br><span class="line">Error: A fatal exception has occurred. Program will exit.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试一下181</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 什么都不加</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ~ docker run --rm -it openjdk:8u181-alpine java -XshowSettings:vm -version</span></span><br><span class="line">VM settings:</span><br><span class="line">    Max. Heap Size (Estimated): 444.50M</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加上内存限制，可见似乎181已经可以自己感知container内存大小了，但并不是1/4，看起来是有最小值</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ~ docker run --rm -it -m 300M openjdk:8u181-alpine java -XshowSettings:vm -version</span></span><br><span class="line">VM settings:</span><br><span class="line">    Max. Heap Size (Estimated): 121.81M</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加上实验特性，还是会接受设置，确实用了1/2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ~ docker run --rm -it -m 300M openjdk:8u181-alpine java -XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap -XX:MaxRAMFraction=2 -XshowSettings:vm -version</span></span><br><span class="line">VM settings:</span><br><span class="line">    Max. Heap Size (Estimated): 145.00M</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 确实用了70%</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ~ docker run --rm -it -m 300M openjdk:8u181-alpine java -XX:+UseContainerSupport -XX:MaxRAMPercentage=70.00 -XshowSettings:vm -version</span></span><br><span class="line">VM settings:</span><br><span class="line">    Max. Heap Size (Estimated): 203.00M</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span><span class="bash"> 191效果与181完全相同</span></span><br></pre></td></tr></table></figure><h3 id="版本到底怎么回事"><a href="#版本到底怎么回事" class="headerlink" title="版本到底怎么回事"></a>版本到底怎么回事</h3><p>看docker openjdk的tag，茫茫多，总共2482个，而且很多tag看起来非常接近：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;8-alpine3.9&quot;</span><br><span class="line">&quot;8-alpine&quot;</span><br><span class="line">&quot;8-alpine3.8&quot;</span><br><span class="line">&quot;8u181-jre&quot;</span><br><span class="line">&quot;8u181&quot;</span><br><span class="line">&quot;8u181-jdk&quot;</span><br><span class="line">&quot;8u181-jdk-alpine&quot;</span><br><span class="line">&quot;8u181-jre-alpine&quot;</span><br><span class="line">&quot;8u181-jre-alpine3.8&quot;</span><br><span class="line">&quot;8u181-jdk-alpine3.8&quot;</span><br></pre></td></tr></table></figure><p>以上只展示了8的一小部分，看起来其命名基本上是<code>大版本号[小版本号]-[jdk|jre]-baseos[版本]</code></p><p>如果不指定小版本号，那么会使用最新的镜像，显然是会不断变化的，于是我们没法精确控制这个版本，虽然说相同的大版本应该向后兼容，但是保持开发环境和部署环境的一致还是非常重要的，因此最好明确指定版本号，比如<code>8u131</code>这样的。</p><p>而jdk和jre的区别，是jre只有java runtime环境，体积会比JDK小一点，但是jmap这样的调试工具就一概没有了。个人认为还是JDK+精确版本控制比较好。</p><p>至于baseOS，一般能用alpine就用他，因为非常精简，能控制镜像体积。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM调试工具使用简介&quot;&gt;&lt;a href=&quot;#JVM调试工具使用简介&quot; class=&quot;headerlink&quot; title=&quot;JVM调试工具使用简介&quot;&gt;&lt;/a&gt;JVM调试工具使用简介&lt;/h1&gt;&lt;p&gt;JVM调试工具是解决线上问题的重要方法。一些常见的线上问题比如说运行</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>从进程的角度再探Java内存</title>
    <link href="http://yoursite.com/2020/04/27/%E4%BB%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%A7%92%E5%BA%A6%E5%86%8D%E6%8E%A2Java%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/2020/04/27/%E4%BB%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%A7%92%E5%BA%A6%E5%86%8D%E6%8E%A2Java%E5%86%85%E5%AD%98/</id>
    <published>2020-04-27T06:00:13.000Z</published>
    <updated>2021-04-22T04:43:17.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从进程的角度再探Java内存"><a href="#从进程的角度再探Java内存" class="headerlink" title="从进程的角度再探Java内存"></a>从进程的角度再探Java内存</h1><p><code>Java</code>的内存模型大家都很熟悉了，比如运行时内存分为：线程栈、本地方法栈、程序计数器、方法区、运行时常量池、堆、本地内存。堆又进一步分为新生代、老年代，新生代又进一步分为eden区和两个survivor区，方法区在JDK1.7之前的hotspot虚拟机的实现中用的是永生代这个概念，但在JDK1.8以后挪到了本地内存空间中去，其他的虚拟机实现比如JRocket一直没有永生代这个概念。</p><p>但同样广为人知的是，Java虚拟机不过是操作系统的一个进程而已。在操作系统看来，这个进程和其他进程并没有什么本质的区别。假设这个虚拟机当前运行在Linux系统中，那么经典的内存分页、交换空间、虚拟内存空间模型，是不是应该还是适用于这个虚拟机。</p><p>于是引发了很多思考：</p><ol><li><p>经典的Linux进程的内存模型，也有堆和栈的概念，这里的堆和栈，和Java运行时内存空间的堆和栈是什么关系？Java运行时内存中的<code>本地内存</code>，到底又和Linux经典内存模型中的哪一部分对应？</p></li><li><p>一个Java进程，能不能申请比物理内存更大的堆空间？如果能，他实际占用的物理内存是多大？</p></li><li><p>Java有OOM错误，操作系统也有OOM错误，这两者之间有什么关系？两者在导致进程死亡上到底有哪些不同？</p></li><li><p>如果再引入一个变量：docker，则问题就更有意思一点。docker daemon只是操作系统的一个进程这个毫无疑问，但是每一个启动起来的container，在操作系统看来又是以什么形态存在的呢？在docker中运行的JVM到底能使用多大的内存，能不能利用经典Linux内存模型中的换页机制？如果超出了docker的内存限制，这时候JVM进程到底是被谁杀死？是docker daemon、操作系统，还是JVM主动停止。</p><p>对这个问题我们可以设想一个场景，在一个物理内存为16G的机器上，启动了一个内存限制为2G的docker，JVM的堆大小能不能设置成3G？假如能，是不是真的能申请到3G内存？假如不能，这个docker里运行的JVM最大能使用多大的堆？超出了会触发谁的OOM机制？</p></li></ol><p>往往是复杂的问题让人兴奋，抽丝剥茧，看到纷繁表象下奔腾在电路板上的二进制洪流。那一刻的光芒，是蔷薇园里最好的一滴晨露，是草原上金线勾勒的鬓角，是中庭下樱花一点的绛唇，是一个程序员的高光时刻。</p><h2 id="经典的Linux内存模型简介"><a href="#经典的Linux内存模型简介" class="headerlink" title="经典的Linux内存模型简介"></a>经典的Linux内存模型简介</h2><h3 id="运行时内存的几个部分"><a href="#运行时内存的几个部分" class="headerlink" title="运行时内存的几个部分"></a>运行时内存的几个部分</h3><p>翻开《程序员的自我修养》这本书第三章：可执行文件的装载与进程。其中讲到：</p><p>进程的<strong>虚拟内存空间</strong>中有部分留作操作系统使用，在32位的linux系统上，一般是虚拟内存空间中最高的那1G空间，而用户只能使用3G空间。而这3G空间中，又主要分为这么几块空间：</p><ul><li>代码段。就是我们的代码编译成本机可执行文件后的那个东西，也就是我们平时编译后得到的那个文件，在运行时装载到代码段。</li><li>数据段。这就是我们代码里的一些常量数据。比如说在代码里写<code>std:string a = &quot;hello world!&quot;</code>，这个字符串就是个常量数据，不会保存到代码段，而是放到数据段。</li><li>堆空间。这个堆是Linux进程内存模型中的堆，要注意区分和<code>Java</code>运行时内存模型中的堆不是一个概念，虽然他们的功能是非常接近的，就是为进程在运行时动态分配的对象提供内存空间。</li><li><p>栈空间。这个栈也是Linux进程内存模型中的栈，要注意区分和<code>JVM</code>内存模型中的线程栈、本地线程栈也不是完全一样，虽然他们的功能也是非常接近的，就是为进程提供一个运行栈。</p></li><li><p>其实细究起来还有很多其他的段，但和我们的讨论相关性很低，就先不管了。</p></li></ul><h3 id="换页机制与swap空间"><a href="#换页机制与swap空间" class="headerlink" title="换页机制与swap空间"></a>换页机制与swap空间</h3><p>只讲结果不探讨原理和为什么。</p><p>现代计算机系统中，每个进程看到的内存都是从0开始的，完整、连续、平坦的一块空间。在32位的linux系统中，一般每个进程都会认为自己有4G内存可以使用。进程看到的内存称之为虚拟内存，而显然这样的虚拟内存和物理内存的地址不可能是一一对应的。所以，实际上无论是物理内存还是虚拟内存，都被分为一些固定大小的页面（一般4k一个页面），内核空间中保存一个虚拟内存页到物理内存页的映射关系。因此不同进程看到的同样地址的虚拟内存，可以被映射到不同地址的物理内存中去。</p><p>实际上，内存管理的方式更加聪明一些，比如说虽然进程能看到4G的空间，但是他并不一定真的会用那么多，实际上很多进程就使用一点点内存。于是当这些虚拟内存没用到的时候，操作系统连虚拟内存到物理内存的映射关系都不会建立，只有当实际用到时才建立。</p><p>那么假如真的有一些进程就是比较占用空间，一直在申请新的内存，确实用到了很大的内存空间，这样的两三个进程，实际用到的内存空间就会超过物理内存，这时候操作系统可以将一些暂时不用的物理内存页的内容写到文件系统里面去（windows下的虚拟内存，注意区分这个虚拟内存和我们刚才讨论的虚拟内存不是一个概念，linux下的交换空间），保证当前的进程仍然可以运行。这个<strong>暂时不用</strong>，我个人的理解是严格来讲只要当前CPU执行的指令用不到的内存地址，理论上都算是暂时不用，都可以交换到文件系统里面去。</p><p>这样做的好处是允许系统中运行的进程能够<strong>实际使用</strong>超过物理内存的内存。这里的<strong>实际使用</strong>是指，假如说从进程的角度观察，自己可用的内存空间一直是4G，那么N个进程看到的虚拟空间地址就是$$4*N$$，肯定远远超过物理内存大小了。但他看到的这些内存空间并不一定实际使用，只有它确实在堆空间中申请了一大堆数据，这样才叫<strong>实际使用</strong>，这样的话，一个进程可能使用100M，另一个使用10M，这样很多个进程，也<strong>未必能实际使用超过物理内存的内存</strong>，在这种情况下，操作系统<strong>就不必须</strong>把物理内存交换到文件系统里去了（实际上并不是只有物理内存耗尽才交换过去，在物理内存耗尽之前，就有可能交换一部分物理内存到交换空间，原因见：<a href="https://blog.51cto.com/wutengfei/2163283" target="_blank" rel="noopener">Linux交换空间</a>）。</p><p>因此，即使进程实际使用的内存超过物理内存，现代操作系统也能够使用交换空间来满足需求。唯一的问题是，在文件系统进行IO是很慢的操作，和在内存里做操作慢了好几个数量级，因此应当尽量避免发生这种事情。</p><p>操作系统设置的交换空间也不是无限的，虽然可以设置地大一点，但肯定不可能无限制地设置。而一旦交换空间  +  物理内存仍不足以满足多个进程的<strong>实际使用</strong>时，就会出现操作系统级别的OOM。</p><p>发生了这种OOM错误以后，操作系统就会开始对现有的进程进行扫描，计算出一个<code>badness</code>评分，然后将评分高的一个或几个进程直接杀掉。操作系统的这个机制称为<code>OOM Killer</code>。这个评分的计算大概参考了以下几个维度：</p><ul><li>子进程内存消耗，越多越容易被选中</li><li>CPU密集型以及老进程，比刚启动的进程更不容易被选中</li><li>root启动的进程更不容易被选中</li><li>用户可以通过控制<code>oom_adj</code>来控制进程选中优先级（范围是-17到15，值越高越容易被杀掉，值为-17时禁止该进程被杀掉）</li></ul><h2 id="Linux运行时内存和Java运行时内存的对应关系"><a href="#Linux运行时内存和Java运行时内存的对应关系" class="headerlink" title="Linux运行时内存和Java运行时内存的对应关系"></a>Linux运行时内存和Java运行时内存的对应关系</h2><h3 id="JVM进程的堆，与Java内存模型的堆"><a href="#JVM进程的堆，与Java内存模型的堆" class="headerlink" title="JVM进程的堆，与Java内存模型的堆"></a>JVM进程的堆，与Java内存模型的堆</h3><p>最常用的<code>JVM</code>之一：OpenJDK，本身是用<code>cpp</code>写的。当该虚拟机运行起来以后，就成为操作系统的一个进程，和其他的操作系统进程相比，这个进程并没有什么特别之处。因此，从整体上观察，一个<code>JVM</code>进程的内存模型就是下面这样子：</p><p><img src="https://www.history-of-my-life.com/imgs-for-md/JVM-and-Linux-memory-20190901-01.jpg" alt="JVM与内存模型"></p><p>其中代码区，放的是<code>jvm</code>虚拟机的代码，数据区，放的是<code>jvm</code>虚拟机的常量数据，堆区，用来放<code>jvm</code>虚拟机申请的实例，这个装载过程是由操作系统进行的，当<code>JVM</code>虚拟机运行起来以后，虚拟机才开始进行我们熟悉的<code>JVM</code>内存的初始化。所以，当考虑到<code>JVM</code>的运行时内存状况时，一个<code>JVM</code>进程的内存是这样的：</p><p><img src="https://www.history-of-my-life.com/imgs-for-md/JVM-and-Linux-memory-20190901-02.jpg" alt="JVM与内存模型"></p><p>这个图是网上找的图，出处见参考部分，只有<code>1.7</code>及以前版本的<code>Hotspot</code>才有永久代，其他的虚拟机实现，以及<code>1.8</code>及以后的<code>Hotspot</code>虚拟机实现，都不再有永久代这个概念。不过既然已经有了这张图，我们先以这个图为例来讨论<code>JVM</code>的内存模型。</p><p>首先，永久代装的是JVM的方法区和运行时常量区。看起来，方法区刚好对应了传统linux内存模型中的代码区，而运行时常量池则对应了数据区。</p><p>其次，新生代、老年代装的是JVM在运行时为用户代码新建的对象。那么新生代 + 老年代，就对应了linux内存模型中的堆区了。</p><p>然后，栈本来就是按需建立的，所以JVM中的栈和linux模型中的栈基本完全对应。</p><p>可见，我们所熟悉的JVM内存，除程序计数器和栈以外，都建立在<code>JVM</code>这个进程的<code>堆空间</code>，这是显而易见的事情，因为所有的这些东西，都是<code>JVM</code>这个进程在运行时新建出来的对象。而<code>Java</code>内存模型中的<code>堆</code>空间，则是<code>JVM</code>虚拟机所建立的一段逻辑空间。</p><p>就像操作系统为每个进程建立了一个逻辑堆空间一样，<code>JVM</code>虚拟机为运行在其上的<code>java</code>代码建立了一个逻辑堆空间，所谓的永久代、新生代、老年代，都是一些数据结构所对应的逻辑空间而已。</p><p>这个问题想明白了，简直是醍醐灌顶，豁然开朗。</p><p>以前的永久代，是<code>jvm</code>这个进程在它的堆空间上分配的一段内存，它维护了这段逻辑内存与自己的进程的虚拟内存对应的一个数据结构，（没看源码的我盲猜）这个数据结构可能包含了起始地址、结束地址、最大可用空间大小等等，在<code>JVM</code>装载<code>java</code>字节码时，会将<code>class</code>文件的内容、运行时常量池放在这个部分。以前的永久代最大空间在<code>JVM</code>运行时就确定了，默认是<code>64M</code>，可以通过<code>-XX:MaxPermSize</code>来指定，当其超过了大小时，就会发生永久代溢出错误，这也是（java）的OOM错误的一种，是<code>JVM</code>主动的行为。</p><p>那么用元空间替代了永久代，并不是说元空间不受<code>JVM</code>这个进程的管控了，只是说<code>JVM</code>对其管理的方式不再像以前的永久代、或者堆那样管理罢了。对堆的管理可能还维护了一个可用空间、起始虚拟内存地址、结束内存地址等，但对于元空间，这部分数据结构可以不用维护了，直接在<code>JVM</code>进程的堆里面申请就完了，要是申请大了，甚至超过了物理机的内存，也没关系啊，操作系统给换页，只要不超过<code>物理内存+swap</code>的总大小就完了，因为<code>swap</code>空间一般还挺大的，一般不至于发生（操作系统级别的）OOM，但一旦因为这个部分的使用发生OOM，那就是操作系统的OOM，会导致操作系统随机杀进程。</p><p>所以说，所谓的用元空间代替永久代，并不是说某一块内存发生了什么神奇的变化，只是在管理这一块内存的时候，采用了一些新的概念模型，如此而已。</p><h3 id="第一个问题的答案"><a href="#第一个问题的答案" class="headerlink" title="第一个问题的答案"></a>第一个问题的答案</h3><p><strong>经典的Linux进程的内存模型，也有堆和栈的概念，这里的堆和栈，和Java运行时内存空间的堆和栈是什么关系？Java运行时内存中的<code>本地内存</code>，到底又和Linux经典内存模型中的哪一部分对应？</strong></p><p>Java内存模型中的本地内存、堆，其实都是分配在<code>Linux</code>经典内存模型中的<code>堆</code>中。</p><p>什么是<code>native memory</code>，翻译成本地内存、直接内存都可以。所谓的本地内存，就是<code>JVM</code>进程所使用的内存。其实我个人理解本地内存就是操作系统分配给<code>JVM</code>进程的内存，那自然从地址空间来讲，包含了java内存模型中的堆在内。只是我们在讨论时，为了理解的方便，经常将java内存模型中的堆从本地内存这个概念中独立出来。那么本地内存的作用就是：</p><ul><li><p>管理java heap的状态数据（用于GC）;</p></li><li><p>JNI调用，也就是Native Stack；</p></li><li><p>JIT（即使编译器）编译时使用Native Memory，并且JIT的输入（Java字节码）和输出（可执行代码）也都是保存在Native Memory；</p></li><li><p>NIO direct buffer；</p></li><li><p>Threads；</p></li><li><p>类加载器和类信息都是保存在Native Memory中的。</p></li></ul><h3 id="第二个问题的答案"><a href="#第二个问题的答案" class="headerlink" title="第二个问题的答案"></a>第二个问题的答案</h3><p><strong>一个Java进程，能不能申请比物理内存更大的堆空间？如果能，他实际占用的物理内存是多大？</strong></p><p>那是自然可以的咯，申请大了没关系，大不了内存换页啊。到底占据多大的物理内存空间，这得看<code>JVM</code>到底是怎么初始化堆的，实际上还真有不同的初始化方式：</p><ul><li><p>在默认情况下，<code>JVM</code>也只是建立了一个有关于java堆的数据结构，java堆的那一块内存并不会去初始化。意思是，对于操作系统来说，<code>JVM</code>这个进程并没有<strong>实际使用</strong>那些内存，因此操作系统也不会给这部分内存真的分配物理地址。于是，实际上这个<code>JVM</code>耗费的物理内存只有一点点，就是<code>JVM</code>本身用到的一些内存，以及java代码使用的那些内存，这两个部分。</p><p>这种方式在大部分情况下是很好的，因为毕竟不是所有人都会主动去设置java堆的大小，而是依赖于java的默认设置（堆最小是1/64物理内存，最大1/4物理内存），而且即使设置了java堆的大小，也未必真的会用那么多。如果每个JVM启动时都把java堆内存的部分初始化一下，占用物理内存，何止是没必要，简直就是浪费，甚至可能导致操作系统内存吃紧发生问题，此外，初始化那么大一块内存，也很费时间。</p><p>但也有一些不好，考虑一个用java实现的数据库或搜索类服务器，比如说ES，这样的一个服务肯定是你给我多少内存，我恨不得都吃掉，至少可以做缓存啊对不对，最好是启动时我就占很大一块，启动速度可以慢一点，启动后运行速度一定是越快越好。而这样的一些服务一般也是独立部署在服务器上，整台服务器资源基本上都是给他用的，也不太需要顾及其他进程的感受。那这时候，在启动时直接让<code>jvm</code>初始化java堆，这样就能避免在运行时触发缺页异常，保证启动后的速度。</p></li><li><p>于是，<code>JVM</code>实际上有个参数做这个事情，<code>-XX:+AlwaysPreTouch</code>，将会在java堆空间中写满0，这样就可以实现初始化的目的了。避免在实际使用到堆空间时再触发缺页异常，影响运行时的效率。</p></li></ul><p>能申请比物理内存更大的堆空间，不代表这么做是对的。一般的进程里，即使用到了比物理内存更大的内存，但其热点内存区域仍然只有一小部分，也就是说，至少频繁用到的内存页仍然可以只有一小部分，因此可以长期装载在物理内存中，不会频繁引起缺页异常导致数据在物理内存和swap之间换入换出，所以运行效率还尚可。但是<code>JVM</code>由于内存回收机制的存在，在<code>gc</code>过程中，需要扫描很大一块内存，假如堆内存大于物理内存，将会导致疯狂换页，这效率一般就低到尘埃里面去了，甚至会拖垮整个服务，所以，我们尽量不要设置大于物理内存的堆内存，而且还要考虑到内存中还有部分是给内核空间用的、给其他关键进程比如<code>sshd</code>用的，因此一般应该使用比物理空间小一些的堆内存空间。</p><h3 id="第三个问题的答案"><a href="#第三个问题的答案" class="headerlink" title="第三个问题的答案"></a>第三个问题的答案</h3><p><strong>Java有OOM错误，操作系统也有OOM错误，这两者之间有什么关系？两者在导致进程死亡上到底有哪些不同？</strong></p><p>Java的OOM错误，是因为java堆空间已经满了，而且经过了GC仍不足以分配内存空间，这时候<code>JVM</code>会抛出一个<code>OutOfMemoryError</code>，这个错误属于java异常体系的一部分，继承自<code>Throwable</code>，可以用如下方式被捕获：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oomMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do some stupid thing to cause OOM</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError e)&#123;</span><br><span class="line">      <span class="comment">// do something to recover, but you really need a good reason to catch </span></span><br><span class="line">      <span class="comment">// an OOM error.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Boot在引入web依赖时，就会帮我们catch这个Error，从而我们的服务可以发生OOM，打出异常栈之后，该服务还能继续接受和处理其他请求。</p><p>但操作系统的OOM，是因为所有运行在该操作系统下的进程所<strong>实际使用</strong>的内存，超出了物理内存和交换空间之和，此时操作系统会根据一些参数计算出一个score，然后把score最大的一个或几个进程直接杀掉，一般就是占用内存最大的那个，（也就是我们的主服务了），这个过程可以人为干预，但仍然有一定的随机性。</p><p>所以，java的OOM是自己检测到无法运行进程了需要退出，是个主动的行为，因此也可以catch后中止这个退出行为；而操作系统的OOM杀进程对于JVM来说，是一个被动的行为，一旦被操作系统选中，作为一个普通进程的jvm将没有任何办法，只能被干掉。</p><p>举一个现实中可能会遇到的情况，我们的线上服务在发生OOM时，有时候会在日志中打出一个OOM的异常栈，然后服务还是启动状态，仍然能接受下一次请求；而在有些情况下，k8s的container会直接重启，查看重启原因会发现是<code>OOM Killed</code>，这就是操作系统的<code>OOM</code>杀了，而因为我们的容器里实际上只运行了<code>JVM</code>，其他进程并不占内存，所以我们可以大胆猜测，是运行时的<code>JVM</code>申请了太多的本地内存，最终导致实际使用的内存超过了物理内存和交换空间之和导致OOM杀，那本地内存在<code>JVM</code>中到底怎么申请的呢？一般会大量使用本地内存、而且在运行前不好估计使用量的，就是NIO框架，以及Spring大量使用的反射机制，所以，调低堆大小，给本地内存留出更大的空间，理论上可以解决这个问题。</p><h2 id="终章：与Docker的战斗"><a href="#终章：与Docker的战斗" class="headerlink" title="终章：与Docker的战斗"></a>终章：与Docker的战斗</h2><h3 id="docker中的进程，也只是一个进程"><a href="#docker中的进程，也只是一个进程" class="headerlink" title="docker中的进程，也只是一个进程"></a>docker中的进程，也只是一个进程</h3><p>想直观地观察到上面的结论，没法用windows或者mac下的docker desktop来观察，因为docker只能运行在linux内核上，所以windows或者mac下docker desktop本质上是个虚拟机。实际上可以理解为，在windows和mac下运行了一个虚拟机，又在虚拟机中运行着docker，因为多了这层虚拟机，所以会干扰我们理解问题。于是我首先在mac上安装一个centOS 7.2的虚拟机，然后在虚拟机上安装docker，在虚拟机上观察。过程不赘。</p><p>我们在虚拟机中运行一个mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ~ docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=password mysql:5.7</span></span><br><span class="line">4a679a362f02fe513bc66b10f1308e42ba99500f1a12ff18587c8eb1435baae0</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ~ docker ps</span></span><br><span class="line">CONTAINER ID    IMAGE        COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class="line">4a679a362f02    mysql:5.7    "docker-entrypoint.s…"   5 seconds ago       Up 4 seconds        0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   awesome_hugle</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ~ docker top 4a679a362f02</span></span><br><span class="line">UID       PID     PPID     C  STIME   TTY    TIME        CMD</span><br><span class="line">polkitd   12230   12213    0  11:55   ?      00:00:00    mysqld</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ~ ps aux | grep 12230<span class="comment"># 第一行是我专门粘贴出来的</span></span></span><br><span class="line">USER     PID    %CPU %MEM    VSZ   RSS   TTY    STAT   START   TIME  COMMAND</span><br><span class="line">polkitd  12230  0.3 10.3 1136228 193620  ?      Ssl    11:55   0:00  mysqld</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面是解释为什么USER是这么诡异的一个值</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参考https://blog.dbi-services.com/how-uid-mapping-works-in-docker-containers/</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ~ docker <span class="built_in">exec</span> -it 4a679a362f02 id mysql</span></span><br><span class="line">uid=999(mysql) gid=999(mysql) groups=999(mysql)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ~ id 999</span></span><br><span class="line">uid=999(polkitd) gid=998(polkitd) 组=998(polkitd)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可见容器里uid为999的用户是mysql，对应着容器外的polkitd，哈哈，虽然知道</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个冷知识看起来没有多大用，但是有疑惑还是顺手查一查比较安心</span></span><br></pre></td></tr></table></figure><p>所以，我们可以看到，运行在容器中的mysql对于操作系统来说也是一个进程而已。（在mac下观察不到这个进程，是因为mac的docker还运行了一层虚拟机）</p><h3 id="真的没有特别之处吗？"><a href="#真的没有特别之处吗？" class="headerlink" title="真的没有特别之处吗？"></a>真的没有特别之处吗？</h3><p>从理论上讲是有一些。docker通过linux的nameSpace技术实现了容器之间的资源隔离，并且使用linux的Cgroup技术，限制了容器中的进程所能使用的硬件资源。所以对于每一个运行在容器中的进程来说，他只能看到容器允许他看到的文件系统、使用容器为他单独维护的网络环境，这是一个完整的、完全独立于宿主机和其他容器的文件系统、网络环境，并且，最多只能使用Cgroup限制的硬件资源，包括CPU资源和内存资源。</p><p>因为我们在这里讨论的是硬件资源的限制，所以我们主要来了解一下CGroups。这篇文章讲得非常透彻：<a href="https://www.infoq.cn/article/docker-kernel-knowledge-cgroups-resource-isolation" target="_blank" rel="noopener">Docker 背后的内核知识——cgroups 资源限制</a>，这篇文章我也没看完，但已经足够解答我们之前提到的问题了。在这里补充一点，查看当前容器的<code>Cgroup</code>限制，可以去以下目录看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ~ docker run --rm -it -m 20m ubuntu ls /sys/fs/cgroup/memory/</span></span><br><span class="line">cgroup.clone_children    memory.memsw.failcnt</span><br><span class="line">cgroup.event_control    memory.memsw.limit_in_bytes</span><br><span class="line">cgroup.procs    memory.memsw.max_usage_in_bytes</span><br><span class="line">memory.failcnt    memory.memsw.usage_in_bytes</span><br><span class="line">memory.force_empty    memory.move_charge_at_immigrate</span><br><span class="line">memory.kmem.failcnt    memory.numa_stat</span><br><span class="line">memory.kmem.limit_in_bytes    memory.oom_control</span><br><span class="line">memory.kmem.max_usage_in_bytes    memory.pressure_level</span><br><span class="line">memory.kmem.slabinfo    memory.soft_limit_in_bytes</span><br><span class="line">memory.kmem.tcp.failcnt    memory.stat</span><br><span class="line">memory.kmem.tcp.limit_in_bytes    memory.swappiness</span><br><span class="line">memory.kmem.tcp.max_usage_in_bytes  memory.usage_in_bytes</span><br><span class="line">memory.kmem.tcp.usage_in_bytes    memory.use_hierarchy</span><br><span class="line">memory.kmem.usage_in_bytes    notify_on_release</span><br><span class="line">memory.limit_in_bytes    tasks</span><br><span class="line">memory.max_usage_in_bytes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里有好多熟悉的小伙伴啊</span></span><br></pre></td></tr></table></figure><h3 id="有关docker与JVM的几个问题"><a href="#有关docker与JVM的几个问题" class="headerlink" title="有关docker与JVM的几个问题"></a>有关docker与JVM的几个问题</h3><p><strong>每一个启动起来的container，在操作系统看来又是以什么形态存在的呢</strong></p><p>答案就是一个进程，但这个进程因为受到CGroup的限制，在申请硬件资源时会被操作系统内核直接限制。</p><p><strong>在docker中运行的JVM到底能使用多大的内存，能不能利用经典Linux内存模型中的换页机制</strong></p><p>能用多大的内存显然取决于CGroups的硬件资源限制。根据<a href="https://blog.csdn.net/candcplusplus/article/details/53728507" target="_blank" rel="noopener">Docker 运行时资源限制</a>中的介绍，限制容器所使用的硬件资源的参数分别如下：</p><ul><li><p>CPU</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name "container1" -c 1024 image</span><br><span class="line">docker run --name "container2" -c 512 image</span><br></pre></td></tr></table></figure><p>参数值是一个整数类型，用于设置当前Docker容器使用cpu的权重值(默认为1024)。这是一个相对值，每个容器能够使用的cpu, 取决于它的cpu shares 占所有容器cpu share的比例: 例如:</p><p>CPU是个稍微特殊一点的资源，假如说CPU资源不紧张的情况下，那我们也没有理由限制容器使用的CPU的数量，所以上述限制只有在CPU紧张的情况下才会发挥作用，如果二者都需要内存，那么 container1 分配到两倍于 container2 的CPU资源。</p></li><li><p>内存</p><p>内存分为物理内存和swap空间，所以docker的限制也包含这两个方面，主要包含六个参数：</p><ul><li><p>第一个是<code>--memory</code>，可以简写为<code>-m</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 此时该容器可以使用的最大的内存值为20M, 默认的swap最大值是物理内存的两倍</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ~ docker run -m 20M image</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们运行下面命令来验证这一点</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ~ docker run --rm -m 20m ubuntu cat /sys/fs/cgroup/memory/memory.limit_in_bytes</span></span><br><span class="line">20971520</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ~ docker run --rm -m 20m ubuntu cat /sys/fs/cgroup/memory/memory.memsw.limit_in_bytes</span></span><br><span class="line">41943040</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 但是有意思的是，容器中的进程并不一定能感知到容器对该进程的硬件资源限制，比如</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ~ docker run --rm -it -m 20m ubuntu free</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        1877556      523812      414256        9128      939488     1186308</span><br><span class="line">Swap:       2064380       41728     2022652</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ~ docker run --rm -it -m 20m ubuntu top</span></span><br><span class="line">top - 07:01:57 up  2:51,  0 users,  load average: 0.02, 0.03, 0.05</span><br><span class="line">Tasks:   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta">%</span><span class="bash">Cpu(s):  0.2 us,  0.2 sy,  0.0 ni, 99.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem :  1877556 total,   416416 free,   521748 used,   939392 buff/cache</span><br><span class="line">KiB Swap:  2064380 total,  2022652 free,    41728 used.  1188244 avail Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">    1 root      20   0   36616   1688   1272 R   0.0  0.1   0:00.04 top</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span><span class="bash"> 无论是top还是free，都并不会去读取cgroup的限制。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其实JDK1.8_131之前也不会去读取CGroup的限制，导致其在计算默认堆大小时</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按照物理机的内存上限去申请。</span></span><br></pre></td></tr></table></figure></li><li><p><code>--memory-swap=300M</code>，这是指物理内存和swap加起来，总共可以用300M，必须和<code>-m</code>搭配使用，不然没意义。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 比如下面这个，实际就使用了200M的物理内存，和100M的swap空间</span><br><span class="line">docker run -m 200M --memory-swap=300M image</span><br></pre></td></tr></table></figure></li><li><p><code>--memory-reservation=300M</code>，这是一个软性限制，所谓的软性限制，是指并不是强制容器在任何时候都不超过这个内存使用值，而是说允许容器短时间内使用的内存超过这个限制，但如果系统内存紧张，会收回分配给容器中进程的资源，强迫其回到软性限制的范围内。软性限制是对物理内存的限制，因此一般来说应该比<code>-m</code>指定的值要小，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -m 500M --memory-reservation 200M image</span><br></pre></td></tr></table></figure></li><li><p><code>--oom-kill-disable</code>，显然，因为docker的资源限制实际上还是使用操作系统内核的特性，所以OOM-killer也仍然由操作系统来进行，未设置这个参数时，当容器使用的内存达到了限制，操作系统内核就会杀掉这个进程，设置后，就不会杀掉这个进程。</p><p>那么假如现在容器中进程使用的资源已经达到了上限，又不允许操作系统杀掉这个进程，此时进程再申请内存怎么办？根据<a href="https://stackoverflow.com/questions/48618431/what-does-oom-kill-disable-do-for-a-docker-container/48618727" target="_blank" rel="noopener">What does –oom-kill-disable do for a Docker container?</a>的介绍，似乎内核会在该进程申请内存时阻塞，直到人为干预为止。</p><p>在未使用<code>-m</code>限制最大内存使用，又禁用了<code>oom-killer</code>的情况下，有可能该进程耗光操作系统内存，还杀不掉，导致内核随机杀掉其他进程，假如不小心杀掉了系统进程，系统就挂了。</p></li><li><p><code>--oom-score-adj</code>这也是操作系统的一个参数，我们在上面介绍过，是操作系统在检测到OOM时计算<code>badness</code>分数时用的一个参数，值越大越容易被杀死。</p></li><li><p><code>--memory-swappiness</code>这也是操作系统的一个参数。其实操作系统并不是只有当物理内存都耗尽的时候才启用swap空间，而是在物理内存使用到一定百分比时，就考虑启用swap空间了。将这个值设为0，意思是尽量使用物理内存，实在不行再用swap，设为100，意为积极使用swap，有机会就交换内存到swap中。</p></li><li><p><code>--kernel-memory</code>，核心内存，不能被交换到swap空间的内存，就是枪支占着物理内存。</p></li></ul><p>一般来说，常用的就是<code>-m</code>和<code>--memory-reservation</code>这两个参数了。那么回到问题本身：在docker中运行的JVM，最多能用到分配给改容器的物理内存和swap空间之和的内存，当然可以把内存交换出去，虽然这不是个好主意。</p></li></ul><p><strong>如果超出了docker的内存限制，JVM到底被谁杀死？</strong></p><p>操作系统啦，哈哈。到这里这个问题的答案简直就是呼之欲出。</p><p><strong>再来看最后那一段超长的问题假设：</strong></p><p>在一个物理内存为16G的机器上，启动了一个内存限制为2G的docker，JVM的堆大小能不能设置成3G？假如能，是不是真的能申请到3G内存？假如不能，这个docker里运行的JVM最大能使用多大的堆？超出了会导致触发谁的OOM机制？</p><p>这里就可以看出我们最初的假设还不够完善，我们再完善一下：</p><p>在一个物理内存为16G的机器上，启动了一个<strong>物理内存和虚拟内存加起来</strong>限制为2G的docker，JVM的堆大小能不能设置成3G？假如能，是不是真的能申请到3G内存？假如不能，这个docker里运行的JVM最大能使用多大的堆？超出了会导致触发谁的OOM机制？</p><p>答案是：JVM的堆大小何止能设置成3G，简直可以设置成1T，只要你不开<code>+AlwaysPreTouch</code>，这些堆又不会真的被使用，连申请都不会申请，只是一个数字，完全可以设置地非常非常大。但是并不能真的申请到超出2G的堆空间，别说2G，考虑到本地内存的占用，1.6G估计就很极限了，真申请到该JVM使用的内存（包括本地内存和Java运行时使用的内存）超过了2G，就会被操作系统OOM杀了。</p><h2 id="尾声：Docker中的JVM"><a href="#尾声：Docker中的JVM" class="headerlink" title="尾声：Docker中的JVM"></a>尾声：Docker中的JVM</h2><p>在<code>JDK1.8_131</code>之前，<code>JVM</code>并不会去读取容器对其使用资源的限制，而直接根据硬件资源来计算默认堆空间大小，综上所述，这样设置当然是可以启动起来的，但是在运行时随着申请的内存越来越多，超过了容器的资源限制，就会被操作系统OOM杀，也就是我们在K8S中看到的<code>OOM KILLED</code>，对于这个问题可以使用Docker的<code>EntryPoint</code>在启动时加上堆最大值和最小值。</p><p><code>JDK1.8_131</code>时，JVM增加了两个参数用来控制这个行为，在这里我懒得找了，因为不怎么好用，至少在<code>JDK1.8_181</code>及以后，JVM提高了对容器的支持，这样就更好用了，但那几个参数我仍然没记住。具体可参见这么两个参考文章：</p><ol><li><a href="https://medium.com/adorsys/jvm-memory-settings-in-a-container-environment-64b0840e1d9e" target="_blank" rel="noopener">JVM Memory Settings in a Container Environment</a></li><li><a href="https://merikan.com/2019/04/jvm-in-a-container/" target="_blank" rel="noopener">JVM in a Container</a></li></ol><p>另外，通过上面的分析，我们可以得知，JVM虚拟机虽然能够使用交换内存，但是使用后很可能造成性能急剧下降，强烈不推荐这种用法。最好是合理设置小于物理内存的堆内存大小，并且令<code>memory-swappiness=0</code>，从而尽量要求操作系统不把JVM的内存交换到缓存空间中去。而本地内存中使用NIO造成的垃圾，虽然JVM也不是完全不管不顾，但是只有<code>FULL GC</code>时才能回收，而且实际上是调用了<code>System.gc()</code>，如果在虚拟机中参数中禁用了显式的gc，那么该部分内存就无法被回收，最终会触发操作系统的<code>OOM killer</code>，导致<code>JVM</code>进程被杀。</p><h2 id="参考及待研究"><a href="#参考及待研究" class="headerlink" title="参考及待研究"></a>参考及待研究</h2><ul><li><p>Linux内存管理</p><p><a href="https://blog.51cto.com/wutengfei/2163283" target="_blank" rel="noopener">Linux交换空间(swap space)</a></p><p><a href="http://www.hulkdev.com/posts/oom_killer" target="_blank" rel="noopener">OOM_Killer</a></p></li><li><p>JVM内存管理</p><p><a href="https://zhuanlan.zhihu.com/p/64737522" target="_blank" rel="noopener">JVM 与 Linux 的内存关系详解</a></p><p><a href="https://www.jianshu.com/p/11ae309ab078" target="_blank" rel="noopener">JVM:能不能在16G机器上设置17G的堆？</a></p></li><li><p>Docker</p><p><a href="https://www.infoq.cn/article/docker-kernel-knowledge-cgroups-resource-isolation" target="_blank" rel="noopener">Docker 背后的内核知识——cgroups 资源限制</a></p><p><a href="https://blog.csdn.net/candcplusplus/article/details/53728507" target="_blank" rel="noopener">Docker 运行时资源限制</a></p><p><a href="https://stackoverflow.com/questions/48618431/what-does-oom-kill-disable-do-for-a-docker-container/48618727" target="_blank" rel="noopener">What does –oom-kill-disable do for a Docker container?</a></p><p><a href="https://medium.com/adorsys/jvm-memory-settings-in-a-container-environment-64b0840e1d9e" target="_blank" rel="noopener">JVM Memory Settings in a Container Environment</a></p><p><a href="https://merikan.com/2019/04/jvm-in-a-container/" target="_blank" rel="noopener">JVM in a Container</a></p></li><li><p>JNI部分</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jnileak/index.html" target="_blank" rel="noopener">在 JNI 编程中避免内存泄漏</a></p><p><a href="https://blog.csdn.net/pzysoft/article/details/79923121" target="_blank" rel="noopener">JNI内存管理</a></p></li></ul><p><strong>声明：</strong></p><p>本文仅用于自学以及几位好友的内部交流，请勿转发给工作相关人员。</p><p>如果承蒙错爱想发博客，注明一下作者即可。</p><p>不保证文章中任何部分的正确性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;从进程的角度再探Java内存&quot;&gt;&lt;a href=&quot;#从进程的角度再探Java内存&quot; class=&quot;headerlink&quot; title=&quot;从进程的角度再探Java内存&quot;&gt;&lt;/a&gt;从进程的角度再探Java内存&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;的内存模型</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础整理之线程池</title>
    <link href="http://yoursite.com/2020/04/17/Java%E5%9F%BAJava%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2020/04/17/Java%E5%9F%BAJava%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-04-17T05:57:58.000Z</published>
    <updated>2021-04-22T04:43:17.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="听说你熟悉线程池？"><a href="#听说你熟悉线程池？" class="headerlink" title="听说你熟悉线程池？"></a>听说你熟悉线程池？</h2><p>在Java的世界里，我们一遇到阻塞的问题，就会想着去创建线程。之所以这么做能够在某些情况下加快程序的运行，是基于这么几个事实。</p><ul><li>线程是CPU可以调度的最小任务单元。如果一个进程是单线程的，那么当他因为某种原因陷入阻塞时就会失去CPU的使用权。假如我们这台服务器就是给某个server用的，那它失去了使用权显然不是我们期待的行为。所以即使在单CPU的情况下，使用多线程模型也可以保证在其中一个线程因阻塞失去CPU使用权的时候，我们进程中还有其他任务可以得到CPU的调度。</li><li>现代服务器基本都是多处理器，或者多核心的，从概念模型上，就是有多个CPU可以用。如果我们坚持使用单线程，因为一个线程只能被一个CPU执行，那么其他CPU就浪费了，这也显然不是我们期望的行为。</li></ul><p>所以，在大部分情况下，使用多线程都会带来性能上的提升。</p><p>但是问题来了，是不是使用多线程一定会带来性能上的提升？</p><ul><li><p>场景一</p><p>一个单线程在单CPU上执行CPU密集型的任务，根本没有IO什么乱七八糟的阻塞，他就是占据CPU，一直在运算，这时候多开一个线程，能不能提高运行效率？</p></li><li><p>场景二</p><p>在4个可用CPU的场景下，一口气提交了1000个任务，我是不是开1000个线程就能达到最佳性能？</p></li></ul><p>答案都是否定的，我们来分析在启用和不启用多线程的情况下，CPU在处理任务的时候，到底干了哪些活儿，我们模拟一个08年的梦幻PC机，拥有牛叉的双核处理器。</p><ul><li><p>不启用多线程。</p><ul><li>提交了任务一。交由主线程，<code>CPU-1</code>拿到任务，开始处理。</li><li>提交了任务二。交给主线程，<code>CPU-1</code>的任务还没有处理完，此时CPU-2可用，但是因为<strong>线程是CPU可调度的最小任务单元</strong>，<code>CPU-2</code>无法和<code>CPU-1</code>同时处理一个线程的工作，因此任务二排队，<code>CPU-2</code>闲置。</li><li><code>CPU-1</code>完成了任务一的处理，继续处理任务二。</li></ul></li><li><p>启用了多线程，线程按需创建。</p><ul><li>提交了任务一。交由线程1，<code>CPU-1</code>拿到任务，开始处理。</li><li>提交了任务二。此时没有多余的线程可以处理任务，CPU-2创建了一个线程，他是线程2，任务2现在交个线程2处理，<code>CPU-2</code>单独调度线程2，此时<code>CPU-1</code>干任务1，<code>CPU-2</code>干任务2，很好。</li><li><p>提交了任务三，此时没有多余的线程可以处理任务，<code>CPU-1</code>和<code>CPU-2</code>都在忙，但是现代CPU都是时分复用的，于是<code>CPU-1</code>这时候暂时放下线程1中的任务1，为任务3创建了一个线程3，接下来，<code>CPU-1</code>和<code>CPU-2</code>在3个线程之间来回切换。</p></li><li><p>more task the same</p></li></ul></li><li><p>启用了多线程，但只允许最多有两个线程。</p><ul><li>提交了任务一。交由线程1，<code>CPU-1</code>拿到任务，开始处理。</li><li>提交了任务二。此时没有多余的线程可以处理任务，CPU-2创建了一个线程，他是线程2，任务2现在交个线程2处理，<code>CPU-2</code>单独调度线程2，此时<code>CPU-1</code>干任务1，<code>CPU-2</code>干任务2，很好。</li><li>提交了任务三。这时候不允许创建新的线程了，于是任务3没办法，只能在等待某一个线程的任务完成以后，再把自己放到线程里面去，得到某个CPU的调度。此时<code>CPU-1</code>干任务1，<code>CPU-2</code>干任务2。</li></ul></li></ul><p>所以我们发现，多线程其实为整个CPU增加了一些额外的工作，这主要包括</p><ul><li>创建线程的开销。这个开销其实很大，是重量级的系统调用，还要为线程开辟栈空间、初始化一些数据，等等。</li><li>任务切换的开销。这个开销也不小，CPU需要把寄存器里面的东西都替换出来（也就是任务上下文的保存），然后把之前保存的另外一个任务的上下文装载到寄存器里面，现代CPU本来内部还很复杂，流水线什么的基本上全部都破坏掉了，也非常消耗资源。</li></ul><p>可见，整体效率最高的办法其实是：有几个CPU，我们就开几个线程，然后任务排队，这样CPU始终在跑一个任务，永远不切换，跑完一个换下一个。这样算下来，完成N个任务的总体时间是最短的。</p><p>但这并不是最友好的解决方案，现实世界总有那么多额外限制，让我们不得不做出权衡。假设我们现在有个服务器，有10个人先后请求了，那么是不是最后一个请求的人就倒霉到必须等到前面所有请求都干完了才轮到我呢？假如前面的人是下载一个视频，而我只是发个文本消息，我还得等到他们干完才轮到我，是不是很不爽？所以实际上，除了确实在干CPU密集型的任务而且容许排队，不然适当开多个线程，让CPU切换处理，是一种权衡之下的更优解。</p><p>好吧，上面是一些人尽皆知的基础知识……希望没有浪费各位看官的时间。</p><p>做个简单的总结，我个人认为，使用线程的两大主要目的，一个是提高CPU的使用效率，一个是保持合理的客户请求响应速度。显然，如果我们的程序就是要做大量运算的，不提供客户服务，显然线程数量和CPU数量保持一致最好；如果想保证合理的客户响应速度，需要多开一些线程，但线程新建的内存和CPU消耗，以及线程切换时的消耗随着线程数量的增加而增加，总会到某个节点，线程新建和切换的消耗完全抵消了多线程可能带来的性能提升，CPU的时间被大量浪费在新建和切换线程，所有的响应都慢的受不了。</p><p>所以，在我们业务要求我们必须保持合理的响应时间的时候，我们（被迫）必须考虑这样的两个核心问题：</p><ol><li>能不能减少线程新建的开销？</li><li>能不能减少线程切换的开销，但却又能保证足够高的CPU利用率。</li></ol><p>问题一的答案是使用线程池，而问题二的答案是设置合理的线程数量。</p><p>我们来看一段我们代码里使用线程池的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">stupidGuy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ExecutorService executors = Executors.newFixedThreadPool(threadCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">        executors.execute(<span class="keyword">new</span> someRunnable());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 我们并不关心这些任务什么时候能结束，所以直接返回了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看这段代码干了什么：</p><ol><li>新建了一个线程池，这个线程池因为是使用<code>Executors.newFixedThreadPool(threadCount)</code>建立出来的，因此会有threadNum个核心线程，threadNum个最大线程，不会主动回收线程资源，并且初始化线程数量为0。</li><li>现在我们在for循环里面开始向线程池提交任务，那么他会一直创建新的线程来接受任务，即使有空闲线程可用，也会创建新的线程。直到线程数量达到threadNum。</li><li>然后因为我们不关心这些任务什么时候结束，所以直接返回了。</li></ol><p>直接说答案，这是完全错误的用法，因为造成了内存泄露。</p><p><code>Executors.newFixedThreadPool(threadCount)</code>在没有调用<code>shutDown()</code>的情况下，即使已经没有引用指向他了，他也永远不会释放自己维护的线程池里面的线程资源，所以一定会造成内存泄露。</p><p>于是我们稍微修改这代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">stupidGuy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ExecutorService executors = Executors.newFixedThreadPool(threadCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">        executors.execute(<span class="keyword">new</span> someRunnable());</span><br><span class="line">    &#125;</span><br><span class="line">  executors.shutdown();</span><br><span class="line">  <span class="comment">// 如果我们希望所有任务完成后再继续，那么可以加上下面这段代码，但加不加对我们这里</span></span><br><span class="line">  <span class="comment">// 想要考察的问题是没有影响的。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executors.awaitTermination(<span class="number">1</span>,TimeUnit.DAYS)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// 并没有人来打断这个线程，所以donothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>同上；</li><li>同上；</li><li>shutdown()之后，且线程池里面的所有线程都运行完了，且线程池的引用也离开了作用域，这时候相关线程资源会被释放，于是Thread对象本身、其代表的线程所申请的栈空间等等，都会被回收释放。不会内存泄露啦，是不是有点开心。（<code>Executors#创建其他线程池的方法</code>创建出来的线程池，不需要像<code>Executors.newFixedThreadPool(threadCount)</code>创建出来的线程池一样显式调用<code>shutdown()</code>也可以内存回收）</li></ol><p>等等，我们最开始说什么来着？创建线程池是为了干嘛？为了<strong>减少线程新建的开销</strong>，可是我们在这里干什么呢？每次调用这个方法，我都新建了个线程池，在第二步还新建了线程。</p><p><strong>那你说我建个线程池图啥呢？</strong></p><p>所以说：线程池不是这么用滴，实际上，<strong>一个线程池，基本应该是全局的。或者至少是类的静态变量</strong>。在方法里建局部线程池是错误的用法，因为完全没有解决线程池这个概念旨在解决的问题，甚至新增了一些维护线程池的负担。</p><p>然后我们看第二个问题，到底多少线程是合理的。</p><p>这个其实需要评估。使用线程池是为了更大限度提高CPU的利用率，那么实际上比较理想的模型是：当一个线程因为IO而阻塞时，总是有刚刚好有需要使用CPU的线程可供CPU调度，这需要根据业务进行量化评估。</p><p>比如说：我们一个线程中的工作，20%是CPU需要运算的，而80%则用来等待IO。那么我们可以把线程池中维护的线程的数量提高到CPU核心数量的4倍。这样则所有等待IO的时间，CPU都有实际的工作线程可以调度。为了维护服务对多个请求都有合理的响应时间，那么线程数量实际上还可以再多几个（30%-50%）。更多的线程未必能带来更好的效果。如果要更精细地调优，我感觉还得评估CPU上下文切换的开销到底有多大。这个太难了，不玩。</p><h2 id="不是总结的总结"><a href="#不是总结的总结" class="headerlink" title="不是总结的总结"></a>不是总结的总结</h2><p>坑到处都有，很多正常不过的操作细想也不是那么回事……线程池最好是全局或者至少是类静态变量，不然就丧失了使用线程池的意义，而线程数量也不是越多越好，而要根据实际的业务需求进行评估，一般可能需要经过反复的测试、评估，才能找到最合适的线程数量。</p><h3 id="聊胜于无的版权声明"><a href="#聊胜于无的版权声明" class="headerlink" title="聊胜于无的版权声明"></a>聊胜于无的版权声明</h3><p>仅用于几位好友的内部技术交流，请勿邮件转发给工作相关人员。</p><p>如果承蒙错爱想发博客，注明一下作者即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;听说你熟悉线程池？&quot;&gt;&lt;a href=&quot;#听说你熟悉线程池？&quot; class=&quot;headerlink&quot; title=&quot;听说你熟悉线程池？&quot;&gt;&lt;/a&gt;听说你熟悉线程池？&lt;/h2&gt;&lt;p&gt;在Java的世界里，我们一遇到阻塞的问题，就会想着去创建线程。之所以这么做能够在某些</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础整理之线程</title>
    <link href="http://yoursite.com/2020/04/07/Java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%E4%B9%8B%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/04/07/Java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%E4%B9%8B%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-04-07T05:56:25.000Z</published>
    <updated>2021-04-22T04:43:17.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h2><h3 id="多线程基本概念"><a href="#多线程基本概念" class="headerlink" title="多线程基本概念"></a>多线程基本概念</h3><ul><li><p>线程</p><p>线程是可以被CPU调度的最小运行单位。也可以认为是一种轻量级的进程。每个进程都有自己独立的地址空间，这保证了进程之间的隔离性，但也带来了进程之间相互访问的复杂性。而同进程的多个线程共享地址空间，因此相比进程来说要快的多，也更轻量一些。</p></li><li><p>并行与并发</p><p>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。</p><p>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</p><p>无论是并行还是并发，CPU调度不同线程的代码块的顺序是随机的，在一个线程运行的任意时刻，都可能被剥夺CPU的使用权，加上不同的线程地址空间共享，经常会操作同一资源，这就引发了多线程环境下最让人头疼的线程安全问题。</p></li><li><p>线程安全</p><p>即一段代码在并发的情况之下，经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果，如不加事务的转账代码：</p></li><li><p>同步</p><p>指的通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。线程安全的优先级高于性能。</p></li><li><p>锁</p><p>一个用来做线程同步的工具，一个锁保护了代码中的一段，这段代码称之为临界区。同一时间，只有持有锁的线程才能进入临界区代码。在java的世界里，每个Object实例都有一个内部锁，通过<code>synchronized</code>关键字和<code>wait()</code>,<code>notify()</code>,<code>notifyAll()</code>方法控制。</p></li></ul><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>线程的内部状态有6个，以<code>enum</code>的形式定义在<code>Thread</code>里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">         * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">         * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">         * such as processor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">         * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">         * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">         * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">         * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">         * following methods:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">         * perform a particular action.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">         * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">         * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">         * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">         * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">         * The thread has completed execution.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状态转换已经很清晰了，要注意的是</p><ul><li><p>所谓阻塞状态</p><p>这里的<code>BLOCKED</code>与我们平时说的阻塞含义不完全一致，<code>BLOCKED</code>的仅指线程无法获得锁而无法继续时所处的状态，而我们日常所说的阻塞，还包括<code>TIMED_WAITING</code>状态，比如调用sleep后我们也说线程进入了阻塞状态，实际上在java内部，线程处于<code>TIMED_WAITING</code>状态。</p></li><li><p>所谓RUNABLE</p><p>java内部并不区分可运行的线程和正在运行的线程，一个可运行的线程，可能正在等待CPU的调度，也有可能正在使用CPU。总之它此时都是RUNABLE状态。</p></li></ul><h3 id="线程的终止和中断"><a href="#线程的终止和中断" class="headerlink" title="线程的终止和中断"></a>线程的终止和中断</h3><p>线程的终止有两种方式：1. 其工作执行完毕；2. 出现了未捕获的异常。在java早期，还有一个stop方法让线程强制终止，并随之释放其持有的锁。但这种强制终结线程的方法显然不安全，比如转账，从一个账户转出后线程被强制终止，那么账户金额就出现了不一致。因此现在已被弃用。</p><p>除以上两种方式以外，没有方法能强制一个线程终止。线程中断提供了一种方式，请求线程终止自己。方式是，当对一个线程调用了<code>interrupt()</code>方法，线程的中断状态会被置位。线程<strong>应该</strong>时不时检测这个中断状态，决定如何处置。一些非常重要的线程，可能会忽略这个中断标志，而大部分线程都应该将中断标志视为自己退出的标志，即线程自己决定结束自己，比如直接跳到代码块尾部。如果该中断状态被置位时线程处于阻塞状态，即没有机会检测中断标志，则阻塞状态会结束，线程会抛出<code>InterruptedException</code>。</p><p>一般不建议将这个Exception的影响压制在过低的范围内，比如说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mySubMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">  sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这样实际上会丢失中断请求，建议的处理方式是：要么直接在方法上声明抛出异常，要么在catch块中将中断标志重新置位：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mySubMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">  sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">  Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而检查线程是否中断也有两种方式，一个是Thread的静态方法<code>interrupted</code>，检查当前线程是否被中断，但该方法有副作用，会清除中断标志，一个是thread的方法<code>isInterrupted</code>，没有副作用。</p><h3 id="线程的方法们"><a href="#线程的方法们" class="headerlink" title="线程的方法们"></a>线程的方法们</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span> <span class="comment">// 返回对当前正在执行的线程对象的引用。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Boolean <span class="title">interrupted</span><span class="params">()</span> <span class="comment">// 检测中断位，并将中断位直接清除</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span><span class="comment">// 返回该线程的标识符。 </span></span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span><span class="comment">// 返回该线程的名称。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span> <span class="comment">// 返回线程的优先级。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> <span class="comment">// 设置线程的中断位标志 </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span><span class="comment">// 测试线程是否处于活动状态。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span><span class="comment">// 让调用线程等待该线程终止</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span><span class="comment">// 等待该线程终止的时间最长为 millis 毫秒。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span><span class="comment">// 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> on)</span><span class="comment">// 将该线程标记为守护线程或用户线程。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span><span class="comment">// 更改线程的优先级。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span><span class="comment">// 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span><span class="comment">// 在指定的毫秒数加指定的纳秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="comment">// 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span><span class="comment">// 使当前的线程主动声明放弃CPU的使用权，重新参与CPU调度竞争</span></span></span><br></pre></td></tr></table></figure><p>重点讲这么几个方法：</p><ul><li><p><code>join()</code></p><p><code>thread.join()</code>的效果是，调用该方法的线程，等待该方法被调用的线程对象所在的线程完成工作后再继续。看下面一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> JoinThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 主线程等待thread的业务处理完了之后再向下运行  </span></span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子里，主线程调用了thread线程的join()方法，效果是主线程等待thread线程结束才能继续。即无论在<code>thread.start()</code>之后是main被调度，还是thread被调度，效果都是thread先运行完。因为如果main先被调度，一定会立即执行到<code>join()</code>，从而放弃调度。</p></li><li><p><code>sleep()</code></p><p>sleep()会<strong>阻塞</strong>当前进程，让出CPU使用权，准确地说，线程现在将进入<code>TIMED_WAITING</code>状态。虽然是Thread的静态方法，但实际上只是暂停当前的线程。在sleep()到期后，线程并不一定会立即被调度，只是进入了Runable状态，可以被调度。该操作不会放弃锁。</p></li><li><p><code>yield()</code></p><p>当前线程主动放弃CPU的使用权，重新进入CPU的调度中，此时有可能其他线程被调用，也有可能该线程立即又被CPU调度。该操作和sleep()一样，不会放弃锁。</p></li><li><p><code>setDaemon()</code></p><p>将线程设置为守护线程。一个守护线程能做的事情就是为其他线程做服务，比如说提供时钟打点、垃圾回收等等。当一个JVM里只有守护线程运行时，JVM也会退出。</p></li></ul><h3 id="线程和锁"><a href="#线程和锁" class="headerlink" title="线程和锁"></a>线程和锁</h3><p>线程之间地址空间共享，因此可以方便地操作同一个资源，经典的比如生产者、消费者模型，生产者线程向一个队列里一直写入数据，而消费者线程从队列中不断取出数据进行消费，因为线程的工作在任何时间都会被打断，其他线程的工作可能会插入，那么向队列中插入数据和取出数据的行为可能变得不安全，比如引起队列内部数据结构的混乱等。还比如说在多线程同时操作一个数字， 对其进行加减操作，因为加减操作不是原子的，就可能造成数据的不一致等。</p><p>为了避免这种<strong>线程不安全情况</strong>的发生，在多线程编程环境下，我们经常需要使用锁。</p><h4 id="wait、notify和synchronized"><a href="#wait、notify和synchronized" class="headerlink" title="wait、notify和synchronized"></a>wait、notify和synchronized</h4><h5 id="monitor机制"><a href="#monitor机制" class="headerlink" title="monitor机制"></a>monitor机制</h5><p><a href="https://segmentfault.com/a/1190000016417017" target="_blank" rel="noopener">Java 中的 Monitor 机制</a></p><p>操作系统在面对 进程/线程 间同步的时候，提供了的一些同步原语，其中semaphore信号量和mutex互斥量是最重要的同步原语。但直接使用这些原语进行同步必须十分小心，很容易出错，为此，为了更容易地编写出正确的并发程序，<strong>一些编程语言</strong>在mutex和semaphore的基础上，提出了更高层次的同步原语monitor，monitor的重要特点是，同一个时刻，只有一个线程能进入monitor中定义的<strong>临界区</strong>，这使得monitor能够达到互斥的效果。但仅仅有互斥的作用是不够的，无法进入monitor临界区的线程，它们应该被阻塞，并且在必要的时候会被唤醒。</p><p>使用monitor机制的目的主要是为了互斥进入临界区，为了做到能够阻塞无法进入临界区的线程，还需要一个monitor object来协助，这个monitor object内部会有相应的数据结构，例如列表，来保存被阻塞的线程；同时由 monitor机制本质上是基于mutex这种基本原语的，所以monitor object 还必须维护一个基于mutex的锁。</p><p>此外，为了在适当的时候能够阻塞和唤醒 进程/线程，还需要引入一个条件变量，这个条件变量用来决定什么时候是“适当的时候”，这个条件可以来自程序代码的逻辑，也可以是在monitor object的内部，总而言之，程序员对条件变量的定义有很大的自主性。不过，由于monitor object内部采用了数据结构来保存被阻塞的队列，因此它也必须对外提供两个 API 来让线程进入阻塞状态以及之后被唤醒，分别是wait和notify。</p><p>在java中，每一个object都有一个对应的内部锁，即一个monitor，object提供了wait、notify、notifyAll方法、java提供了<code>synchronized</code>关键字来操作这个锁。</p><h5 id="入口集和等待集-锁池与等待池"><a href="#入口集和等待集-锁池与等待池" class="headerlink" title="入口集和等待集(锁池与等待池)"></a>入口集和等待集(锁池与等待池)</h5><p><strong>注意：这是重量级锁的实现，在后文锁的中高级扩展知识中有详细阐述</strong></p><p><a href="https://www.zhihu.com/question/64725629" target="_blank" rel="noopener">知乎：锁池和等待池相关提问</a></p><p>对于每一个monitor，java都会为其维护一个<code>Entry Set</code>(入口集，也有翻译为锁池的)和<code>Wait Set</code>(等待集，也有翻译为等待池)，其中，EntrySet用于保存等待获取该monitor对应的内部锁的所有线程，而其WaitSet则用于存储执行了在该对象上调用了<code>wait()</code>、<code>wait(long)</code>的线程。</p><p>假设objectX是任意一个对象，moniterX为这个对象对应的内部锁，假设有线程A、B、C同时申请monitorX，胜出的线程是B，那么AC线程会被暂停(即其生命周期被调整为BLOCKED)，同时AC被存入objectX对应的Entry Set中，当B释放monitorX时，JVM会决定唤醒EntrySet中的任意一个线程，将其生命周期状态调整为RUNABLE，这个被唤醒的线程会与其他活跃线程(不在EntrySet中，且状态为RUNABLE的线程)再次抢占monitorX，如果成功申请到monitorX，该线程从entrySet中移出，否则被唤醒的线程仍然停留在EntrySet中，并再次进入BLOCKED状态，等待下次有线程放弃锁。</p><p>如果有线程在获得锁的情况下，调用了wait()方法，则他将会主动放弃锁，同时被暂停（线程的生命周期状态被设置为WAITING或者TIMED_WAITING），并进入monitorX的WaitSet。此时，线程就被称为objectX的等待线程。当其他线程在objectX上调用了<code>notify()</code>或者<code>notifyAll()</code>后，WaitSet中的任意一个(<code>notify()</code>)或所有(<code>notifyAll()</code>)等待线程会被移入EntrySet，即线程生命周期调整为RUNABLE，这些被唤醒的线程会与EntrySet中被唤醒的线程以及其他活跃线程共同抢夺monitorX，如果其中一个被唤醒的等待线程成功申请到锁，那么该线程会从EntrySet中移除，否则其会继续停留在EntrySet中，并再次被暂停。</p><p>在一些情况下，使用<code>notify()</code>可能导致死锁，死锁的原因可以参见：<a href="https://www.jianshu.com/p/45626f4e0fc1" target="_blank" rel="noopener">从一个死锁分析wait，notify，notifyAll</a></p><p>简版的解释是：假如我们用一个List作为对象作为锁，那么假如有一个生产者P向该List中添加数据，两个消费者C1，C2从List中取出数据，在某一时刻，P和C2都在等待池中，消费者C1消费完毕后，list为空，然后调用了list的notify，但C2被调度，此时C2因为条件不满足，获得锁之后会立即放弃锁，也进入等待池，此时三个线程全都在等待池，等待不可能到来的资源，就形成了死锁。</p><p>为了防止这类死锁的发生，一个是可以将notify改为notifyAll，一个是可以在调用wait时传入合适的超时时间，这样可以保证在超时后，线程仍然会进入锁池。<strong>effective java</strong>中推荐的标准写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">while</span> (&lt;condition does not hold&gt;)&#123;</span><br><span class="line">        obj.wait(timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Perform action appropriate to condition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解了等待集和入口集的概念以后，就可以画出线程的全生命周期图：</p><p><img src="https://www.history-of-my-life.com/imgs-for-md/java%E7%BA%BF%E7%A8%8B%E5%85%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE2019-6-11.jpg" alt="线程全生命周期图"></p><h6 id="todo-存疑"><a href="#todo-存疑" class="headerlink" title="todo 存疑"></a>todo 存疑</h6><p>这里有个小疑问，在知乎的上述回答中，该大佬称</p><blockquote><p>从java虚拟机性能的角度来说，java虚拟机没有必要在notifyAll之后将WaitSet中的线程移入EntrySet，因为从一个队列移动到另一个队列有开销。其次，notifyAll后WaitSet中多个线程会被唤醒，但在极端情况下这些线程没有一个能获得锁，或者获得了锁但也因为其他资源不满足而无法运行，那么这个时候，这些等待线程仍然需要调用wait()进入等待状态，此时将他移出WaitSet后需要马上再移回WaitSet，这就是一种浪费。</p></blockquote><p>所以，该大佬表示：</p><blockquote><p>当其他线程在objectX上调用了<code>notify()</code>或者<code>notifyAll()</code>后，WaitSet中的任意一个(<code>notify()</code>)或所有(<code>notifyAll()</code>)等待线程会被唤醒，即线程生命周期调整为RUNABLE，这些被唤醒的线程会与EntrySet中被唤醒的线程以及其他活跃线程共同抢夺monitorX，如果其中一个被唤醒的等待线程成功申请到锁，那么该线程会从<strong>WaitSet</strong>中移除，否则其会继续停留在<strong>WaitSet</strong>中，并再次被暂停。</p></blockquote><p>但在这个理论中，我没搞清楚一点，即这样难道不会造成死锁？以上面notify()导致死锁的案例为例：</p><p>假如此时P和C1在等待集，C2获取锁后处理完毕，进行notifyAll()，此时P和C1、C2共同竞争锁，结果C2再次获胜，此时按大佬的说法，P和C1仍然在等待集中，但此时C2因为队列为空无法处理，调用wait()进入等待集。但按照大佬的说法，JVM会唤醒EntrySet中的线程，但不会唤醒WaitSet中的线程，所以此时所有的线程都在WaitSet里，没有任何线程可以唤醒他们了。除非，当P和C1在等待集中被唤醒后因为抢夺锁失败，重新进入BLOCKED状态，而JVM在唤醒时也不是只唤醒WaitSet中的线程，而是唤醒所有在BLOCKED状态的线程，这样才可以避免死锁。</p><p>但这与大佬的说法不符，而且每次都要扫描WaitSet和EntrySet中的所有线程，那么还要这两个Set干嘛？每次全部扫描不就OK了。所以这个问题还是比较没搞清楚，在这里权做记录。</p><h5 id="synchronized、wait、notify与notifyAll的效果"><a href="#synchronized、wait、notify与notifyAll的效果" class="headerlink" title="synchronized、wait、notify与notifyAll的效果"></a>synchronized、wait、notify与notifyAll的效果</h5><p>一言以蔽之，<strong>被 synchronized 关键字修饰的方法、代码块，就是monitor机制的临界区。</strong>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object ANOTHER_LOCK = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (ANOTHER_LOCK) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，上述的 synchronized 关键字在使用的时候，往往需要指定一个对象与之关联，例如 synchronized(this)，或者 synchronized(ANOTHER_LOCK)，synchronized 如果修饰的是实例方法，那么其关联的对象实际上是this，如果修饰的是类方法，那么其关联的对象是this.class。总之，synchronzied需要关联一个对象，而这个对象就是monitor object。</p><p>只有在Entry Set中的线程才会去竞争锁，而哪个线程获得锁则由系统的调度程序决定。当调用某个object的wait方法时，当前线程必须已经获得了锁(所以要求wait必须在synchronized块中调用)，而调用该方法将导致当前线程直接放弃锁，进入Wait Set。进入Wait Set的锁将永远不会主动<strong>竞争</strong>锁，除非其他线程在该Object上调用了notify或者notifyAll方法，这两个方法也要求当前线程必须获得锁，因此也必须在synchronized块中调用，如果调用的是notifyAll方法，那么所有在该object的Wait Set中的线程都会进入Entry Set，重新竞争锁，而notify方法会则随机将一个线程从wait set移动到entry set。</p><h4 id="sleep与wait"><a href="#sleep与wait" class="headerlink" title="sleep与wait"></a>sleep与wait</h4><p>sleep和wait虽然都会导致阻塞，但是wait会释放锁，而sleep不会释放锁。必须要想明白的一个问题是，锁其实只和monitor对象有关，而wait正是操作monitor对象的方法，而sleep则和锁无关。</p><p>wait存在的原因是，只有获得锁才能判断资源是否就位(以防刚判断完资源就被修改了)，但如果资源没就位获得锁就没有意义，所以就搞出了一个synchronized – wait的结构，即“获取锁-判断资源情况-判断不满足就释放锁-然后等通知重来”，用特定的代码形式来实现“条件同步”。所以wait必须存在于synchronized代码块中，如果在未获得锁时调用，就必然抛出<code>IllegalMonitorStateException</code>异常。而sleep既然与锁无关，也就不要求放在synchronized代码块里了。</p><p>因为wait()和sleep()时线程都处于阻塞状态，因此无法检查线程的中断状态，所以如果阻塞期间中断标志被置位，都会抛出<code>InterruptedException</code>。</p><h4 id="锁的可重入性"><a href="#锁的可重入性" class="headerlink" title="锁的可重入性"></a>锁的可重入性</h4><p>一般来说，锁上有一个计数器。已经获得monitorX锁的线程，可以重复获得该锁，每次进入临界区，锁的计数器会加一，退出一个临界区，会减一。从而实现可重入。</p><h4 id="Lock-and-Condition"><a href="#Lock-and-Condition" class="headerlink" title="Lock and Condition"></a>Lock and Condition</h4><h5 id="synchronized的不足之处"><a href="#synchronized的不足之处" class="headerlink" title="synchronized的不足之处"></a>synchronized的不足之处</h5><p>在java5之前，要想直接使用<code>thread and lock</code>机制，必须使用<code>synchronized wait notify</code>机制。但是synchronized关键字也有一些缺点：</p><ul><li>一个锁只能等待一个条件。在并发多的情况下，多个条件可以让代码的可读性更好，也更容易实现一些。</li><li>无法控制获得锁的顺序，在一些倒霉的情况下，某些线程可能总是得不到调度。而接下来要介绍的Lock就会提供公平机制(会较大降低性能)，优先选择长期未得到调度的线程。</li><li>synchronized是悲观锁，造成的性能损失较大。而之后要介绍的Lock是乐观锁，采用CAS(compare and swap来)加锁，性能要好得多。</li><li>在尝试获取锁时阻塞且无法中断。意思是说，假如一个线程尝试进入synchronized锁定的临界区，那他就必须一直等待，无法退出，如果别人永远不释放锁，那这个线程就永远等下去。接下来要介绍的Lock就要高端一些，有<code>tryLock()</code>方法，可以直接返回，也有方法可以在等待一段时间后返回，此时当前线程将目前持有锁的线程中断，或者决定做其他工作。</li><li>缺少读写锁的支持。当多线程同时读一个文件时，读操作理应相互不阻塞，而写操作本身、读写操作才需要阻塞，但synchronized显然是一刀切，读操作也相互阻塞，这不合理。</li><li>无法得知锁当前的状态，即是否被锁上，有多少线程在等待锁等。</li><li>在Lock的注释里，还提到，synchronized必须按顺序加锁，逆序解锁，并且必须在同一个作用域里释放，这使得一些技术难以施展，比如说一些算法可能需要chain lock，即获得nodeA的锁，然后获得nodeB，然后释放nodeA，然后获得nodeC的锁，这样加锁顺序和释放顺序就不是严格逆序，而且也不一定在一个作用域，用synchronized的话就很难应用。</li></ul><p>可以说，synchronized是在刚开始，JDK还不够成熟时诞生的通用解决方案，任何对象都可以作为它的监视器。任何对象都可以作为monitor这种设计是否合理还有待考证，而它确实存在的这些不足，也促进了JDK1.5推出更高级的锁机制。即<code>java.util.concurrent.locks</code>包里的一些类。</p><h5 id="Lock接口简介"><a href="#Lock接口简介" class="headerlink" title="Lock接口简介"></a>Lock接口简介</h5><p>自从JDK1.5依赖，java新增了标准包：<code>java.util.concurrent.locks</code>，除了推出了比synchronized语义更加灵活的Lock and Condition以外，还推出了很多高级线程同步工具。其实根据《Java核心技术》一书的建议，普通用户：</p><blockquote><ol><li><p>最好既不使用Lock/Condition，也不使用synchronized关键字，因为这些都是比较贴近底层的同步原语，用的不好非常容易出错。concurrent包带来了很多同步工具，他们都隐藏了这样的加锁与加锁行为，很大程度上降低了程序员的心智负担。在可行的情况下，应当使用更高级的同步工具。</p></li><li><p>如果synchronized已经够用，那就尽量使用synchronized，因为这需要更少的代码量，减少了出错的几率。</p></li><li>如果特别需要Lock/Condition带来的新特性，才使用Lock/Condition。</li></ol></blockquote><p>但既然已经开始了解并发问题了，那总是要了解一下Lock/Condition的。</p><p>提炼了一下Lock接口的注释内容：</p><blockquote><ol><li>介绍了一下什么是锁。在绝大多数情况下，一个锁只能被一个线程获取，即确保同一时间只有一个线程能访问共享资源，但例如读写锁这样的锁，就允许并发访问同一个资源。</li><li>synchronized关键字解锁时只能在同一作用域，且解锁顺序必须与加锁顺序严格逆序。这限制了一些高端技巧的应用。</li><li>Great power comes with Great responsibility。在Lock带来更大灵活性的同时，也带来了释放锁的额外要求，要求程序员一定要记得在finally块中解锁。如果加锁和解锁不在同一个作用域，就需要加倍小心。</li><li><p>Lock提供了比synchronized更多的特性。包括请求锁时不阻塞：<code>trylock()</code>，无法获得锁时立刻返回false；包括因等待锁而阻塞时，获得锁的过程可以打断，<code>lockInterruptibly()</code>，如果在调用这个方法时，或者在这个方法阻塞的任意时刻，线程的中断位被置位，则该方法立即抛出<code>InterruptedException</code>；包括请求锁时可以设置最大等待时间：<code>tryLock(long,TimeUnit)</code>，在等待超时时会返回false。</p></li><li><p>目前与Lock紧密相关的几个类或接口有：<code>ReentrantLock</code> <code>Condition</code> <code>ReadWriteLock</code></p></li></ol></blockquote><h5 id="Lock接口的方法"><a href="#Lock接口的方法" class="headerlink" title="Lock接口的方法"></a>Lock接口的方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>lock()</code></p><p>请求获得锁。这个方法在无法获得锁时会阻塞，而且不能打断，所以稍微也有点危险。</p></li><li><p><code>void lockInterruptibly() throws InterruptedException</code></p><p>请求获得锁，如果方法被调用时线程已经被中断了，直接抛出<code>InterruptedException</code>。该方法在无法获得锁时会阻塞，但可以打断，打断时会抛出<code>InterruptedException</code>异常。</p></li><li><p><code>boolean tryLock()</code></p><p>尝试获得锁并立即返回。如果成功获得锁返回true，如果失败返回false。建议的用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line"><span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// manipulate protected state</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// perform alternative actions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>boolean tryLock(long time, TimeUnit unit) throws InterruptedException</code></p><p>效果和<code>void lockInterruptibly() throws InterruptedException</code>类似，阻塞时被打断会抛异常，时间到期后返回false。</p></li><li><p><code>Condition newCondition()</code></p><p>获得一个condition，在线程获得锁的时候，可以在返回的condition上调用<code>await()</code>方法，放弃锁，该方法返回时会重新获得锁。</p></li></ul><h5 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h5><p>就是一个可重入锁，实现了<code>Lock</code>接口的功能而已。</p><p>该锁的构造函数中有一个可选参数fair，如果将其设为true，则会在锁分配上偏爱那些长期得不到调度的线程。但该参数会导致较大的性能损失，只有在确有必要的时候，才应该使用该参数。</p><h5 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h5><p>读写锁维护了两个相关的Lock。这个接口只有两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读写锁的注释梗概：</p><blockquote><ol><li>在读写锁的实现里，只要没有写锁，读锁可以被多个线程获得，而写锁排除其他写锁和读锁。</li><li>读写锁需要保证内存的同步，即当我们获得一个读锁时，上一个写锁中进行的所有修改都要对这个读锁可见。</li><li>从理论上讲，采取读写锁的实现会有更好的并发性能表现，因为普通的锁在同一时刻只能被一个线程持有，而读写锁允许多个线程同时持有读锁。但实践中，这样的并发性能提升仅能在多处理器上观察到，并且受共享数据访问模式影响较大。</li><li>读写锁是否能够提高性能，很大程度上依赖于数据被读取与被修改的频率的差别、读写操作各自耗费的时间，以及数据上的竞争大小——即同时尝试获取读锁或者写锁的数量。比如，一个初始化后的集合，如果不经常修改，但经常被搜索，比如说字典，就是使用读写锁的完美场景。但是，如果更新频率比较高，那么大部分时间数据都会被排他的写锁锁定，这就只有有限的、甚至没有并发提升了。进一步讲，如果读操作本身耗时非常短，那么读写锁本身实现所带来的复杂度耗时，甚至消解了读并发所带来的性能提升。因此，必须提前针对场景进行性能测试，才能知道是否应当使用读写锁。</li><li>即使读写锁的基本概念十分直白，但仍然有很多细节上的决策需要不同的实现来决定。而实现上的不同也会影响不同的读写锁在一个程序中的表现。比如说：当一个写锁释放时，此时读锁和写锁同时请求，大多数实现会先把锁给写锁，因为写被认为是不频繁的操作，而个别实现会把锁给读锁，或者说有的实现就是按请求锁的顺序给；当有线程获得读锁、且此时有写锁在等待时，是否允许其他读锁加入锁争用，如果允许读锁竞争，可能会导致等待写锁的线程饿死，但只允许写锁，会导致读锁的并发性能下降；锁的可重入性，比如在线程获得写锁时，是否允许再获得读锁，或者一个读锁直接升级成写锁。总之这些实现的差别都有可能导致性能的差异，所以<strong>必须提前针对场景进行性能测试，才能知道是否应当使用读写锁。</strong></li></ol></blockquote><h5 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h5><p>根据构造函数中的fair参数不同，这个锁的表现有较大的差别。其注释梗概是：</p><blockquote><ol><li><p>当锁为非公平锁(默认情况)时，读写锁获得锁的顺序都是未定义的。但这个模式可以提供更高的吞吐量。</p></li><li><p>当锁为公平锁时。当一个锁释放时，等待时间最长的写锁会获得锁，除非此时有一批读锁等待的时间都超过了等待时间最长的写锁，那这些读锁会一起获得读锁。</p><p>当锁为公平锁时，假如一个写锁正在等待或者写锁已被某个线程获得，那么读锁都会被阻塞，尝试在这种情况下获取读锁的线程都必须等待下一个写锁获得并释放后，假如获得该写锁的线程放弃了锁，且一个或多个等待读锁的线程等待时间都超过了等待时间最长的写锁，那么这个或这些线程会获得读锁。</p><p>当锁为公平锁时，一个尝试获得写锁的线程会一直阻塞，直到读写锁都处于释放状态。</p></li><li><p>该锁允许读写锁重入，即获得读锁的线程可以继续获得读锁，获得写锁的线程继续获得写锁，同时，获得写锁的线程还可以继续获得读锁，但获得读锁的线程无法获得获得写锁。</p></li><li><p>只有写锁支持condition，而读锁不支持。</p></li><li><p>最多支持65535个递归写锁重入和65535个读锁。试图超过这个限制都将导致抛出一个Error。(这啥样的程序能超啊……)</p></li></ol></blockquote><p>同时，注释中给了两个很有意思的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">  Object data;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">  <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"> *</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rwl.readLock().lock();</span><br><span class="line">    <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">      <span class="comment">// Must release read lock before acquiring write lock</span></span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">      rwl.writeLock().lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Recheck state because another thread might have</span></span><br><span class="line">        <span class="comment">// acquired write lock and changed state before we did.</span></span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">          data = ...</span><br><span class="line">          cacheValid = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在获得写锁时可以获得读锁</span></span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rwl.writeLock().unlock(); <span class="comment">// 释放写锁，但仍然持有读锁。</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> *</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      use(data);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>读写锁最经典的使用场景是某种类型的collection上，特别是该集合需要足够大，读操作的频率远超写操作，而且读操作的时间超过了同步的负担。比如，下面这个例子：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RWDictionary</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Data&gt; m = <span class="keyword">new</span> TreeMap&lt;String, Data&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock r = rwl.readLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Data <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.get(key); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String[] allKeys() &#123;</span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.keySet().toArray(); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Data <span class="title">put</span><span class="params">(String key, Data value)</span> </span>&#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.put(key, value); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; m.clear(); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h5><p>条件有时候会被称为条件队列（但其实它没有什么先进先出的特性）或者条件变量。可以另一个线程在等待另一个线程执行时阻塞，直到被另一个线程通知可以继续运行。其方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"><span class="comment">// 对应Object的wait()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个无法被打断的wait(),即使中断标志位被置位仍然会等待，直到获得锁时才返回。</span></span><br><span class="line">  <span class="comment">// 返回时如果已经设置了中断标志位，则中断标志位不会清除。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面这三个方法类似于wait(long timeout)，只是参数上更加灵活了</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 对应Object的notify() 和 notifyAll() 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原子性、有序性与可见性"><a href="#原子性、有序性与可见性" class="headerlink" title="原子性、有序性与可见性"></a>原子性、有序性与可见性</h3><p><a href="https://www.jianshu.com/p/cf57726e77f2" target="_blank" rel="noopener">三大性质总结：原子性，有序性，可见性</a></p><ul><li><p>原子性</p><p><strong>一个操作是不可中断的，要么全部执行成功要么全部执行失败</strong>，不能再分了。一个原子操作总是线程安全的，因为其不可能被打断。虽然原子操作不需要加锁，但绝大部分操作都不是原子的，JAVA编程思想这本书建议：<strong>没有能力手写JVM的</strong>的程序员都不要尝试依赖原子性做到线程安全，该加锁加锁。</p></li><li><p>有序性</p><p>出于性能优化的原因，编译器和处理器会将指令尽兴重排序，也就会说，java程序的有序性是指：如果在本线程内观察，可以认为所有操作是有序的，但从另一个线程观察，则未必如此。有序性会影响线程安全，考虑下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>instance = new Singleton()</code>的行为并不是原子的，它至少可以拆为三个部分：1. 分配对象的内存空间；2.初始化对象；3.设置instance指向刚分配的内存地址。从调用new的线程观察，当new返回时，这三步都已经完成了，但实际上在JVM内部，可能会调换2与3的顺序，即先将instance指向内存空间，再初始化对象。此时这段代码有可能出现问题，即当线程A正在执行new操作时，刚好完成了new的第三步(第二步初始化还没完成甚至没有开始)，线程B进入了第一个判断，发现instance已经被赋值，不再是null，此时B将会得到一个未构造完成的instance，实际上不可用，这就是顺序性导致的线程安全问题。</p></li><li><p>可见性</p><p>指一个线程修改了共享变量以后，其他线程是不是可以立刻得知这个修改。</p></li></ul><p>为解决非原子的操作不被中途打断，因此有了锁机制，锁将保证其他线程无法进入需要不被中断的代码区，所以一个获得锁的线程总是能连续完成自己的工作不被打断。</p><p>而<strong>volatile</strong>关键词则能：</p><ol><li>禁止涉及到相关变量的指令重排，从而使一段代码更加有序。</li><li>强制处理器每次在读取数据时从主存中读取，并将结果写入主存。</li></ol><p>所以如果上述代码改成下面这样子，就能够禁止重排，避免错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br></pre></td></tr></table></figure><p>要注意的是，volatile关键词并不能保证原子性，所以多线程操作同一个变量，仍然需要加锁。</p><p>实际上，synchronized不仅可以保证方法或者代码块在运行，同一时刻只有一个方法进入临界区，同时还可以保证共享变量的内存可见性。</p><p><strong>上面的例子举得并不好，实际上sychronized关键字本身就能保证有序性，但网上都是这个例子，我也找不出更好的说明有序性的例子，所以权且以此举例。</strong></p><h3 id="锁的中高阶扩展知识"><a href="#锁的中高阶扩展知识" class="headerlink" title="锁的中高阶扩展知识"></a>锁的中高阶扩展知识</h3><p><a href="https://zhuanlan.zhihu.com/p/67372870" target="_blank" rel="noopener">知乎：Synchronized 实现原理</a></p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。</p><p>因此，引入了一种新的锁获得机制。在一般锁中，如果无法获得锁，线程就会进入阻塞状态，而在自旋锁中，如果请求锁的线程发现锁被占用，则（在一定时间内）一直循环尝试试图获得锁，进入一种<strong>忙循环</strong>状态，直到获取该锁为止。</p><p>曾经有个经典的例子来比喻自旋锁：A，B两个人合租一套房子，共用一个厕所，那么这个厕所就是共享资源，且在任一时刻最多只能有一个人在使用。当厕所闲置时，谁来了都可以使用，当A使用时，就会关上厕所门，而B也要使用，就得在门外焦急地等待，急得原地转圈，是为“自旋”。</p><p>虽然我们一般认为，忙循环是对CPU资源的一种浪费，但因为自旋锁避免了上下文调度开销，因此对于线程只会阻塞很短时间的场合时是有效的。</p><h4 id="适应自旋锁"><a href="#适应自旋锁" class="headerlink" title="适应自旋锁"></a>适应自旋锁</h4><p>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的时间不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><p>线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。<strong>有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</strong></p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>有些java的内置API使用了锁机制，比如StringBuffer、Vector（弃用）、HashTable（弃用），这时候虽然用户没有显式加锁，但是存在隐式的加锁操作。锁消除是一种编译器优化措施，即通过扫描，发现有些代码完全不可能存在并发问题，那就将这段代码中的加锁解锁操作全部去除以提高性能。比如说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLockEliminate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(s1);</span><br><span class="line">        sb.append(s2);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码里，StringBuffer是函数内部的局部变量，因此不可能出现多线程同步访问，也就没有资源竞争，但StringBuffer的append操作却在内部加了锁，这显然是一种性能浪费。所以在编译期就可以大胆把加锁操作全部取消以提高性能。</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>在大部分情况下，我们都希望同步块的作用范围越小越好，仅在确实需要操作共享数据时才尽兴同步，这样做的目的是尽可能缩小阻塞带来的性能损失，如果存在锁竞争，等待锁的线程也能尽快拿到锁。但在个别情况下，如果出现一系列的加锁、解锁操作，可能会导致不必要的性能损耗，所以引入了锁粗化的概念：</p><p>即将多个连续的加锁、解锁操作连接在一起，扩展成一个更大范围的锁，如一个vector在一个for循环中不断进行add操作，那么编译器就可以把加锁操作移到for循环以外。</p><p>####java对象头</p><p>这是一个准备知识。</p><p>因为在java中任意对象都可以作为锁，那么必然要有某种映射关系，来存储该对象和与他相关的锁、线程信息，比如哪个线程目前持有锁，哪些线程在等待等。java选择把这样的映射关系存储在对象头中(有时候是存储指向这样的映射关系的指针，总之通过对象头就可以找到锁信息)。</p><p>在JVM中，对象在内存中除了本身的数据外还会有个对象头，对于普通对象而言，其对象头中有两类信息：<code>mark word</code>和类型指针，另外对于数组而言还会有一份记录数组长度的数据。其中每一部分数据的长度根据虚拟机位数不同，分别是32位或者64位。</p><p>其中，对象头的<code>mark word</code>部分在锁机制中被复用，在标志位不同的时候代表不同的含义。下面是32位虚拟机的对象头在不同的锁状态下，分别代表以下含义：</p><p><img src="https://www.history-of-my-life.com/imgs-for-md/java对象头与锁20190613.jpeg" alt="java对象头"></p><p>其中是否偏向锁标志位和锁标志位共同指示当前对象代表的锁处于何种状态。如处于无锁状态，即该对象没有被用作锁，则该标志位分别是0，01，处于偏向锁状态则为1，01，处于轻量级锁和重量级锁时是否偏向锁标志被占用，靠锁标志位是00还是10来指示是轻量锁还是重量锁。当锁标志位是11时该对象头与锁状态无关，此处不讨论。至于不同锁状态下对象头的具体含义，在下文会有阐述。</p><h4 id="悲观锁、乐观锁与CAS操作"><a href="#悲观锁、乐观锁与CAS操作" class="headerlink" title="悲观锁、乐观锁与CAS操作"></a>悲观锁、乐观锁与CAS操作</h4><p>锁其实只是为了保证多线程操作下的数据安全，所以只要能做到这一点，从理论上都可以称为某种锁。但对于如何保证数据安全这一点上，也有两种经典的处理模式。</p><ul><li><p>悲观锁</p><p>悲观锁假设线程之间的竞争非常激烈，因此每一次操作都有可能产生冲突，所以它采取的策略是，每一次操作都先获得锁，操作完毕后释放锁，这样对一个数据同一时间都只有一个线程在操作，保证了安全性。悲观锁是个广义的概念，不仅应用于线程安全，还用于数据库安全等，假如一个数据库认为某些数据上的竞争非常激烈，那么他就会在每一次操作上加上事务，不允许其他数据操作(实际中事务还有很多级别，这是题外话)，这就可以认为是一种悲观锁。显然悲观锁的性能不会很好，在线程同步问题上，阻塞和调度线程需要内核态和用户态切换，而且还会导致CPU的上下文切换；在数据库领域，就是降低了并发数量。</p></li><li><p>乐观锁</p><p>为了缓解这个问题，推出了乐观锁。乐观锁的思想是，假设每次操作都没有竞争，我先做完我的工作，然后在写回的时候把我持有的数据oldValue和现在数据的主副本做对比，如果两个数据相等，那我认为这个数据没有其他线程操作过，如果不相等，我就再把数据从主副本载入，再做一次运算，再做一次对比。这是一个死循环，直到设置成功。写出代码大概是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object atmoticObject, <span class="keyword">long</span> valueOffset, <span class="keyword">int</span> addValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> atmoticObjectValue;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        atmoticObjectValue = <span class="keyword">this</span>.getIntVolatile(atmoticObject, valueOffset);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(atmoticObject, valueOffset, </span><br><span class="line">                         atmoticObjectValue, atmoticObjectValue + addValue));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> atmoticObjectValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>compareAndSwapInt</code>在CPU层面是个原子操作，其中offset是atmoticObject中value相对atmoticObject对象内存地址的偏移量，如果做完运算后，对比发现atmoticObjectValue的oldValue还等于内存中的数据，我们就假设这个数据从来没被修改过，然后就将该内存的值设为新值，如果这个值被修改了，那我们就必须回来重新取值、重新做一次比较。而这个<code>比较-如果相等就设置</code>的操作，就叫做<strong>CAS</strong>。<strong>CAS</strong>就是乐观锁的核心实现。</p><p>在数据库方面也有乐观锁的实现，即每条数据都带有一个version字段，写入时会检查并version，如果与持有的old version相同，就写入并同时自增version的值。</p><p>可见，乐观锁的思想和自旋锁是相同的，就是认为线程阻塞的切换消耗太大，超过了让线程忙循环一段时间的消耗，因此采取了让CPU忙循环的方式处理竞争问题。但这种方式显然都有一个问题，即当线程之间的竞争真的很激烈的时候，忙循环可能抢不到锁，最后还得走线程阻塞那条路，而CAS操作可能每次都发现值不一样，不得不不断循环，还不如加锁来的快。</p><p>因此，乐观锁适用于线程竞争不激烈的场合，性能表现较好，而悲观锁在线程竞争激烈的场合，其实效果更好。</p></li><li><p>CAS操作和ABA问题。</p><p><a href="https://www.jianshu.com/p/fb6e91b013cc" target="_blank" rel="noopener">深入浅出CAS</a></p><p>CAS操作有个重大的问题，就是它假设内存里的value与自己持有的oldValue相等，那么值就没有被修改过，但实际上有可能这个值原本为A，被某个线程修改为B后再修改为A，此时值其实已经修改，但会被认为没有修改过。</p><p>在数字计算中，这并不是问题，因为只要相等我就可以认为这个值没有被修改过，即使被修改过，说明其他线程计算的结果刚好是他，那和没有变没有区别，数据依然是安全的。</p><p>但维基百科中列出了一种情况，可能因为ABA问题导致错误，详见<a href="[https://zh.wikipedia.org/wiki/%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2#ABA%E9%97%AE%E9%A2%98](https://zh.wikipedia.org/wiki/比较并交换#ABA问题">维基：CAS与ABA问题</a>)</p><p>为解决ABA问题，可以在数据上加上版本号，于是即使value相同，但问题变成了1A2B3A，就不会被误认为值没有被修改过了。</p></li></ul><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p><a href="https://github.com/farmerjohngit/myblog/issues/12" target="_blank" rel="noopener">死磕synchronized关键字</a></p><p>即传统意义上的锁，这就是JDK1.6以前<code>synchronized</code>关键字操作的锁实现方式。利用操作系统底层的同步机制实现java中的线程同步。此时对象头中的<code>mark word</code>为指向堆中monitor对象的指针。</p><p>其实现包括入口集、等待集、owner等。这个上文已经阐述过了。与对象头的关系绘图如下：</p><p><img src="https://www.history-of-my-life.com/imgs-for-md/java重量级锁-对象头-20190613.png" alt="java重量级锁-对象头-20190613"></p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p><a href="https://www.cnblogs.com/kundeg/p/8422557.html" target="_blank" rel="noopener">从jvm源码看synchronized</a></p><p><a href="https://gorden5566.com/post/1019.html" target="_blank" rel="noopener">轻量级锁加锁&amp;解锁过程</a></p><p>JVM的开发者发现在很多情况下，在Java程序运行时，同步块中的代码都是不存在竞争的，不同的线程交替执行同步块中的代码。这种情况下，用重量级锁没有必要。因此JVM引入了轻量级锁的概念。线程在执行同步块之前，JVM会先在当前的线程的栈帧中创建一个<code>Lock Record</code>，其包括一个用于存储对象头中的 <code>mark word</code>（官方称之为<code>Displaced Mark Word</code>）以及一个指向对象的指针。下图右边的部分就是一个<code>Lock Record</code>。</p><p><img src="https://www.history-of-my-life.com/imgs-for-md/java轻量级锁-对象头1-20190613.png" alt="java-轻量级锁与对象头"></p><p>在轻量锁的实现下，一个线程获得了该对象的轻量级锁的标志就是，该锁对象对象头中的锁标志位为00，且前30位记录了线程栈中的Lock Record的地址。</p><ul><li><p>加锁过程</p><ol><li><p>在线程栈中创建一个<code>Lock Record</code>，将其<code>obj</code>（即上图的Object reference，也有教程称之为owner字段）字段指向锁对象。</p></li><li><p>直接通过<code>CAS</code>指令将<code>Lock Record</code>的地址存储在对象头的<code>mark word</code>中，如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。如果失败，则进入步骤3</p></li><li><p>检查线程是否已经持有该锁（锁对象的markWord指向的是不是当前现成的栈帧范围内），如果已经持有了，那就代表这是一次锁重入。则把此次重入时新建的<code>Lock Record</code>中的<code>Displaced Mark Word</code>设为null。之后结束。</p></li><li><p>如果发现并不是当前线程占有了锁，即出现了锁争用，此时将出现<strong>锁膨胀</strong>，即该锁升级为重量级锁，object对象头中的mark word被修改为重量级锁的格式，同时在堆中建立monitor数据结构。</p><p>值得注意的是，其实最新的实现中，即使发现了锁竞争，也会先自旋等待一下，如果等待不到再升级为重量级锁。</p></li></ol><p>这里比较难理解的一点是，其实线程每次尝试获得锁时都会在线程私有栈上创建一个新的<code>Lock Record</code>。</p></li><li><p>解锁过程</p><ol><li>找到最新的一个obj字段等于当前锁对象的<code>Lock Record</code></li><li>如果<code>Lock Record</code>的<code>Displaced Mark Word</code>为null，代表这是一次重入，将<code>obj</code>设置为null后什么也不做，退栈了事。</li><li>如果<code>Lock Record</code>的<code>Displaced Mark Word</code>不为null，说明这正是当前线程第一次获得该锁时的<code>Lock Record</code>，则利用CAS指令将对象头的<code>mark word</code>恢复成为<code>Displaced Mark Word</code>。如果成功就继续，否则膨胀为重量级锁后退出。(没搞明白为什么会失败，能想到的就是这个线程在运行时其他线程尝试获得锁失败，锁已经膨胀为重量级锁所以才失败？)</li></ol></li></ul><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>在更极端的情况下，虽然一个线程看起来有加锁的必要，但实际上这段代码在运行时只有一个线程在执行。从来没有第二个线程执行。</p><p>在这种情况下，其实连轻量级锁都用不到，因为轻量级锁在加锁和解锁过程中要用到多次CAS，这个操作也稍微有些耗时，因此丧心病狂的工程师创造了偏向锁这个概念。以应对这种虽然加了锁，但运行时只有单线程调用代码的情况。</p><p>当JVM启用了偏向锁模式（1.6以上默认开启），当新创建一个对象的时候，如果该对象所属的class没有关闭偏向锁模式，那新创建对象的<code>mark word</code>将是可偏向状态，此时<code>mark word中</code>的thread id（参见上文偏向状态下的<code>mark word</code>格式）为0，表示未偏向任何线程，也叫做匿名偏向(anonymously biased)。</p><ul><li><p>偏向锁的加锁</p><ul><li>当该对象第一次被线程获得锁的时候，发现是匿名偏向状态，则会用CAS指令，将<code>mark word</code>中的thread id由0改成当前线程Id。如果成功，则代表获得了偏向锁，继续执行同步块中的代码。否则说明其他线程也在操作这个对象的偏向锁并且那个线程成功了，则将偏向锁撤销，升级为轻量级锁。</li><li>当被偏向的线程再次进入同步块时，发现锁对象偏向的就是当前线程，会往当前线程的栈中添加一条<code>Displaced Mark Word</code>为空的<code>Lock Record</code>中，然后继续执行同步块的代码，因为操纵的是线程私有的栈，因此不需要用到CAS指令；由此可见偏向锁模式下，当被偏向的线程再次尝试获得锁时，仅仅进行几个简单的操作就可以了，在这种情况下，<code>synchronized</code>关键字带来的性能开销基本可以忽略。</li><li>当其他线程进入同步块时，发现已经有偏向的线程了，则会进入到<strong>撤销偏向锁</strong>的逻辑里，一般来说，会在<code>safepoint</code>中去查看偏向的线程是否还存活，如果存活且还在同步块中则将锁升级为轻量级锁，原偏向的线程继续拥有锁，当前线程则走入到锁升级的逻辑里；如果偏向的线程已经不存活或者不在同步块中，则将对象头的<code>mark word</code>改为无锁状态（unlocked），之后再升级为轻量级锁。</li></ul><p>所以偏向锁的逻辑是：当锁已经发生偏向后，只要有另一个线程尝试获得偏向锁，则该偏向锁就会升级成轻量级锁。</p></li><li><p>偏向锁的解锁</p><p>当有其他线程尝试获得锁时，是根据遍历偏向线程的<code>lock record</code>来确定该线程是否还在执行同步块中的代码。因此偏向锁的解锁很简单，仅仅将栈中的最近一条<code>lock record</code>的<code>obj</code>字段设置为null。需要注意的是，偏向锁的解锁步骤中<strong>并不会修改对象头中的thread id。</strong></p><p>因此如果锁已经偏向后另一个线程试图获取锁，就会立即发现此时其实并不是只有一个线程在操作锁，锁直接升为轻量级锁。</p></li></ul><p>偏向锁还存在批量重偏向与撤销的问题，太过复杂，不在这里描述，可以参考<a href="https://github.com/farmerjohngit/myblog/issues/12" target="_blank" rel="noopener">死磕synchronized关键字</a>的最后一节。</p><h4 id="锁的升级（锁膨胀）与降级"><a href="#锁的升级（锁膨胀）与降级" class="headerlink" title="锁的升级（锁膨胀）与降级"></a>锁的升级（锁膨胀）与降级</h4><p>一般来讲，一个synchronized所操作的对象上的锁会经历从无锁状态到偏向锁状态、轻量级锁到重量级锁的状态。在早期，锁只能膨胀而不能降级，但据那些拆OpenJDK源码的大神说，其实jdk8的实现中就有了锁降级机制。这个更复杂，还是不研究了。</p><h3 id="高级同步工具之阻塞队列"><a href="#高级同步工具之阻塞队列" class="headerlink" title="高级同步工具之阻塞队列"></a>高级同步工具之阻塞队列</h3><p>虽然我们在前面把这些锁的知识总结了七七八八，搞得很复杂。但实际上，负责人的java参考书都会说：无论是synchronized关键字，还是Lock&amp;Condition，都属于很贴近底层的原语，用的不好很容易挂自己。而使用由并发处理的专家实现的高级同步工具显然要方便和安全地多。</p><p>显然java也照顾到了菜鸡们的能力和感受，在jdk1.5中就推出了<code>java.util.concurrent</code>包，包含了很多高级线程同步工具。将底层程序员解放出来了。</p><p>这其中比较强大的一种工具就叫做阻塞队列。阻塞队列可以解决多线程下经典的生产者/消费者问题。通过队列作为线程之间传输数据的工具，生产者线程只管往队列中添加产品，而消费者只管取。阻塞队列本身保证存取过程是线程安全的，而因为产品的产生和消费都是在各自的线程里，一些变量不再需要共享，编写出线程安全的程序就容易一些。</p><p>BlockingQueue的接口方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>put</code>和<code>take</code>方法分别在队列已满和队列为空时会阻塞。其他方法就不介绍了。因为这些队列会在一些非阻塞的取接口中返回null表示队列中没有值，因此这些阻塞队列都不允许插入null值。</p><p>阻塞队列的具体实现很多，包括：</p><ul><li><p>ArrayBlockintQueue</p><p>构造时指定容量，并且可以设置是否需要公平性，公平性会偏爱长期得不到调度的线程，但也会降低性能。</p></li><li><p>LinkedBlockingQueue</p><p>构造时可以指定容量，但默认是没有边界，允许无限个对象放进来。这个不限制上限的同步阻塞队列，是java默认的线程池<code>ExecutorService</code>在一些消费者能力不足时引发OOM问题的罪魁祸首。以后提到线程池的时候会再说这个问题。</p></li><li><p>PriorityBlockingQueue</p><p>弹出时将优先级最高的数据弹出，放入的元素必须实现了Comparable接口，如果没有，则需要在构造函数中提供一个比较器。这个队列也是无界的。</p></li><li><p>BlockingDeque</p><p>接口。提供一个双向队列，相应的，它提供的方法里也有双向存取的方法。</p></li><li><p>DelayQueue</p><p>放在这个队列里的元素必须实现<code>Delayed</code>接口，在一个元素自带的延迟时间超时之前，这个元素无法通过各种取方式从这个队列中取出。(还没搞明白有啥用)</p></li><li><p>SynchronousQueue</p><p><a href="https://www.jianshu.com/p/b7f7eb2bc778" target="_blank" rel="noopener">SynchronousQueue使用实例</a></p><p>这是种奇怪的队列，即该队列上必须有一个consumer在等待的时候，put操作才能成功，否则一直阻塞，(如果使用offer，则直接返回false)。具体用途目前看了一些文章，都是在说在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了，这就可以在线城池没有线程在等待时offer操作直接返回false，以便线程池管理工具创建新的线程来完成工作，而如果线程池已经有了空闲线程，即<code>SynchronousQueue</code>队列有人在等着消费，那就offer成功。先不深究。</p></li><li><p>TransferQueue</p><p>这个有点像更灵活的<code>SynchronousQueue</code>，即当使用<code>transfer</code>方法时，必须有线程等到消费才能放入，而使用put时就更表现地像正常的<code>BlockintQueue</code>。</p></li></ul><p>总之，使用阻塞队列可以简化生产者/消费者模型，使线程不必自己处理复杂的同步问题，无论是生产者还是消费者线程，都只要简单put和take，就可以完成线程安全的存取操作，并且其自带的阻塞功能可以用于线程同步。是生产者/消费者模型很好的选择。</p><h3 id="高级同步工具之同步器"><a href="#高级同步工具之同步器" class="headerlink" title="高级同步工具之同步器"></a>高级同步工具之同步器</h3><h4 id="计数门闩-CountDownLatch"><a href="#计数门闩-CountDownLatch" class="headerlink" title="计数门闩(CountDownLatch)"></a>计数门闩(CountDownLatch)</h4><p>在某些场景下，主线程开启多个线程处理多个子任务，当各个子任务处理完毕后，主线程还要做一些合并工作。比如说使用了分治法的一些算法。</p><p>此时，主线程需要等待子线程任务完毕，这就是计数门闩使用的绝佳场景。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> throw InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(THREAD_NUM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != THREAD_NUM; ++i) &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> SomeRunable(countDownLatch));</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdownNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SomeRunable实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeRunable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch countDownLatch;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SomeRunable</span><span class="params">(CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do some real work</span></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栅栏-Barrier"><a href="#栅栏-Barrier" class="headerlink" title="栅栏(Barrier)"></a>栅栏(Barrier)</h4><p>像是一个可循环的计数门闩。考虑一个算法分为好几个阶段，每一个阶段都需要上一个阶段的所有线程都完成后才能进行，那么Barrier就比计数门闩要好用。更进一步的是，创建barrier时，可以传入一个Runable的对象作为栅栏所有线程都到达栅栏之后要执行的操作。</p><p>即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runable barrierAction = …;</span><br><span class="line">CyclicBarrier barrier = <span class="keyword">new</span> CycliBarrier(threadNums, barrierAction);</span><br></pre></td></tr></table></figure><p>这个动作执行完毕后，所有到达栅栏的线程才会继续执行。</p><h4 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h4><p>更高级的栅栏，允许改变不同阶段参与线程的个数。</p><h4 id="交换器-Exchanger"><a href="#交换器-Exchanger" class="headerlink" title="交换器(Exchanger)"></a>交换器(Exchanger)</h4><p>当两个线程在同一个数据缓冲区的两个实例上工作时可以使用交换器，典型的比如一个线程往缓冲区写数据，另一个在使用，采用交换器直接交换两个缓冲区，则效率更高一些，并且不必创建新的缓冲区。</p><h4 id="同步队列-SynchronousQueue"><a href="#同步队列-SynchronousQueue" class="headerlink" title="同步队列(SynchronousQueue)"></a>同步队列(SynchronousQueue)</h4><p>这是一种将生产者线程和消费者线程配对的机制，当一个线程在该队列上调用put方法时，他会阻塞一直到有消费者线程来取。反之亦然。与Exchanger不同的是，这个同步队列中数据传递方向是单向的。因为可以保证生产者线程总是要等到有消费者才返回，也可以作为一种同步工具。</p><h3 id="高级同步工具之原子类"><a href="#高级同步工具之原子类" class="headerlink" title="高级同步工具之原子类"></a>高级同步工具之原子类</h3><p><code>java.util.concurrent.atomic</code>包中提供了一些类，他提供的很多方法采用了很高效的机器级指令来保证操作的原子性，其实就是CAS。这些方法都可以安全地在多线程中进行自增和自减操作，但是在更高级的适用场合，仍然无法保证原子性，可能需要手动CAS。</p><p>假设我们要将<code>AtomicLong</code>的一个实例加10，则可能写出这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"><span class="comment">// in some thread</span></span><br><span class="line">atomicLong.set(atomicLong.get() + <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>但是因为这个set和get操作并不是原子的，因此并不安全。</p><p>要想线程安全地执行这个操作，应该像下面这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in some thread</span></span><br><span class="line"><span class="keyword">long</span> oldValue, newValue;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    oldValue = atomicLong.get();</span><br><span class="line">    newValue = oldValue + <span class="number">10</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (!atomicLong.compareAndSet(oldValue, newValue));</span><br></pre></td></tr></table></figure><p>看起来很眼熟，实际上这就是手动CAS了。依赖于compareAndSet的原子性，这个增加操作可以多线程安全地执行。然而手写这个while还是有点繁琐，所以在java 8中，Atomic增加了新的方法用于这种场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atomicLong.updateAndGet(x -&gt; x + <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">atomicLong.accumulateAndGet(<span class="number">10</span>,Math::addExact);</span><br></pre></td></tr></table></figure><p>但是要记住，Atomic系列类的底层实现是CAS，这种乐观锁机制在竞争激烈的情况下需要经常忙循环，性能急剧下降。所以Java8提供了<code>LongAdder</code>和<code>LongAccumulator</code>，<code>DoubleAdder</code>和<code>DoubleAccumulator</code>类，他在内部保存了多个变量（加数），其总和为当前值，这样就可以有多个线程更新不同的加数，而最后用sum返回结果。因此，在预估到竞争会很激烈时，用LongAdder的效果明显要好，LongAccumulator则可以提供一个运算函数，做加法以外的操作。</p><h3 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h3><p>如果多线程要并发的操作一个集合，可能会破坏集合的内部结构。比如说，HashMap在桶内红黑树重排时，如果遇到线程切换，其他线程的操作可能会破坏红黑树结构，导致发生发生异常或者指针出现循环。</p><p>线程安全的集合是指，这些集合在多线程下操作绝对不会破坏其内部结构。而且他们内部使用了很复杂的算法，允许对集合的部分进行加锁，从而允许并发地访问，甚至写入集合的不同部分，使竞争最小化，以提高并行率。比如并发的哈希表，默认情况下允许16个写线程同时执行。</p><p>线程安全的集合包括：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、ConcurrentLinkedQueue等。</p><p>但要注意的是，就如同上面说的原子类也不能保证set之类函数的原子性，需要手写CAS，线程安全的集合只是保证了多线程操作不会破坏集合的内部结构，而绝不是说保证了原子性，比如这样的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Long oldValue = map.get(word);</span><br><span class="line">Long newValue = oldValue == <span class="keyword">null</span> ? <span class="number">1</span>: oldValue + <span class="number">1</span>;</span><br><span class="line">map.put(word, newValue); <span class="comment">// Error-might not replace oldValue</span></span><br></pre></td></tr></table></figure><p>多线程执行下不能确定结果是什么，因此安全的方法还是手写CAS：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    oldValue = map.get(word);</span><br><span class="line">    newValue = oldValue = <span class="keyword">null</span> ? <span class="number">1</span> : oldValue + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (!nap.replace(word, oldValue, newValue));</span><br></pre></td></tr></table></figure><p>也可以通过java8的新接口来替代这个手工CAS：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.compute(word, (k, v) -&gt; v = <span class="keyword">null</span> ? <span class="number">1</span>: v + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>或者更进一步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.computelfAbsent(word , k -&gt; <span class="keyword">new</span> LongAdderO) _increment() ;</span><br></pre></td></tr></table></figure><h3 id="Runnable、Callable、Future、FutureTask"><a href="#Runnable、Callable、Future、FutureTask" class="headerlink" title="Runnable、Callable、Future、FutureTask"></a>Runnable、Callable、Future、FutureTask</h3><p>上文已经基本把线程以及线程安全的问题挖的差不多了，但搞到现在，才发现从来没有介绍怎样让Java跑起来一个多线程的程序……</p><p>在比较古老的时期，多线程需要继承Thread对象，直接覆盖Thread的run方法，把业务代码写在run里面，但这种把任务和任务调度混在一起的方法并不是一个好的实现，所以很快这种做法就被抛弃了，具体的业务代码被包装到一个Runnable对象中去，所以要写一个多线程的程序，基本上类似这种写法(在不使用线程池时)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeRunable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是线程"</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SomeRunable());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在lambda表达式的加持下，代码可以写成下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"我是线程"</span> + Thread.currentThread().getName()));</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，首先是实现<code>Runnable</code>接口，在其<code>run()</code>方法中写上业务代码，然后再将该对象传入Thread的构造函数中，再调用<code>thread.start()</code>方法，线程就可以启动。</p><p>但是，Runable对象有个小缺憾，就是没有返回值，如果没有返回值的话，线程想向外传递数据就只能通过其他手段，比如在Runnable构造方法中传入一个集合之类的。这有时候不太方便。因此在java1.5中出现了新的类，允许线程的业务代码返回结果，这就是Callable接口，与Runnable只有一个run方法类似，这个接口只有一个call方法。</p><p>但这里就出现了两个问题，一个是Thread的构造函数只支持传入Runable，并且没有提供返回值的接口，call方法的返回值存到哪里去，又从哪里获得呢？而且，因为线程是异步的，我怎么知道什么时候返回值准备好了呢？</p><p>这时候就出现了一个适配器，名为<code>FutureTask</code>，它同时实现了Runable和Future接口，接受一个Callable作为构造函数的参数，于是问题得到了解决，代码可以写成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Thread.currentThread().getId();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Long sth = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            FutureTask&lt;Long&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> SomeCallable());</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(task);</span><br><span class="line">            thread.start();</span><br><span class="line">            sth += task.get();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sth);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中Future保存了异步计算的结果，Future对象的所有者在计算结果准备好之后就可以获得它。Future的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancel</span> <span class="params">(<span class="keyword">boolean</span> maylnterrupt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中get()会阻塞一直到计算完成，第二个方法如果超时就会抛出<code>TimeoutException</code>。isDone可以检测计算是否完成，而cancel可以请求取消计算，如果计算还没开始则不再开始，如果计算正在运行且mayInterrupt参数为true，则线程被中断(记住线程的中断只是个置位，具体线程如何处理还看具体线程)</p><h3 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h3><p><a href="https://www.ibm.com/developerworks/cn/java/j-jtp11137.html" target="_blank" rel="noopener">应用 fork-join 框架</a></p><p><a href="https://www.infoq.cn/article/fork-join-introduction" target="_blank" rel="noopener">聊聊并发：Fork/Join框架介绍</a></p><h4 id="Fork-Join的设计思路"><a href="#Fork-Join的设计思路" class="headerlink" title="Fork/Join的设计思路"></a>Fork/Join的设计思路</h4><p>上面第一篇文章，从编程语言要适应硬件发展的相适应的角度，详细阐述了<code>Fork/Join</code>框架诞生的历史和原因。文中说到，现代的CPU已经能在硬件层面提供更多的内核，但更多的内核如果没有相应的更细粒度的任务来驱动，那么处理器将出现空闲的风险，即使还有很多工作要处理。而<code>Fock/Join</code>就是用于表示更细粒度算法的框架。</p><p>所谓的<code>Fork/Join</code>，其实是一种分治法。即将一些更大的任务划分为相互隔离的细粒度的问题，分别交由不同的线程完成，之后再将这些线程的结果合并在一起。写出伪代码类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public T doTask(task) &#123;</span><br><span class="line">    if (scale of task is small enough) &#123;</span><br><span class="line">        slove it;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        split into small tasks</span><br><span class="line">        doTask(childTask1);</span><br><span class="line">        doTask(childTask2);</span><br><span class="line">        doTask...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个框架绘图出来类似这样：</p><p><img src="https://www.history-of-my-life.com/imgs-for-md/java-fork-join1-20190614.png" alt="fork/join框架"></p><p>之所以叫fork/join模型，是因为先fork出一些子任务来，然后再将这些子任务的结果join在一起。</p><p>这样的一个任务模型，如果要用原生的java线程来完成也不是不可以，其实就可以用上面的那套Callable/Future工具来做，利用Future的<code>get()</code>方法阻塞来进行线程同步，不断拆分任务，交给一个callable对象完成，等待future的结果，再合并起来。</p><p>这样折腾要耗费不少精力，容易出错，而且仔细思考上面的模型，如果一个线程提前完成了任务，那么因为必须等待其他线程到达join点，即使它没工作了，也只能无所事事，所以这显然是一种浪费。另外，其实在这个模型里，线程在到达join之前相互之间并不会阻塞，使用传统的加锁方法需要考虑线程阻塞的问题，也有额外的开销。针对这两个问题，那帮高级工程师采用了两周手段。</p><ul><li><p><strong>工作窃取（work stealing）</strong></p><p>每个工作线程都有自己的工作队列，一般使用双端队列来实现。当一个任务派生出新的线程时，它将自己放到deque的头部，当一个任务执行与另一个未完成任务的合并操作时，它将另一个任务推到队列头部并执行，当线程的任务队列为空时，它将尝试从另一个线程的尾部窃取一个任务。</p><p>之所以用双端队列，是因为双端队列可以减少争用，一个线程总是从队首取任务，而窃取任务的另一个线程总是从队尾窃取任务，这样就极少发生争用。而且使用deque暗含着后进先出，即当前线程总是处理刚压进去的，更琐碎一些的任务，而窃取线程总是能拿到更早压进去的，更大块的任务，这样就可以在窃取到以后再拆分任务，避免了多次窃取导致的成本。</p></li><li><p><strong>阻塞优化</strong></p><p>因为线程之间除了工作窃取并不发生争用，因此线程在绝大部分情况下不会发生阻塞，于是在类库里一些线程同步操作被精心重新设计了。最大限度减少了争用。</p></li></ul><h4 id="Fork-Join的使用步骤"><a href="#Fork-Join的使用步骤" class="headerlink" title="Fork/Join的使用步骤"></a>Fork/Join的使用步骤</h4><ol><li><p><strong>分割任务</strong></p><p>要求子任务之间是独立的，相互不干扰的。有时候经过分割子任务还是很大，那就递归划分，直到任务足够小，再实际处理之。</p></li><li><p><strong>执行任务并合并结果</strong></p><p>分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</p><p>为此，我们需要创建Fork/Join任务的类，一般来说，我们继承下面两个子类。</p><ul><li>RecursiveAction。用于没有返回结果的任务。</li><li>RecursiveTask。用于有返回结果的任务。</li></ul><p>同时，我们需要一个池来维护这些任务。</p><ul><li><p>ForkJoinPool ：ForkJoinTask 需要通过 ForkJoinPool 来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</p><p>他有三个主要方法：</p><ol><li>execute：异步执行，没有返回结果；</li><li>invoke、invokeAll：异步执行，阻塞直到任务完成后返回。</li><li>submit：异步执行，并立即返回一个Future对象。</li></ol></li></ul></li></ol><p>来段代码。比如求一大堆数相加、求一群数字的最大值等等，以求和为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX = <span class="number">1000000000L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> THRESHOLD = <span class="number">1000L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinTask</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        Long sum = forkJoinPool.invoke(<span class="keyword">new</span> ForkJoinTask(<span class="number">1</span>, MAX));</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        System.out.println(System.currentTimeMillis() - start + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            ForkJoinTask task1 = <span class="keyword">new</span> ForkJoinTask(start, mid);</span><br><span class="line">            task1.fork();</span><br><span class="line"></span><br><span class="line">            ForkJoinTask task2 = <span class="keyword">new</span> ForkJoinTask(mid + <span class="number">1</span>, end);</span><br><span class="line">            task2.fork();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Fork-Join的异常处理"><a href="#Fork-Join的异常处理" class="headerlink" title="Fork/Join的异常处理"></a>Fork/Join的异常处理</h4><p>ForkJoinTask 在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以 ForkJoinTask 提供了 isCompletedAbnormally() 方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过 ForkJoinTask 的 getException 方法获取异常。使用如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(task.isCompletedAbnormally())</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(task.getException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getException 方法返回 Throwable 对象，如果任务被取消了则返回 CancellationException。如果任务没有完成或者没有抛出异常则返回 null。</p><h4 id="Fork-Join的适用场景"><a href="#Fork-Join的适用场景" class="headerlink" title="Fork/Join的适用场景"></a>Fork/Join的适用场景</h4><p>首先要任务能够被切分为子任务，而且数据集要足够大，并且每个元素处理的成本都要比较高，才能补偿建立fork/join框架所消耗的成本，而且要合理设置阈值，不能太大也不能太小，阈值太小则线程建立太多，抵消了并行运算带来的好处，太大则不能充分利用硬件和并行带来的好处。</p><h3 id="Future、CompletionStage与CompleteableFuture"><a href="#Future、CompletionStage与CompleteableFuture" class="headerlink" title="Future、CompletionStage与CompleteableFuture"></a>Future、CompletionStage与CompleteableFuture</h3><p>Future提供了一种延迟获得结果的方法，但是Future提供的方法比较单一，而且如果我们要用程序语言表达：当一个线程结束以后，我们用它的结果再做一些工作这样的场景时，可能需要先用一个Future等待结果，然后用get等待结果，再将结果传入新的线程。这样的操作会异步、阻塞、再异步、再阻塞，显然很不优雅。如果之后的操作也是异步的，这样就有非常麻烦的线程同步开销。</p><p>因此，在java8中引入了新的异步执行接口，<code>CompletionStage</code>，以及该接口的实现类<code>CompleteableFuture</code>，实际上，<code>CompleteableFuture</code>同时实现了<code>CompletionStage</code>和<code>Future</code>接口，因此在一系列操作之后，依然可以用Future的get()等方法来获得结果。</p><h4 id="CompletionStage"><a href="#CompletionStage" class="headerlink" title="CompletionStage"></a>CompletionStage</h4><p>注解摘录：</p><blockquote><p>一个Stage可能就是一个异步的计算，它在等待另一个stage的action完成后，执行某个动作或者执行某个结果。一个stage在它的运算完毕时就认为结束了，但是它的结束可能会触发依赖它的其他stage开始运行。这个接口定义的方法其实只采用了一些基本的形式，但是这些基本形式的展开和组合有可能构成一些非常有用的编程模式。</p><p>一个Stage所执行的计算，可以是一个函数、一个消费者，或者一个Runnable对象。这取决于他们是否接收参数作为输入，以及是否有返回值。比如说，可能会写出这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; stage.thenApply(x -&gt; square(x))</span><br><span class="line">&gt;   .thenAccept(x -&gt; System.out.print(x))</span><br><span class="line">&gt;   .thenRun(() -&gt; System.out.println());</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>大部分的方法都是对一个stage的运算结果起作用，但是只有<code>compose()</code>方法是作用于stage本身。即大部分方法可能都返回一个result，但compose()方法返回一个<code>CompleteableFuture</code></p><p>在一些方法中，允许传入自定义的Executor(执行器，线程池的一个抽象)，如果传入了自定义的Executor，则stage的线程行为可能会被Executor改变，甚至完全不允许并行。在CompleteableFuture的实现中，这个Executor是<code>ForkJoinPool.commonPool()</code></p><p>一个stage的开始可能会被一个stage的完成触发，或者需要两个stage都完成，或两个stage中的一个完成即可触发。依赖于一个stage的新stage可以用<code>then</code>开头的方法来触发，而依赖于两个stage的新stage，则根据需要使用用<code>runAfterBoth()</code>或者<code>runAfterEither()</code>方法，以及这些方法的变种来触发。这些函数都接受另一个Stage作为一参数，一个函数、一个消费者，或者一个Runnable对象作为二参数。</p><p>有几种途径为stage注册最终的回调函数，即当整个执行链执行完毕后应该做哪些工作。</p><ul><li><p><code>whenComplete()</code></p><p>它接受一个回调函数action作为参数，当前stage完成时，执行这个action，返回一个新的Stage，这个新的stage中持有之前stage调用链的结果(和异常)。这个action接受上个stage的结果输出和异常。</p><p>如果action本身抛出了异常，那么假如之前的stage已有异常，那么最终的future持有的异常仍然是之前stage的异常，如果之前的stage没有异常，那么最终future持有的异常就是action抛出的异常。</p><p>它的声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="keyword">public</span> CompletionStage&lt;T&gt; whenComplete</span><br><span class="line">&gt;           (BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>  action是一个consumer，没有返回值。</p><ul><li><p><code>handle()</code></p><p>handle()就更加高大上一点，它接受的是一个有返回值的回调函数作为参数，返回一个新的stage，这个回调函数也接受上个stage的结果输出和异常。它可以返回一个新的result。</p><p>它的声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; handle</span><br><span class="line">&gt;           (BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>  注意其参数是一个BiFunction，可以有返回值，而<code>whenComplete()</code>的参数是一个BiConsumer，没有返回值。</p><ul><li><p><code>exceptionally()</code></p><p>注册一个回调函数，其接受一个Throwable作为参数，返回一个stage，假如之前的运算出现异常，则该回调函数被调用，该回调函数可以返回一个与之前的stage同类型的result，如果之前的stage正常完成，那么这个回调函数不会被调用。</p><p>这个方法可以用于以下场景：假如某个工作正常完成，那么返回一个正常完成的值，如果出现异常，返回一个其他值。比如说：假如不出错，返回1，出异常了就调用回调函数，可能返回一个0。以使接下来的stage无论当前stage是否异常都可以正常运行。</p></li></ul><p>对于上面这两个方法来说，无论前面的操作正常进行了还是出异常了，回调函数都会被调用，如果出异常了，那么result为null，如果正常结束，那么exception参数为null。</p><p>如果调用链中某一环发生异常，那么依赖于该环节结果的所有stage都会以异常状态结束，并且会返回一个CompletionException，将最先产生的异常作为cause，如果一个环节的完成是用both方法组合起来的，并且both的两个环节都异常了，那么将随机有一个cause，如果是用either组合起来的，且其中有一个环节异常了，那么不能保证最后有没有cause。</p><p>在运算完成之前，都可以调用<code>complete(T value)</code>提供一个值，使当前的stage立即结束，并返回提供的值。但如果stage已经正常结束，则不会使用这个值。</p></blockquote><p>CompletionStage的每一个方法都有异步的重载版本，以及异步+自提供Executor的重载版本。每一个stage都有两种结束状态，正如线程有两种状态一样：正常结束、未捕获的异常结束。</p><p><code>CompletionStage</code>有一系列重要的方法，如果忽略各种异步、提供Executor的重载版本，大概可以梳理出以下几个系列，在这些方法的注解中，我们称调用这些方法的stage为<strong>上一个stage</strong>。</p><ul><li><p><code>public &lt;U&gt; CompletionStage&lt;U&gt; thenApply(Function&lt;? super T,? extends U&gt; fn);</code></p><p>返回一个stage，该stage将在上个stage正常结束后运行，执行提供的fn，并且将上个stage的结果作为参数。</p></li><li><p><code>public CompletionStage&lt;Void&gt; thenAccept(Consumer&lt;? super T&gt; action)</code></p><p>返回一个stage，当上一个stage正常结束后，执行提供的action，并且将上个stage的结果作为参数。</p></li><li><p><code>public CompletionStage&lt;Void&gt; thenRun(Runnable action)</code></p><p>返回一个stage，当上一个stage正常结束后，执行提供的action。</p></li><li><p><code>public &lt;U,V&gt; CompletionStage&lt;V&gt; thenCombine</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletionStage&lt;V&gt; thenCombine</span><br><span class="line">        (CompletionStage&lt;? extends U&gt; other,</span><br><span class="line">         BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn);</span><br></pre></td></tr></table></figure><p>返回一个stage，当上一个stage和other都正常结束时，把两个stage的结果作为参数传入fn中，调用fn。</p></li><li><p><code>public &lt;U&gt; CompletionStage&lt;Void&gt; thenAcceptBoth</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;Void&gt; thenAcceptBoth</span><br><span class="line">        (CompletionStage&lt;? extends U&gt; other,</span><br><span class="line">         BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action);</span><br></pre></td></tr></table></figure><p>返回一个stage，当上一个stage和other都正常结束时，把两个stage的结果作为参数传入action中。</p></li><li><p><code>public CompletionStage&lt;Void&gt; runAfterBoth(CompletionStage&lt;?&gt; other,Runnable action);</code></p><p>返回一个stage，当上一个stage和other都正常结束时，运行action</p></li><li><p><code>public &lt;U&gt; CompletionStage&lt;U&gt; applyToEither</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; applyToEither</span><br><span class="line">        (CompletionStage&lt;? extends T&gt; other,</span><br><span class="line">         Function&lt;? <span class="keyword">super</span> T, U&gt; fn);</span><br></pre></td></tr></table></figure><p>返回一个stage，当上一个stage或other中任意一个正常结束时，以他的结果调用fn。要注意的是，这里的other stage返回值必须和上一个stage返回值一致。</p></li><li><p><code>public CompletionStage&lt;Void&gt; acceptEither (CompletionStage&lt;? extends T&gt; other, consumer&lt;? super T&gt; action);</code></p><p>返回一个stage，当上一个stage或者other中任意一个正常结束时，以他的结果调用action。</p></li><li><p><code>public CompletionStage&lt;Void&gt; runAfterEither(CompletionStage&lt;?&gt; other, Runnable action);</code></p><p>返回一个stage，当上一个stage或other中任意一个正常结束时，调用action。</p></li><li><p><code>public &lt;U&gt; CompletionStage&lt;U&gt; thenCompose</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; thenCompose</span><br><span class="line">        (Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn);</span><br></pre></td></tr></table></figure><p>其功能非常类似于<code>thenApply</code>，也是返回一个stage，当上一个stage完成时，以上一个stage的返回值作为参数调用fn，但该fn返回一个<code>CompletionStage</code>，也就是该方法的返回值。</p><p>它和<code>thenApply</code>之间的区别，就好像stream的<code>map()</code>和<code>flatMap()</code>一样。</p></li><li><p><code>public CompletionStage&lt;T&gt; exceptionally(Function&lt;Throwable, ? extends T&gt; fn);</code></p><p>已如上述。</p></li><li><p><code>public CompletionStage&lt;T&gt; whenComplete(BiConsumer&lt;? super T, ? super Throwable&gt; action);</code></p><p>已如上述。</p></li><li><p><code>public &lt;U&gt; CompletionStage&lt;U&gt; handle((BiFunction&lt;? super T, Throwable, ? extends U&gt; fn))</code></p><p>已如上述。</p></li><li><p><code>public CompletableFuture&lt;T&gt; toCompletableFuture();</code></p><p>就是返回和上一个stage一样的结果，如果上一个stage已经完成，可能就返回上一个stage，如果没完成，可能返回一个新的stage，但其持有的值还是一样的。其用途没搞清楚。</p></li></ul><h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><p>这是jdk包中对<code>CompletionStage</code>的唯一实现。正如stage一样，它可以组合各种同步或者异步任务，总之我们可以用它来串一串任务，并在最后直接用<code>whenComplete()</code>完成消费。或者把它像Future一样用，使用<code>get()</code>阻塞地获得最终结果。</p><p>关于<code>CompleteableFuture</code>的用法，可以见<a href="https://medium.com/@Mumuksia/completablefuture-practical-guide-e4564f332f83" target="_blank" rel="noopener">CompletableFuture practical guide</a></p><p>简单地讲，一般都是用它的几个静态方法来构建一个<code>CompleteableFuture</code>，之后链式调用其方法来做后续操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                       Executor executor)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   Executor executor)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt; <span class="title">anyOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">completedFuture</span><span class="params">(U value)</span></span></span><br></pre></td></tr></table></figure><p>这些方法是比较正常的构造一个CompleteFuture的办法，之后就可以愉快地调用链了。</p><p><code>CompletableFuture</code>中有一些<code>CompletionStage</code>中没有的方法，包括：</p><ul><li><p><code>allOf(CompletableFuture&lt;?&gt;... cfs)</code></p><p>返回一个stage，该stage当所有参数中的cfs都完成后才返回。</p></li><li><p><code>anyOf(CompletableFuture&lt;?&gt;... cfs)</code></p><p>返回一个stage，该stage当参数中提供的cfs有一个完成后就返回。</p></li></ul><p>但有一些<strong>Bad practice</strong>，如下：</p><ol><li>不要搞一长串的调用链，写时一时爽，debug火葬场。</li><li><code>get()</code>and<code>join()</code>方法最好不要调用，这些能够阻塞当前线程的调用，直到当前的<code>CompletableFuture</code>完成。</li></ol><p><code>CompletableFuture</code>因为实现了两个接口，而且有一些新的方法，因此在实例化时也经常直接实例化一个<code>CompletableFuture</code>，而不是<code>CompletionStage</code></p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>一个线程的生命周期包括创建线程、执行线程任务、销毁线程。记他们所需要的时间分别为T1、T2、T3。在很多时候，线程需要频繁处理一些生命周期非常短的任务，也就是说，T2的时间很短。在这种情况下，创建和销毁线程所需要的时间可能远远超过任务执行的时间。在这种情况下，使用线程池就更加合适。</p><p>线程池在Java中的抽象是<code>ExecutorService</code>，其顶级接口是<code>Executor</code>，但是真正的线程池接口还是<code>ExecutorService</code>，所以在代码里一般都直接用<code>ExecutorService</code>，写出这样的代码来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = Executors.newFixedThreadPool(<span class="keyword">int</span> nThreads);</span><br></pre></td></tr></table></figure><p>一般来说，我们使用线程池调度算法的具体场景类似下面这段code</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkService</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ServerSocket serverSocket;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService pool;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NetworkService</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">int</span> poolSize)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">    pool = Executors.newFixedThreadPool(poolSize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// run the service</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        pool.execute(<span class="keyword">new</span> Handler(serverSocket.accept()));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Socket socket;</span><br><span class="line">  Handler(Socket socket) &#123; <span class="keyword">this</span>.socket = socket; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// read and service request on socket</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就开始使用线程池了。那接下来详细观察一下线程池</p><h4 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h4><p>还是先来注解摘抄：</p><blockquote><p>这是一个Eexcutor，提供专门管理Runable和Callable的方法。</p><p>ExecutorService可以被<code>shutdown</code>，shutdown之后该executor就不在接受新的任务。有两种shutdown方法可以关闭一个executor，其中<code>shutdown()</code>就是简单地不再接受新的任务。而<code>shutdownNow()</code>则不仅不接受新的任务，而且正在等待的所有任务都会取消执行，正在执行中的任务都会尝试停止。当终止时，一个executor保证没有正在执行的任务，没有正在等待执行的任务，并且没有新的任务可以提交。</p><p>一个不用的executor必须被shutdown，这样它占用的资源才有可能被回收。</p><p>Executor提供两个主要的方法来管理任务。一个是<code>void execute(Runnable runable)</code>，一个是<code>Future&lt;T&gt; submit(Callable&lt;T&gt; callable)</code>。</p><p>方法<code>invokeAny()</code>和<code>invokeAll()</code>提供了一种通用的管理任务的方法，即一次提交一大批任务，等待他们中有一个完成，或者都完成。<code>ExecutorCompletionService</code>可以用来自定义这两个方法。</p><p><code>Executors</code>是一个工厂类，用来产生各种合适的Executor。</p></blockquote><p>一个ExectorService有以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;<span class="comment">// 返回正在等待中的任务(该方法会取消正在等待任务的执行)</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;<span class="comment">//该方法扩展于Executor接口</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;<span class="comment">// Runable结束后返回result</span></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);<span class="comment">// future的get()会阻塞到runnable执行完后，返回null</span></span><br><span class="line"></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br></pre></td></tr></table></figure><p>具体不赘述。</p><h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><p>这就是JDK提供的，方便生产线程池给我们用的工厂类。可以生产<code>Executor</code>， <code>ExecutorService</code>， <code>ScheduledExecutorService</code>、<code>ThreadFactory</code>和一些定义在<code>Executors</code>内部的<code>Callable</code></p><p>其方法即注解如下(以下方法声明都忽略了<code>public static</code>修饰符)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 产生一个固定线程数量的线程池，当线程数量达到上限以后，新提交的任务将被放到一个无界阻塞队列中</span></span><br><span class="line"><span class="comment">* 当一个线程因为异常而死亡时，一个新的线程会创建来接替他的工作。</span></span><br><span class="line"><span class="comment">* 因为使用了无界队列，在消费者速度赶不上生产者速度时，任务会在队列中一直堆积，直到OOM</span></span><br><span class="line"><span class="comment">* 生产的Executor需要调用shutdown()显式关闭</span></span><br><span class="line"><span class="comment">* 实际产生一个ThreadPoolExecutor实例，使用的无界阻塞队列是LinkedBlockingQueue</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用给定ThreadFactory生产线程。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                 ThreadFactory threadFactory)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 产生一个维护足够数量的线程以支持参数指定并行级别的线程池，而且可能会使用多个队列来降低竞争。</span></span><br><span class="line"><span class="comment">* 该线程池的实际线程数量可能会动态调整，并且不保证任务执行顺序。</span></span><br><span class="line"><span class="comment">* 实际返回一个ForkJoinPool实例，使用的无界阻塞队列是LinkedBlockingQueue</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ExecutorService <span class="title">newWorkStealingPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用运行时可用处理器数量作为并行级别。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 生产一个只有一个线程的线程池，以串行执行任务。</span></span><br><span class="line"><span class="comment">* 返回一个ThreadPoolExecutor的装饰器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 生产一个线程池，其线程数量上限是Integer.MAX_VALUE。一般没事别用这个线程池。</span></span><br><span class="line"><span class="comment">* 一个线程至少占用1M资源，无限创建线程将会OOM</span></span><br><span class="line"><span class="comment">* 返回一个ThreadPoolExecutor</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 产生一个执行定期任务的线程池。以执行定期任务或者在一定delay后执行任务</span></span><br><span class="line"><span class="comment">* corePoolSize是指线程池中最小线程数量，即使他们处于空闲状态</span></span><br><span class="line"><span class="comment">* 返回一个ScheduledThreadPoolExecutor</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>;</span><br><span class="line"><span class="function">ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">* 产生只有一个线程的定期任务线程池。</span></span></span><br><span class="line"><span class="function"><span class="comment">* 返回一个ScheduledThreadPoolExecutor的包装器。</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br><span class="line"><span class="function">ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span>;</span><br><span class="line">ScheduledExecutorService </span><br><span class="line">newSingleThreadScheduledExecutor(ThreadFactory threadFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个Executor的装饰器，以防止用户通过将ExecutorService Cast成为具体类型</span></span><br><span class="line"><span class="comment">* 之后再修改线程池的配置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ExecutorService <span class="title">unconfigurableExecutorService</span><span class="params">(ExecutorService executor)</span></span>;</span><br><span class="line"><span class="function">ScheduledExecutorService <span class="title">unconfigurableScheduledExecutorService</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  ScheduledExecutorService executor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个默认的线程工厂。</span></span><br><span class="line"><span class="comment">* 实际上该接口只有一个方法，Thread newThread(Runnable r);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ThreadFactory <span class="title">defaultThreadFactory</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个线程工厂，该线程工厂除了做defalutThreadFactory的工作以外，还额外地将新线程</span></span><br><span class="line"><span class="comment">* 的访问控制上下文和contextClassLoader上下文设为和调用该privilegedThreadFactory的</span></span><br><span class="line"><span class="comment">* 线程的相关内容一致。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ThreadFactory <span class="title">privilegedThreadFactory</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>一个ExecutorService，它使用自己维护的多个线称中的一个来完成提交到它的任务。</p><p>线程池解决了两个问题，一个是它通常能够通过降低单任务的施法前摇和后摇来缩短一个任务的执行时间，另一个是它可以协助管理执行一组任务所需要的资源，包括线程本身占用的资源等等。</p><p>在大部分时间里，我们都可以使用<code>Executors</code>这个工厂类来创建各种各样的<code>ThreadPoolExecutor</code>，但如这篇文章所述：<a href="https://zhuanlan.zhihu.com/p/32867181" target="_blank" rel="noopener">一个线程池误用引发的血案</a>，该工厂产生的线程池使用的都是无界队列来存放一时无法处理的任务，当任务的生产速度超过消费速度就会引起任务积压，最终导致OOM崩溃，而不限制线程数量的线程池，其默认线程数量上限是<code>Integer.MAX_VALUE</code>，在上述消费者能力不够的情况下会引起无限开线程，线程本身需要的资源导致OOM。</p><p>因此，包括阿里巴巴JAVA开发手册在内，一些JAVA语言的指导都要求不要使用<code>Executors</code>工厂类创建的线程池，而自己去创建线程池。ThreadPoolExecutor的注释表明，该类确实提供了极大的灵活性以自定义线程池的方方面面，如果确实需要自定义这些配置的话，需要遵守以下指导规范：</p><ul><li><p>核心线程数量和最大线程数量(Core and maximum pool sizes)</p><p>一个<code>ThreadPoolExecutor</code>线程池将根据核心线程数量和最大线程数量自动调整线程池大小。当一个新任务提交时，如果此时正在运行的线程比corePoolSize数量小，那么线程池将会创建一个新线程来处理这个任务，即使现在还有线程处于空闲状态。如果正在运行的线程数量大于corePoolSize但是小于maximumPoolSize，任务将会先暂存到任务队列里，除非任务队列也满了，这时候才会新建一个线程。</p><p>因此，通过调整核心线程数量和最大线程数量就可以控制线程的数量。一般来说，这两个参数实在新建时就创建好的，但仍然可以在运行时进行修改。(Executors中提供了方法可以禁止这种创建完毕后的修改。)</p></li><li><p>创建时构造线程池</p><p>一般来说，一个线程池创建以后并不新建线程，直到任务到来。但可以调用方法<code>prestartCoreThread</code>或者<code>prestartAllCoreThreads</code>要求线程池在初始化时就新建足够数量的线程。如果你在执行一个线程时已经有一个非空的任务队列，可以使用这个特性。</p></li><li><p>创建新的线程</p><p>新线程都是通过<code>ThreadFactory</code>创建的，如果没有特别指定，那么<code>ThreadFactory</code>将使用<code>Executors.DefaultThreadFactory</code>，该<code>ThreadFactory</code>创建的线程都属于一个线程组(一个已经不建议使用的概念)，并且都有相同的优先级，也就是默认优先级(Normal_Priority)，并且是非守护线程。通过提供自定义的<code>ThreadFactory</code>，用户可以自定义线程名、线程组、优先级、守护状态等等。如果<code>ThreadFactory</code>创建线程失败，返回了null，线程池并不会崩溃，但可能无法处理任何任务了。</p><p>线程必须拥有modifyThread这个权限，如果没有该权限，那么executor可能会降级，配置更改可能不会生效，或者线程池能停留在一个终止了但没有完全清除的状态。</p></li><li><p>存活时间Keep-alive times</p><p>如果一个线程池当前的线程数超过了corePoolSize，超出的线程将会在空闲超过存活时间后被终止。这个参数也可以在运行时动态设置，如果设置成一个非常长的时间，实际效果就是这些线程将永远不会被终止。一般来说，存活时间仅对超过了corePoolSize的线程起作用，但可以通过<code>allowCoreThreadTimeOut(Boolean)</code>方法使超时策略也应用于核心线程。</p></li><li><p>阻塞队列</p><p>阻塞队列处理的问题是任务如何被提交给线程。阻塞队列的使用与线程池大小有一定关系。</p><ul><li>如果当前运行的线程数量少于corePoolSize，那么Executor将总是新建线程来完成任务，此时阻塞队列并没有用处。</li><li>如果当前运行的线程数量大于或者等于corePoolSize，那么Executor将把线程放到队列中去，而不是新建线程。即使线程数量还没有达到maximumPoolSize。</li><li>如果一个请求无法放入队列，即队列已满，且线程数量还没有达到maximumPoolSize，新线程才会被创建。如果队列已满、线程数量已到最大，那么新任务就会被拒绝。至于拒绝策略，在之后需要提供。</li></ul><p>有三种普遍的队列策略：</p><ul><li><p>直接hand to hand交接。</p><p>比如使用SynchronousQueue，必须有可用线程在等待时任务交付才能够完成，否则就会新建一个线程来这个任务。这个方式避免了任务集中的任务有内部依赖时可能产生的锁定(This policy avoids lockups when handling sets of requests that might have internal dependencies.)，这种队列一般需要无上限的maximumPoolSize，因此可能造成线程池膨胀造成的OOM。</p></li><li><p>无界阻塞队列。</p><p>比如使用LinkedBlockingQueue，这种策略在corePoolSize数量的线程都在忙时，新任务会一直往队列里提交，也就是说，maximumPoolSize设置会实际上无效，因为永远不会有超过corePoolSize的线程创建。这种策略一般适用于任务之间独立、没有相互依赖的情况，比如一个web服务器。但是这种队列因为其没有容量上限，可能导致队列膨胀造成的OOM。</p></li><li><p>有界队列</p><p>这种队列能够防止占用资源无限膨胀，但可能更难控制。队列大小和最大线程数量将会相互影响，使用大队列和小线程池，可能会节省CPU和系统资源，但降低了吞吐量。如果使用小队列一般需要更大的线程池，这可能保持CPU的高使用率，但可能遭遇无法接受的上下文切换消耗，最终也降低了吞吐量。</p></li></ul></li><li><p>拒绝策略</p><p>当线程池被<code>shutdown()</code>或者上述线程池处理能力满了的时候，新提交的任务就会被拒绝。无论是哪种情况引发的拒绝，<code>RejectedExecutionHandler.rejectedExecution(Runnable, ThreadPoolExecutor)</code>都将被调用，JDK提供了以下四个预定义的拒绝策略：</p><ul><li><p><code>ThreadPoolExecutor.AbortPolicy</code></p><p>抛出一个运行时异常：RejectedExecutionException</p></li><li><p><code>ThreadPoolExecutor.CallerRunsPolicy</code></p><p>这个策略将直接在调用execute的线程下执行提交的task。因为生产者线程会因为执行这个task被阻塞，不能提交新的任务，可以延缓新task的产生。</p></li><li><p><code>ThreadPoolExecutor.DiscardPolicy</code></p><p>直接丢弃</p></li><li><p><code>ThreadPoolExecutor.DiscardOldestPolicy</code></p><p>丢弃队列首位的任务。如果使用了优先级队列，将导致优先级最高的任务被丢弃，不建议搭配优先级队列使用。</p></li></ul><p>也可以定义自己的拒绝策略，如果你要这么玩儿，就需要格外小心，特别是使用有界队列的时候。</p></li><li><p>钩子方法</p><p>可以继承并覆写该类的<code>beforeExecute(Thread, Runnable)</code>方法和<code>afterExecute(Runnable, Throwable)</code>，这两个方法，在任务执行前或者执行后执行某些制定操作，比如说重新初始化线程变量、收集统计数据、或者增加日志等（策略模式，aop思想），也可以覆写<code>terminated</code>方法，要求executor在完全终止时执行任何自定义的操作。</p><p>如果钩子或者回调参数发生了异常，那么该线程可能连续失败。</p></li><li><p>队列维护</p><p><code>getQueue()</code>方法允许用户访问工作中的队列，为监控或者debug提供支持。因为其他原因使用该方法都是强烈不建议的。<code>remove(Runnable)</code>和<code>purge()</code>方法可以用来在大量队列任务取消的时候，协助处理内存回收。</p></li><li><p>Finalization</p><p>一个不再被引用且不再保有线程的线程池将会被自动shutdown，如果要确保不被引用的线程池锁占用的资源在用户忘记调用shutdown的情况下仍然能够被回收，那就必须设置合理的超时时间，并且设置核心线程数量为0或者打开allowCoreThreadTimeOut。</p></li></ul><h4 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h4><p>一个<code>ScheduledThreadPoolExecutor</code>支持定时执行任务，包括在给定延迟之后执行任务，以及周期性执行任务。</p><p>延迟任务（delayed tasks）将在正式启动之后运行，但启动后具体执行的时间将没有保证。在同一时间被启动的任务将会严格按照FIFO原则执行。当一个任务在执行前被取消，那么执行将会停止，但是该任务并不会被自动移出队列，直到超时，这么做是为了方便做监控。但这样就可能造成被取消的任务积压(如果设置的时间太长)导致OOM，为了避免这种情况，可以将<code>setRemoveOnCancelPolicy</code>设为<code>true</code>，这样他们被取消时就会立即移出队列。</p><p>虽然该类继承于<code>ThreadPoolExecutor</code>，但一些参数调整对该类并没有什么效果。一方面，这个类总是一个固定线程数量(corePoolSize)的线程池，并且使用无界队列，因此设置<code>maximumPoolSize</code>对该类无用。并且，在任何时候都不要设置corePoolSize为0，或者<code>allowCoreThreadTimeOut</code>，因为这可能会导致该线程池在真正需要执行任务时没有线程可用。</p><p>该类的主要方法继承自接口<code>ScheduledExecutorService</code>，对于该接口，有一些重要注解摘抄如下：</p><p><code>schedule</code>方法允许创建带有多样化延迟的任务，并且返回一个task的object，以便用来取消任务执行以及检查执行情况。<code>scheduleAtFixedRate</code>和<code>scheduleWithFixedDelay</code>方法创建并执行一个定期执行的任务，直到被取消。</p><p>而<code>execute()</code>和<code>submit()</code>会被当做是一个延迟为0或者负的定时任务，也就是他们会立即执行。</p><p>所有的<code>schedule</code>方法都接受相对时间或者时间段作为参数，而不是绝对时间或者日期。</p><p>一个简单的代码示例，在接下来一小时里每十秒输出一个beep，直到一小时后取消。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.concurrent.TimeUnit.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeeperControl</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduler =</span><br><span class="line">    Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beepForAnHour</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Runnable beeper = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"beep"</span>); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">final</span> ScheduledFuture&lt;?&gt; beeperHandle =</span><br><span class="line">      scheduler.scheduleAtFixedRate(beeper, <span class="number">10</span>, <span class="number">10</span>, SECONDS);</span><br><span class="line">    scheduler.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; beeperHandle.cancel(<span class="keyword">true</span>); &#125;</span><br><span class="line">    &#125;, <span class="number">60</span> * <span class="number">60</span>, SECONDS);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的主要方法有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                       <span class="keyword">long</span> delay, TimeUnit unit);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">long</span> delay, TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                  <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                  <span class="keyword">long</span> period,</span><br><span class="line">                                                  TimeUnit unit);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                     <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                     <span class="keyword">long</span> delay,</span><br><span class="line">                                                     TimeUnit unit);</span><br></pre></td></tr></table></figure><p>非常简单。需要注意的是。<code>ScheduledThreadPoolExecutor</code>实际上覆写了<code>submit</code>和<code>execute</code>方法，将他们作为延迟为0的任务提交给<code>schedule()</code>执行了，因此返回值实际上是<code>ScheduledFuture</code>。在覆写该类时应该注意到这一点。</p><h4 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h4><p>顾名思义，用来执行<code>ForkJoinTask</code>的线程池。但也提供了执行非<code>ForkJoinTask</code>的接口。</p><p>ForkJoinPool与其他线程池最大的不同在于，它应用了<strong>任务窃取</strong>技术。任务窃取技术的细节在上面的<code>Fork/Join框架</code>那个部分已经讲过了。不过这里提到了一句话，即</p><blockquote><p>ForkJoinPools may also be appropriate for use with event-style tasks that are never joined.</p><p>对于那些不需要join的事件型的任务也非常合适。即并不关心结果，只求把任务分解后跑完。只fork而并不join。</p></blockquote><p>在大部分场合下，使用静态方法<code>commonPool()</code>就足够了。任何没有被显式提交到特定线程池的ForkJoinTask都使用common pool。使用该pool通常会节省资源，因为它会缓慢回收无用线程，并且再使用时再恢复。</p><p>如果程序真的需要自定义线程池，那么可以在构造<code>ForkJoinPool</code>时传入指定的并行级别(parallelism level)，默认情况下等于可用处理器数量。该线程池会动态维护足够的线程来完成任务。</p><p>除了执行任务和生命周期管理，该类还提供了状态检查方法，比如<code>getStealCount()</code>，旨在帮助调优和监控fork/join框架的运行情况。同时，<code>toString()</code>方法以特定的格式输出监控信息。</p><p>对于其他的<code>ExecutorService</code>来说，主要通过<code>execute()</code>、<code>submit()</code>、<code>invoke()</code>来提交任务，<code>ScheduleExecutorService</code>主要通过<code>sheduleXXX()</code>系列方法来提交定时任务。对于ForkJoinPool来说，仍然可以通过以上三个主要方法来提交<code>ForkJoinTask</code>，但除非你的任务是那种事件型不需要或很少需要join的任务，不然还是推荐使用<code>ForkJoinStyle</code>的写法。即通过<code>ForkJoinTask.fork()</code>和<code>ForkJoinTask.invoke()</code>来替代，演示虽然上面已经有例子了，还是再来一次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX = <span class="number">1000000000L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> THRESHOLD = <span class="number">1000L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinTask</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        Long sum = forkJoinPool.invoke(<span class="keyword">new</span> ForkJoinTask(<span class="number">1</span>, MAX));</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        System.out.println(System.currentTimeMillis() - start + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="comment">// ForkJoinTask主要是覆盖这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            ForkJoinTask task1 = <span class="keyword">new</span> ForkJoinTask(start, mid);</span><br><span class="line">            task1.fork();</span><br><span class="line"></span><br><span class="line">            ForkJoinTask task2 = <span class="keyword">new</span> ForkJoinTask(mid + <span class="number">1</span>, end);</span><br><span class="line">            task2.fork();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>commonPool一般是通过默认参数构造的，但是如果确有需要调整，也可以通过以下几个参数来调整：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                    ForkJoinPool.ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                    Thread.UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">boolean</span> asyncMode)</span></span>;</span><br><span class="line"><span class="comment">// 最后一个参数设为true，可能更方便执行那些事件型不需要或极少需要join的任务。</span></span><br></pre></td></tr></table></figure><p>该线程池的主要特定方法包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 执行指定任务直到完成，如果执行出现异常，异常会被抛出。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invoke</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="进一步看看ForkJoinTask"><a href="#进一步看看ForkJoinTask" class="headerlink" title="进一步看看ForkJoinTask"></a>进一步看看ForkJoinTask</h5><p>为执行在<code>ForkJoinPool</code>中的任务设计的抽象基类。一个<code>ForkJoinTask</code>是一个类似线程(Thread-like)的实体，但比普通的线程要轻量地多。大量的任务和子任务能够被少量的线程处理，只是应用上稍微受限一点。</p><p>一个<code>ForkJoinTask</code>从显式提交给<code>ForkJoinPool</code>时正式运行，或者还没有与某个<code>ForkJoinPool</code>关联时，调用<code>ForkJoinTask.fork()</code>、<code>invoke()</code>方法，会把任务提交给<code>ForkJoinPool.Commonpool</code>。一旦开始，一个<code>Task</code>通常会产生一些subtask。虽然实际上大部分用户使用<code>ForkJoinTask</code>，都只会应用<code>fork()</code>，<code>join()</code>这两个方法，不过该类还是为高级玩家预留了一下方法。</p><p>一个<code>ForkJoinTask</code>是一个轻量级的<code>Future</code>，<code>ForkJoinTask</code>的高效来源于这样的假设：即他们的主要用途是执行纯粹的函数或者执行一些相互之间没有联系的任务。<code>ForkJoinTask</code>的主要的同步工具是<code>fork()</code>方法，这将触发一次异步执行，而<code>join()</code>动作将阻塞直到具体的计算任务完成。计算任务最好<strong>避免</strong>使用<code>synchronized</code>方法或<code>synchronized</code>块和大部分同步原语，除了<code>join</code>其他任务，或者<code>Phasers</code>这样推荐和<code>Fork/Join</code>框架合作的同步原语。<strong>子任务应当不要执行阻塞IO</strong>，并且最好只访问与其他线程完全隔离的变量。这些指导原则靠不允许抛出受检查异常如IOException来松散地保证。但用户任务仍然可能抛出非检查异常，那么该异常将会抛到尝试join这些发生异常的任务的线程里。除此之外，当资源耗尽的时候，比如无法为任务分配队列空间，有可能会抛出<code>RejectedExecutionException</code>。重新抛出的异常和普通的异常是一样的，只是在可能的时候会包含两个线程的异常栈信息：初始化这个任务的线程和真正遇到这个异常的线程，最少有后者的异常栈信息。</p><p>除非满足下列条件，否则ForkJoinTask不应该执行阻塞任务：</p><ul><li>其他任务应该不依赖(如果非要依赖，也尽量少)那些需要外部synchronization同步控制或者IO的任务。那些事件型、从来不join的异步任务就很符合这个要求；</li><li>最小化资源争用。任务应当足够小，最好这个阻塞任务只执行这个阻塞任务。</li><li>除非用过了<code>ForkJoinPool.ManagedBlocker</code>接口，或者有可能阻塞的任务小于ForkJoinPool的并行级别，不然线程池无法保证有足够的线程完成工作，或者保证性能。</li></ul><p>让当前线程等待另一个任务完成并得到结果的主要方法是<code>join()</code>，但因为<code>ForkJoinTask()</code>本身实现了<code>Future</code>接口，因此也可以用<code>Future.get()</code>这种Future风格的方法来等待和获取结果。<code>invoke()</code>方法在语义上和<code>fork()</code>方法是一致的，<code>join()</code>方法则总是尝试在当前线程执行。这些方法的<code>quiet</code>变体不会产生结果，也不会报告异常，这些变体在一系列任务需要执行，但你需要在所有任务都完成后再处理结果或异常的场景下比较有用。<code>invokeAll()</code>方法就更牛逼了，它一口气fork出一系列任务，然后等待他们全部完成(join them).</p><p>在大多数情况下，一个ForkJoin任务执行就像一个递归函数中的调用(fork)/返回(join)。在大部分情况下，fork/join的顺序也像递归那样安排，比如<code>a.fork(); b.fork(); b.join(); a.join();</code>这种形式，就比a先join效率可能高一点。</p><p>有多种方式可以查看任务的执行状态，<code>isDone()</code>在任务完成，包括任务被取消的情况下返回true，<code>isCompleteNormally()</code>在任务正常完成且没有被取消、没有抛异常的情况下返回true，<code>isCancelled()</code>在任务取消时返回true，而<code>isCompletedAbnormally()</code>在任务取消或任务遇到异常时返回true。在任务取消时，<code>getException()</code>方法将会得到<code>CancellationException</code>，在任务遇到异常时，会得到具体异常。</p><p>该接口通常不会直接被实现，如果用户需要实现该接口，一般是实现它的一些抽象子类，这些抽箱子类被设计为执行不同风格的<code>Fork/Join</code>任务，特别是<code>RecursiveAction</code>，适合大多数不返回结果的任务，而<code>RecursiveTask</code>适合返回结果的任务，而<code>CountedCompleter</code>是为那些链式调用，即一个完成的任务trigger另一个完成的任务这种操作准备的。一般情况下，就是扩展其中一个，然后覆盖相应类中的<code>compute()</code>方法即可。</p><p><code>ForkJoinTask</code>应当执行相对较小的任务，较大的任务应当被分割为更小的任务后再执行，一个粗糙的参考标准是，一个子任务应当进行大于100并且小于10000次运算，并且应当避免模糊的循环次数。如果一个任务太大了，那并行就无法提高吞吐量，如果太小了，那么调度的开销可能会超过拆分带来的好处。</p><p><code>ForkJoinTasks</code>实现了<code>Serializable</code>接口，因此允许类似远程调用的技术。但应当在任务执行之前或之后进行序列化，而非正在执行时。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>多线程估计是程序员进阶路上绕不过的一个绊子。多线程本身的复杂性，再加上现代编译器和CPU的很多透明优化，将会造成很多很难排查、很难复现的问题。</p><p>使用线程，首先需要了解线程的一些基本概念，包括线程的六种状态、线程的终止和中断。特别是了解到线程的中断实际上只是在线程的中断标志位置位，至于如何处理这个中断标志，由线程自己决定。因此，线程应该总是在合适的位置检查中断标志位，以决定如何处理中断。在线程阻塞的情况下，比如<code>sleep()</code>或者<code>wait()</code>时，因为线程阻塞无法到达检查中断标志位的代码，此时将该线程中断标志置位将导致该线程抛出<code>InterruptedException</code>。</p><p>java从早期版本就支持<code>synchronized</code>同步关键字，并将<code>wait()</code>，<code>notify()</code>和<code>notifyAll()</code>设计到</p><p>每一个object中，从而使每一个object都可以作为锁使用，最早的<code>synchronized</code>关键字将会直接使用一个重量级锁，即monitor锁，与此相关的概念主要是入口集、等待集和锁owner。明白这些概念，将很容易理解<code>wait()</code>和<code>notify()</code>以及<code>notifyAll()</code>的具体效果，并且明白为什么<code>notify()</code>可能导致死锁。因为早期的<code>synchronized</code>使用了重量级锁，这也造成了大家只要使用该关键字就会造成性能较大损失的印象。</p><p>早期的<code>synchronized</code>提供的功能在当时的硬件条件下还是可以的，我个人理解，可能当时的硬件并没有普遍的多核，因此该关键字的主要功能实际上是在服务因为IO等阻塞后不影响其他任务的调度，即多线程主要用来处理异步，而并非并发，对性能的要求也没有这么极端。但随着硬件的发展，真正的多核时代到来了，更多的应用程序需要用到多核的硬件，此时使用java提供的<code>sychronized</code>低级同步原语十分困难且容易出错，java顺应程序员的呼声，推出了一系列高级同步工具，并且大幅度优化了<code>sychronized</code>的锁机制。</p><ul><li><p>现在的<code>synchronized</code>锁并不是一开始就是重量级锁，而是综合运用了偏向锁、轻量级锁、重量级锁逐步升级的技术，尽量避免锁性能浪费，同时采取了自旋锁，在部分情况下使用CAS乐观锁，在CPU忙循环消耗和线程上下文切换消耗中试图做出更优化的选择。并且使用了编译期的锁消除、锁粗化机制，尽量避免无谓的加锁解锁消耗。</p></li><li><p>提供了<code>Lock and Condition</code>这种更高级的锁机制，他可以支持不阻塞地尝试加锁(失败时立即返回false)，还可以在其他代码块进行解锁，也不像<code>synchronized</code>关键字这样必须严格按照加锁倒序进行解锁。这就使得一些链式加锁（先获得A的锁，再获得B的锁，再释放A的锁，再获得C的锁，再释放B的锁）成为可能。</p><p>同时，还提供了读写锁这种高级锁机制，以提高在大容量容器上、执行读操作远远多于写操作场景下锁的性能。该锁允许多个线程同时获取读锁，但当有线程获得写锁时，其他任何线程都不能获得读锁或者写锁。</p><p>同时，这种锁还提供了Condition机制，以允许线程在获得锁后，因为其他资源未就绪(执行条件不满足)而放弃锁，给其他线程以准备资源的机会。</p></li><li><p>为了方便程序员写出线程安全的代码，提供了很多内部使用了锁的工具、对外暴露简单接口的阻塞队列，以简化<code>生产者/消费者</code>模型的开发难度。这些队列根据是否有界、是否先进先出、是否双端可取分为很多种。并作为基础工具大量应用于更高级的线程工具中，比如Fork/Join框架。</p></li><li>为了使程序员能够更灵活地控制线程同步，还推出了更高级的同步器，可以支持让主线程等待N个子线程完成工作（CountDownLatch），或者允许线程阶段性地在某处同步(Barrier、Phaser)。</li><li><p>在Runnable对象之外，还提供了Callable与Future，来简化需要有返回值的任务多线程执行。为了能够让Callable跑在原来为Runnable设计的Thread类中，为Callable设计了一个适配器，将Callable转化为Future和Runnable，这就是FutureTask类。</p></li><li><p>JDK同时提供了一系列线程安全的集合，保证在多线程环境下操作这些集合不会破坏他们的内部结构，导致循环或者其他问题。但是要注意的是，这些集合本身只能保证在多线程环境下内部结构是安全的，而不能保证操作是原子的。即这样的代码<code>map.put(key,map.get(key)+1);</code>在多线程下操作会造成不可预知的结果，为保证类似操作的安全，应该手写CAS，或者利用这些线程安全集合的一些高级方法，以保证这类操作原子性。</p></li><li>JDK提供了一些原子类，即<code>AtomicXXX</code>系列类。这些类在底层使用了CAS机制，保证多线程下对他们的操作是安全的，结果是可预期的。同时，为了避免这些类在高度竞争的情况下出现性能问题，JDK还提供了<code>LongAdder</code>，<code>DoubleAdder</code>、<code>LongAccumulator</code>、<code>DoubleAccumulator</code>类，通过将数字的存储在内部分散到多个原子类上，而其总和表示最终数字的方式，减少了竞争带来的性能损耗。在多线程环境下，应该根据合适的环境选择合适的原子类，避免自己加锁。</li></ul><p>同时，为了减少线程创建和销毁的开销，JDK提供了线程池的概念，线程池的顶级接口是<code>Executor</code>，但是实际上都会用<code>ExecutorService</code>、<code>ScheduledExecutorService</code>、<code>ForkJoinPool</code>作为真正是用的接口，他们具体的实现类包括<code>ThreadPoolExecutor</code>、 <code>ScheduledThreadPoolExecutor</code> 、 <code>ForkJoinPool</code>。这些线程都有自己的调度策略，有自己的专属方法，也有自己的一些特殊要求，比如<code>ForkJoinPool</code>执行的任务最好是完全独立，且不阻塞的。但这些线程池都需要解决这样的一些问题：</p><ul><li>线程池是否在创建时就创建一定数量的线程，还是在任务到来后动态创建。动态创建的策略是什么，线程池里的线程是否允许回收，回收策略是什么。这些策略与<code>corePoolSize</code>， <code>maximumPoolSize</code>，<code>keepAliveTime</code>以及 <code>allowCoreThreadTimeOut</code>这几个参数息息相关。</li><li>线程池在任务不断到来，但可用线程都在工作时，到底采取什么策略来新建线程，或者暂存来不及执行的任务。这根据线程池用来保存任务的阻塞队列是什么，以及maximumPoolSize的选择息息相关。在生产者速度超过消费者速度的情况下，因为这个策略的不同，会使线程池的行为走向两个极端，一个是使用无界队列一直保存来不及执行的任务，导致任务OOM，一个是不断新建线程试图同时运行所有任务，导致线程资源OOM。因此，在生产环境下监控消费者能力不足、任务积压的情况十分必要。</li></ul><p>这些线程池一般不用自己手动创建，JDK提供了<code>Executors</code>这个工厂类来产生线程，在大部分情况下，工厂生产的默认线程池就够用了。但主要需要提防线程生产者能力超过消费者能力这种情况，在这种情况下可能需要提供有界队列，并提供拒绝接受新任务时的处理器（handler）。</p><p>除了这些仍然需要和线程这个概念直接打交道的机制以外，JDK还提供了更高级别的线程抽象机制，即将线程的概念都隐藏起来，只暴露出执行任务的抽象接口，进一步剥离线程管理的复杂度。这些工具包括<code>CompleteableFuture</code>、<code>Fork/Join</code>框架。</p><ul><li><code>CompletableFuture</code>适合用来处理一系列有先后关系的任务，即特别适合描述这样的编程场景：一个异步任务完成后，我们执行另外一个异步任务，再执行另外一个异步任务，或者等待两个异步任务都完成后，用他们的结果执行一些任务等等，并且能妥善处理任意一步任务出现的异常。<code>CompletableFuture</code>同时实现了<code>CompletionStage</code>和<code>Future</code>接口，提供多达50多个方法，支持各种形式的异步任务调用链。可以极大简化上述场景的编程任务。</li><li><code>Fork/Join</code>框架则适合处理那些可以分拆成相互独立的子任务的大型任务，以充分利用多核处理器的效能，同时它还通过<strong>任务窃取</strong>技术，保证所有线程都能保持较高负载率，而避免出现一个线程阻塞后无所事事的情况。为了充分利用Fork/Join框架的能力，应当为其提供合理的并行级别，而且应当尽力保证提交给它的任务是不阻塞的，而且相互之间没有依赖关系。</li></ul><p>但是，万剑归宗。无论是使用底层的低级同步原语，还是使用更加高级的线程同步工具，都必须时刻记住线程安全这个大话题。要确保线程安全，需要对原子性、有序性与可见性有基本的了解，对现代CPU调度、多级缓存有一定的概念。无论如何，要记得无锁区的任意代码都有可能随时被中断，使用类似set方法时要格外留意。</p><p>本文求全而不求深，只求对Java多线程下的大部分工具有一个基本的了解，以便在使用时知道要去哪里寻找。</p><p>谢谢耐心看到这里。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;多线程问题&quot;&gt;&lt;a href=&quot;#多线程问题&quot; class=&quot;headerlink&quot; title=&quot;多线程问题&quot;&gt;&lt;/a&gt;多线程问题&lt;/h2&gt;&lt;h3 id=&quot;多线程基本概念&quot;&gt;&lt;a href=&quot;#多线程基本概念&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java的IO进化简史</title>
    <link href="http://yoursite.com/2020/02/07/Java%E7%9A%84IO%E8%BF%9B%E5%8C%96%E7%AE%80%E5%8F%B2/"/>
    <id>http://yoursite.com/2020/02/07/Java%E7%9A%84IO%E8%BF%9B%E5%8C%96%E7%AE%80%E5%8F%B2/</id>
    <published>2020-02-07T04:32:25.000Z</published>
    <updated>2021-04-22T04:43:17.459Z</updated>
    
    <content type="html"><![CDATA[<p>– 你有《时间简史》吗？</p><p>– 你有病吧，我有时间也不去捡屎啊。</p><p>好吧，上面是个冷笑话。</p><a id="more"></a><h2 id="问题的引出"><a href="#问题的引出" class="headerlink" title="问题的引出"></a>问题的引出</h2><p>前一段时间看Java的内存模型，里面提到了本地内存，以及经常会使用本地内存的一种由<code>JDK1.4</code>引入的新IO方式，<code>NIO</code>，虽然官方称之为<code>New IO</code>，但是实际上因为其最重要的特性是非阻塞，因此常被称为<code>Non-Blocking IO</code>，即非阻塞式IO，它的出现解决了传统的<code>Blocking IO</code>带来的一些性能问题。其具体的优化细节和解决的痛点我们之后再详细讨论。</p><p>然后我就陷入<code>NIO</code>的坑里了，经过一段时间的整理，我发现<code>JDK1.7</code>以后，又引入了一种新的IO类型，<code>NIO2.0</code>，又称为<code>AIO</code>，意思是<code>Asynchronous IO</code>，即异步IO。能推出异步IO肯定有他的道理，但出现了这个概念以后，我就想认真梳理一下这些IO有什么不同，以及到底解决了什么问题。</p><p>于是首先我陷入了一个新手可能都会绕进去的概念里面：</p><h2 id="同步、异步-阻塞、非阻塞"><a href="#同步、异步-阻塞、非阻塞" class="headerlink" title="同步、异步 | 阻塞、非阻塞"></a>同步、异步 | 阻塞、非阻塞</h2><p>这两个可以排列组合的，所以将可能排列出同步阻塞、同步非阻塞、异步阻塞、异步非阻塞，这四种方式，特别是其中的异步阻塞最为诡异和难以理解。我一开始确实绕进去了，但后来还是根据上面知乎回答搞明白了这几个概念。</p><p>其中最核心的区别是：</p><p>同步、异步是针对调用者而言的，一个同步调用在<strong>被调用者完成其任务前</strong>不会返回，而一个异步调用，在<strong>向被调用者提交完任务后</strong>就返回了，被调用者通过通知来告知调用者其任务已经执行完毕，或者直接执行调用者提供的回调函数。</p><p>而阻塞、非阻塞关注的是程序在等待返回值时在干什么。阻塞是指当前的任务会被挂起，一直到结果返回，而非阻塞是指<strong>即使调用没有立即完成</strong>，程序在等待完成的过程中可以干点其他的事情。</p><p>这个还是不好理解的话，知乎上举的例子还是很简单易懂的。</p><blockquote><p>老张爱喝茶，废话不说，煮开水。<br>出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。<br>1 老张把水壶放到火上，立等水开。（同步阻塞）<br>老张觉得自己有点傻<br>2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）<br>老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。<br>3 老张把响水壶放到火上，立等水开。（异步阻塞）<br>老张觉得这样傻等意义不大<br>4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）<br>老张觉得自己聪明了。</p></blockquote><p>其中最诡异的是异步阻塞，其行为很反逻辑，所以会让人想不明白，因为我都异步了，为什么要阻塞在这里等待？但其实这个在某些场合下也有用处。比如说：在数据库主从同步时，如果要求强一致性，那么在返回之前就必须保证所有的从数据库的消息都返回，那我是不是一个个调用从数据的阻塞接口，写完一个再写下一个？或者提交任务后一遍遍去问他们都做完了没有？显然更好的方式是我一口气给他们每一个都发送一个异步任务，然后阻塞着等他们都完成后通知我，我再进行下一步。其他我实在想不到应用场景……总之比较诡异。</p><p>上面老张的例子是个好理解的例子而已，而且上面所说的异步非阻塞的模型是<strong>异步+通知</strong>的模型，实际上还有个<strong>异步+回调</strong>的模型，如果非要用烧水煮茶的例子类比，就是这个水壶很智能，你可以告诉他水烧好后自己泡茶，然后你就彻底不用管了。</p><p>以上的四种模型，如果用代码语言去表达，大概会是什么样子呢？我试着举出下面的例子，如有错误，请自行甄别：</p><ul><li><p>同步阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = sum(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);<span class="comment">// 这就是个典型的同步阻塞调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] input)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 忽略判null</span></span><br><span class="line">   <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i: input)&#123;</span><br><span class="line">      ret += i;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同步非阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncBlock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] input;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(<span class="keyword">int</span>[] input)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.input = input;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : input) &#123;</span><br><span class="line">                ret += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Callable&lt;Integer&gt; sumTask = <span class="keyword">new</span> SumTask(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(sumTask);</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        <span class="keyword">while</span> (!futureTask.isDone()) &#123;</span><br><span class="line">            <span class="comment">// 下面这行输出是模拟我在等待结果的过程中做其他事情</span></span><br><span class="line">            <span class="comment">// 同步的意思是，futureTask.isDone()在返回时该方法的任务已经完成了</span></span><br><span class="line">            <span class="comment">// 毕竟他的任务只是判断任务是不是已经结束。</span></span><br><span class="line">            <span class="comment">// 又因为调用者在等待结果时可以做其他事，所以称之为非阻塞</span></span><br><span class="line">            System.out.println(<span class="string">"我买了好破一台电脑，四个数都加不出来"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>异步非阻塞</p><p>先来个回调方式，这样实际上调用线程什么都不用做了，只要提供一个合理的回调方法就行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncNonBlockingWithCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] input;</span><br><span class="line">        Consumer&lt;Integer&gt; callback;</span><br><span class="line"></span><br><span class="line">        SumTask(<span class="keyword">int</span>[] input, Consumer&lt;Integer&gt; callBack) &#123;</span><br><span class="line">            <span class="keyword">this</span>.input = input;</span><br><span class="line">            <span class="keyword">this</span>.callback = callBack;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : input) &#123;</span><br><span class="line">                ret += i;</span><br><span class="line">            &#125;</span><br><span class="line">            callback.accept(ret);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Consumer&lt;Integer&gt; callback = (result) -&gt; System.out.println(result);</span><br><span class="line">        Runnable sumTask = <span class="keyword">new</span> SumTask(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, callback);</span><br><span class="line">        <span class="keyword">new</span> Thread(sumTask).start();</span><br><span class="line">        System.out.println(<span class="string">"OH YEAH，任务甩给那个线程啦，我现在想干啥都行了，干完以后他自己处理回调就好了"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>通知方式，即当异步任务完成后，会去通知调用线程。这是上面老王煮茶那个例子了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncNonBlockingWithNotify</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] input;</span><br><span class="line">        <span class="keyword">private</span> Thread caller;</span><br><span class="line"></span><br><span class="line">        SumTask(<span class="keyword">int</span>[] input, Thread caller) &#123;</span><br><span class="line">            <span class="keyword">this</span>.input = input;</span><br><span class="line">            <span class="keyword">this</span>.caller = caller;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : input) &#123;</span><br><span class="line">                ret += i;</span><br><span class="line">            &#125;</span><br><span class="line">            caller.interrupt();</span><br><span class="line">            <span class="comment">// 这里隐藏了一个很微妙的线程同步问题，即这个interrupt和后面的返回并不是原子的</span></span><br><span class="line">          <span class="comment">// 万一打断后，该线程失去了CPU使用权，没返回，那边会在get上阻塞一下，虽然不是大问题</span></span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line"></span><br><span class="line">        SumTask sumTask = <span class="keyword">new</span> SumTask(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, Thread.currentThread());</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(sumTask);</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 我愉快地干自己的事情啦</span></span><br><span class="line">          <span class="comment">// 区别于上一次我一直去轮询Future是不是完成了</span></span><br><span class="line">            <span class="comment">// 这里其实是异步任务(通过打断线程)来通知我任务完成了</span></span><br><span class="line">          <span class="comment">// 我在这里只需要在合适的位置去检查这个中断标志就可以了</span></span><br><span class="line">          <span class="comment">// 相当于老王在看电视的同时等待水壶响起来，但是在程序里总得有个时间点去检查</span></span><br><span class="line">          <span class="comment">// 通知的状态。</span></span><br><span class="line">            System.out.println(<span class="string">"等待等待再等待，心儿已等碎，我和你在河两岸，共饮一江水"</span>);</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(String.format(<span class="string">"好吧，这哥们加完了，结果是%d"</span>, futureTask.get()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 实际运行效果</span></span><br><span class="line"><span class="comment">* 等待等待再等待，心儿已等碎，我和你在河两岸，共饮一江水</span></span><br><span class="line"><span class="comment">* 等待等待再等待，心儿已等碎，我和你在河两岸，共饮一江水</span></span><br><span class="line"><span class="comment">* 等待等待再等待，心儿已等碎，我和你在河两岸，共饮一江水</span></span><br><span class="line"><span class="comment">* 等待等待再等待，心儿已等碎，我和你在河两岸，共饮一江水</span></span><br><span class="line"><span class="comment">* 等待等待再等待，心儿已等碎，我和你在河两岸，共饮一江水</span></span><br><span class="line"><span class="comment">* 等待等待再等待，心儿已等碎，我和你在河两岸，共饮一江水</span></span><br><span class="line"><span class="comment">* 好吧，这哥们加完了，结果是10</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><ul><li><p>异步阻塞</p><p>终于到了这个奇怪的组合了，稍微修改一下上面的例子即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line"></span><br><span class="line">    SumTask sumTask = <span class="keyword">new</span> SumTask(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, Thread.currentThread());</span><br><span class="line">    FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(sumTask);</span><br><span class="line">    <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在sleep调用时如果interrupt标志已经置位，会直接抛出InterruptedException</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"哎呀被打断了"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(String.format(<span class="string">"好吧，这哥们加完了，结果是%d"</span>, futureTask.get()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在另外一个参考文件上获得了一段对理解阻塞非常有意义的文字，摘抄如下：</p><blockquote><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，<strong>则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。</strong>可见，进程的阻塞是进程自身的一种<strong>主动行为</strong>，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。</p></blockquote><h2 id="BIO（Blocking-IO）"><a href="#BIO（Blocking-IO）" class="headerlink" title="BIO（Blocking IO）"></a>BIO（Blocking IO）</h2><p>同步阻塞IO模式，即数据的读取和写入必须阻塞在一个线程内等待其完成。如果想在等待时干点其他的事情，就需要手动实现类似上面举的例子中的一些多线程的东西。比如一个线程去读，另外一个线程干其他事情。但是，IO操作本身是同步的，这就导致如果不想阻塞在IO上，必须要多开一个线程。</p><p>于是，最传统的、基于BIO（一请求一应答）的通信模型图如下：</p><p><img src="https://camo.githubusercontent.com/5ef6de9824ae82bb0c403522a647953d1193a362/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f322e706e67" alt="BIO-Web-Service"></p><p>一般由一个Acceptor去接受请求，经典的代码就是在<code>while(true)</code>里面去调用accept接口，accept接口会阻塞一直到有新的请求到来，每当来一个新的请求，<code>Acceptor</code>就开个新的线程去处理这个请求。</p><p>一请求一应答的模式有很大的缺陷：</p><ol><li>线程的新建和销毁的成本很高。要新建栈空间，初始化一堆东西，在 Linux 这样的操作系统中，线程本质上就是一个进程，创建和销毁线程都是重量级的系统函数。而且由于栈空间也会消耗内存空间，过多的线程会导致OOM错误。</li><li>线程的切换成本很高。线程切换涉及到CPU寄存器上下文保存等，一直是一个成本很高的操作。</li></ol><p>针对上面的问题，一般会考虑用线程池来缓解问题，线程池维护一些工作线程，这样就节省了线程新建和销毁的成本，一个线程池维护M个线程，可以应对远大于M的N个请求。实际操作中，一般是将socket包装成一个Runable，交给线程池去做，于是CS模型会变成下面这样</p><p><img src="https://camo.githubusercontent.com/04b258a50ca7f9762f43d64e70f4489440bae4eb/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f332e706e67" alt></p><p>但这仍然有一些问题：</p><ol><li>有一些HTTP长连接需要长期保持，比如说聊天软件，不可能创建一个无限大的线程池来保持每一个连接的通信。</li><li>即使线程池大小不是问题，BIO的这种阻塞模型，会要求当连接建立时对应的处理线程就要分配出来，但这时候很有可能真正的数据还在传输中，没有到达，这个等待因为是IO等待，一般都会比较长，那么工作线程在这个过程中占据了线程资源，却没有真的干活。这受限于BlockingIO的同步阻塞特性，不好消除。</li></ol><p>比如一个经典的基于BIO的Server可能如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 闪电侠</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年10月14日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 服务端</span></span><br><span class="line"><span class="comment"> * 原文自：https://www.jianshu.com/p/a4e03835921a</span></span><br><span class="line"><span class="comment"> * 本文作者有小改动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 服务端处理客户端连接请求</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">3333</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 阻塞方法获取新的连接</span></span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 每一个新的连接都创建一个线程，负责读取数据</span></span><br><span class="line">                <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> len;</span><br><span class="line">                        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        InputStream inputStream = socket.getInputStream();</span><br><span class="line">                        <span class="comment">// 按字节流方式读取数据</span></span><br><span class="line">                        <span class="keyword">while</span> ((len = inputStream.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                            System.out.println(<span class="keyword">new</span> String(data, <span class="number">0</span>, len));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用连接池改写，就是这个样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketConsumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SocketConsumer</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> len;</span><br><span class="line">                <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                InputStream inputStream = socket.getInputStream();</span><br><span class="line">                <span class="comment">// 按字节流方式读取数据</span></span><br><span class="line">                <span class="keyword">while</span> ((len = inputStream.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(data, <span class="number">0</span>, len));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 服务端处理客户端连接请求</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">3333</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 阻塞方法获取新的连接</span></span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                executorService.execute(<span class="keyword">new</span> SocketConsumer(socket));</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BIO的好处在于，当连接数不多（单机1000连接以下）的时候，用这种编程模型非常简单，不容易出错，而且工作的也还不错。但是应对十万甚至百万级的连接时，就会非常困难。</p><p>到了JDK1.4，java引入了新的IO模型，即NIO</p><h2 id="NIO（Non-Blocking-IO）"><a href="#NIO（Non-Blocking-IO）" class="headerlink" title="NIO（Non-Blocking IO）"></a>NIO（Non-Blocking IO）</h2><h3 id="NIO要解决什么问题"><a href="#NIO要解决什么问题" class="headerlink" title="NIO要解决什么问题"></a>NIO要解决什么问题</h3><p>知道了上面BIO的缺点，那我们大概就可以猜测NIO到底想要解决什么问题：</p><ol><li>能不能用尽量少的线程对应尽可能多的连接；</li><li>能不能在需要的数据都到达以后，才把数据交由真正的工作线程去处理，避免工作线程空等数据到来。</li></ol><p>答案是可以。我们先来考虑一下一次网络IO大概要经历哪些步骤（自己的理解，有错误请自行甄别）：</p><ol><li>网卡收到了一些数据，之后将这些数据放到物理内存的某个部分。</li><li>这部分物理内存只有内核态的代码有访问权限，即所谓的特权代码。熟悉内存布局的同志应该了解，一个进程中有一部分内存是操作系统使用的，只有这部分特权代码有权限访问硬件资源。而用户代码要访问这一部分内存，必须通过系统调用。Java中的IO类，实际上也是对系统调用的一种封装。</li><li>现在用户代码通过Java的IO类进行了一次系统调用，此时就需要把一些数据从内核态内存复制到用户内存中（至少从模型上理解是这样的，至于内存映射之类的骚操作这里先不考虑）。那么传统的BIO就是我们一直监听着这一块内存，没有数据就等着，有数据就从内核态的内存传过来给用户用。</li></ol><p>那么这个读取的过程，其实要包含两个部分，一个部分是等待数据到来，一个部分是复制数据，其中等待数据到来的这个过程，就是阻塞，其示意图如下：</p><p><img src="https://www.history-of-my-life.com/imgs-for-md/BIO-CopyFromKernel-20190828.png" alt="BIO"></p><p>那么内核能不能修改一下这个阻塞行为，当还在等待数据到来的时候直接返回一个数据还未准备好的状态，这样就不用阻塞等待了。那当然是可以的，这就是非阻塞IO了，其模型如下：</p><p><img src="https://www.history-of-my-life.com/imgs-for-md/Non-BlockingIO-CopyFromKernel-20190828.png" alt="NIO"></p><p>这个模型显然是同步非阻塞的，需要我们一直去轮询。那我们是不是需要自己手写代码去轮询这个呢？答案是你可以这么做，就像我上面的代码中的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!futureTask.isDone()) &#123;</span><br><span class="line">      <span class="comment">// 我还没准备好，技能冷却中，我还不能那么做，太远了</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 好了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，其实我就可以用<strong>一个线程</strong>去监视多个socket通道了，只要我们这个线程里开一个<strong>轮询器</strong>，把那些Socket全都注册到这个轮询器上，我轮询一圈，看数据好了没，好了我就提示用户，没好我就继续轮询。（显然我这里说的这种初级的轮询方式会造成严重的CPU空转问题，实际的设计应该更精巧一些，比如说socket准备好了以后主动通知轮询器，但这就是异步了，我们目前先不管这个，所以了解轮询器就是这么概念模型就好）</p><h3 id="NIO的核心组件"><a href="#NIO的核心组件" class="headerlink" title="NIO的核心组件"></a>NIO的核心组件</h3><p>好了，这就是NIO的思想了，通过我上面描述的这个简易模型，他解决了上面提出的两个问题：</p><ol><li>用尽量少的线程对应尽量多的连接；</li><li>在没有真正数据准备好的时候不要来烦我。</li></ol><p>了解了NIO要解决的问题和它的思想，我们再来正式介绍NIO的核心组件。</p><p>NIO有很多组件，但核心的组件主要是下面这三个：</p><ul><li><p>轮询器，NIO称为selector；</p></li><li><p>需要监听的连接，NIO称为channel；</p></li><li><p>接收数据的缓冲区，NIO称为Buffer。</p></li></ul><p>NIO将一个连接分为好几个步骤，并且将这些步骤抽象为几个可以监听的事件，不同的事件发生后，可以通知不同的监听器。</p><ul><li>Accept：有可以接受的连接到来了；</li><li>Connect：成功建立了连接；</li><li>Read：有数据可以读</li><li>Write：准备好接收写入数据了</li></ul><p>显然，当我们遇到合适的事件发生时再去做合适的事情就好了，再也不用一个线程对应一个请求，在阻塞时傻傻等待了。接下来我们详细介绍一下这几个组件。</p><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>一个channel就代表了和某一实体的链接，这个实体可以是文件、网络套接字等，官网上是这么解读的：</p><blockquote><p>A channel represents an open connection to an entity such as a<br>hardware device, a file, a network socket, or a program component that<br>is capable of performing one or more distinct I/O operations, for<br>example reading or writing.</p></blockquote><p>这个组件的地位，有点类似于BIO中的Stream，其功能也有点类似Stream，就是从一个Buffer中读取数据，或者把数据写入Buffer。</p><p>Java中NIO中最常用的通道实现有以下几个：</p><ul><li><p>FileChannel：读写文件，只有阻塞模式。这是因为UNIX当时不支持文件的非阻塞读取，而Java为了跨平台的表现一致，也就这样设置了。参考：<a href="https://stackoverflow.com/questions/3955250/why-filechannel-in-java-is-not-non-blocking" target="_blank" rel="noopener">Why FileChannel in Java is not non-blocking?</a></p><p>这意味着它也没法注册到Selector上面去。</p></li><li><p>DatagramChannel: UDP协议网络通信</p></li><li><p>SocketChannel：TCP协议网络通信</p></li><li><p>ServerSocketChannel：监听TCP连接，TCP连接的服务端。</p></li></ul><p>事件也是在Channel上发生的，所以我们需要在注册事件时，告知Selector我到底关心这个Channel上发生了哪些事件。</p><p>要注意的是，FileChannel只有阻塞模式。具体原因待调差。</p><h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><p>这就是NIO中使用的缓冲区，他不是一个byte[]，而是封装过的一个Buffer类，其继承层次如下：</p><p><img src="https://www.history-of-my-life.com/imgs-for-md/NonBlockingIO-channel-20190828-01.png" alt="NIO-Buffer"></p><p>看来还帮我们封装了一些基本的数据类型，这样读起来可能方便一些，分配内存的时候，也是按相应数据类型来计算size的，比如<code>IntBuffer.allocate(1024)</code>就是申请一个能放1024个Int的缓冲区，而<code>Double.allocate(1024)</code>就是申请一个能放1024个Double的缓冲区。</p><p>Buffer有几个重要的变量，就是上面标注的那四个。</p><ul><li>capacity。容量，allocate后就不会变了；</li><li>limit。此次可以操作的最后一个元素的位置。显然当Buffer被用于写的时候，就是Buffer的capacity，当Buffer用于读的时候，就是Buffer中已写入的元素的数量。</li><li>position。当前操作到的那个元素。</li><li>mark。一个可以随时指定的标记位，可以调用<code>Buffer#mark()</code>标记，调用<code>Buffer#reset()</code>使position指针回到上一次mark的位置。</li></ul><p>Buffer即可以用来读，也可以用来写，只是不能同时用来读和写，从写状态切换为读状态使用<code>filp()</code>，从读切换到写状态使用<code>compact()</code>。</p><p>读写状态调用<code>Buffer#filp()</code>方法来进行转换。一般来说，都是先写进去一些数据，然后再读出来，而这个状态的切换实际上也挺精妙的。我们在写的过程中，position一直在增长，指向最后一个写入的元素，此时limit表示可以写的最后一个位置的下一个位置，当然是和capacity的值保持一致。那当要从这个Buffer里读取元素时，只需要将limit置为写的position，然后将position置为0即可，这样就可以从0开始读，最多读到position。再由读翻转到写，只要吧position置为0，limit再置为capacity就可以了。</p><h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><p>根据上文描述的简易模型，这个选择器就对应着轮询器，用于监听各个通道中的事件。我们先将通道注册到选择器，并设置好关心的事件，然后就可以通过调用select()方法，等待我们关心的事件发生。</p><p>关心的事件上面已经介绍过了。</p><p>Selector本身是阻塞的，当没有任何关心的事件发生时，他不会占据CPU，在内存消耗上，他也只占据了一个线程的资源。当发生了感兴趣的事情以后，它再进行实际的工作。而且不像非阻塞IO那样，需要我们自己不断去查询连接状态，这样会空耗CPU。所以确实是一个比较理想的方案。</p><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是个单线程的Server</span></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个selector</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化TCP连接监听通道</span></span><br><span class="line">        ServerSocketChannel listenChannel = ServerSocketChannel.open();</span><br><span class="line">        listenChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">      <span class="comment">// NIO的阻塞与否是可选的，在网络环境下我们将其设置为非阻塞</span></span><br><span class="line">        listenChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 注册到selector（监听其ACCEPT事件）</span></span><br><span class="line">        listenChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            selector.select(); <span class="comment">//阻塞，直到有监听的事件发生</span></span><br><span class="line">          <span class="comment">// 可能不止有一个连接状态发生了变化</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIter = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过迭代器依次访问select出来的Channel事件</span></span><br><span class="line">            <span class="keyword">while</span> (keyIter.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = keyIter.next();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123; <span class="comment">// 有连接可以接受</span></span><br><span class="line">                    SocketChannel channel = ((ServerSocketChannel) key.channel()).accept();</span><br><span class="line">                    channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                  <span class="comment">// 再次注册，这次指明关心的事件是可读</span></span><br><span class="line">                    channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"与【"</span> + channel.getRemoteAddress() + <span class="string">"】建立了连接！"</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123; <span class="comment">// 有数据可以读取</span></span><br><span class="line">                    buffer.clear();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 读取-1说明到了流末尾，说明TCP连接已断开，</span></span><br><span class="line">                    <span class="comment">// 因此需要关闭通道或者取消监听READ事件</span></span><br><span class="line">                    <span class="comment">// 否则会无限循环</span></span><br><span class="line">                    <span class="keyword">if</span> (((SocketChannel) key.channel()).read(buffer) == -<span class="number">1</span>) &#123;</span><br><span class="line">                        key.channel().close();</span><br><span class="line">                      <span class="comment">// 已经处理的事件一定要手动移除</span></span><br><span class="line">                keyIter.remove();</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 按字节遍历数据</span></span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        <span class="keyword">byte</span> b = buffer.get();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123; <span class="comment">// 客户端消息末尾的\0</span></span><br><span class="line">                            System.out.println();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 响应客户端</span></span><br><span class="line">                            buffer.clear();</span><br><span class="line">                            buffer.put(<span class="string">"Hello, Client!\0"</span>.getBytes());</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                                ((SocketChannel) key.channel()).write(buffer);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.print((<span class="keyword">char</span>) b);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 已经处理的事件一定要手动移除</span></span><br><span class="line">                keyIter.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来一个简单的Client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">8080</span>);</span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先向服务端发送数据</span></span><br><span class="line">        os.write(<span class="string">"Hello, Server!\0"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取服务端发来的数据</span></span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b = is.read()) != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># server端</span><br><span class="line">与【/127.0.0.1:59974】建立了连接！</span><br><span class="line">Hello, Server!</span><br><span class="line"></span><br><span class="line"># client端</span><br><span class="line">Hello, Client!</span><br></pre></td></tr></table></figure><h3 id="NIO并不完美"><a href="#NIO并不完美" class="headerlink" title="NIO并不完美"></a>NIO并不完美</h3><p>这个例子展示了挺多东西。首先，我们可以看到Server用单线程处理了多个连接。但也暴露出一些问题。</p><ol><li><p>如果我们的服务器里用上面的单线程模型去处理，那么多CPU的性能优势就体现不出来。当然了，我们可以改善这个模型，使用一个线程来监听Accept事件，用多个线程来监听Read事件，代码就会变成这个样子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServerMultiThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptListener</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Selector acceptSelector;</span><br><span class="line">        <span class="keyword">private</span> Selector[] readSelectors;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        AcceptListener(Selector acceptSelector, Selector[] readSelectors) &#123;</span><br><span class="line">            <span class="keyword">this</span>.acceptSelector = acceptSelector;</span><br><span class="line">            <span class="keyword">this</span>.readSelectors = readSelectors;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ServerSocketChannel listenChannel = ServerSocketChannel.open();</span><br><span class="line">                listenChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8081</span>));</span><br><span class="line">                listenChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 注册到selector（监听其ACCEPT事件）</span></span><br><span class="line">                listenChannel.register(acceptSelector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (acceptSelector.select(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Iterator&lt;SelectionKey&gt; keyIter = acceptSelector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 通过迭代器依次访问select出来的Channel事件</span></span><br><span class="line">                        <span class="keyword">while</span> (keyIter.hasNext()) &#123;</span><br><span class="line">                            SelectionKey key = keyIter.next();</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (key.isAcceptable()) &#123; <span class="comment">// 有连接可以接受</span></span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    SocketChannel channel = ((ServerSocketChannel) key.channel()).accept();</span><br><span class="line">                                    channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                                  <span class="comment">// 这个register方法有可能出现问题</span></span><br><span class="line">                                    channel.register(readSelectors[index], SelectionKey.OP_READ);</span><br><span class="line">                                    index = (index + <span class="number">1</span>) % readSelectors.length;</span><br><span class="line"></span><br><span class="line">                                    System.out.println(<span class="string">"与【"</span> + channel.getRemoteAddress() + <span class="string">"】建立了连接！"</span>);</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    keyIter.remove();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadListener</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Selector readSelector;</span><br><span class="line">        <span class="keyword">private</span> ByteBuffer buffer = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        ReadListener(Selector readSelector) &#123;</span><br><span class="line">            <span class="keyword">this</span>.readSelector = readSelector;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                  <span class="comment">// 如果用上个例子的select()方法会导致acceptListener中的register阻塞</span></span><br><span class="line">                  <span class="comment">// 原因是readSelector锁定了内部key等待，而这个key在register中也需要先获取才能register，就死锁了</span></span><br><span class="line">                  <span class="comment">// 所以只好让他定期来释放锁，给register以机会</span></span><br><span class="line">                    <span class="keyword">if</span> (readSelector.select(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Iterator&lt;SelectionKey&gt; keyIter = readSelector.selectedKeys().iterator();</span><br><span class="line">                        <span class="keyword">while</span> (keyIter.hasNext()) &#123;</span><br><span class="line">                            SelectionKey key = keyIter.next();</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    buffer.clear();</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 读取到流末尾说明TCP连接已断开，</span></span><br><span class="line">                                    <span class="comment">// 因此需要关闭通道或者取消监听READ事件</span></span><br><span class="line">                                    <span class="comment">// 否则会无限循环</span></span><br><span class="line">                                    <span class="keyword">if</span> (((SocketChannel) key.channel()).read(buffer) == -<span class="number">1</span>) &#123;</span><br><span class="line">                                        key.channel().close();</span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    buffer.flip();</span><br><span class="line">                                    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                                        <span class="keyword">byte</span> b = buffer.get();</span><br><span class="line"></span><br><span class="line">                                        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123; <span class="comment">// 客户端消息末尾的\0</span></span><br><span class="line">                                            System.out.println();</span><br><span class="line"></span><br><span class="line">                                            <span class="comment">// 响应客户端</span></span><br><span class="line">                                            buffer.clear();</span><br><span class="line">                                            buffer.put(<span class="string">"Hello, Client!\0"</span>.getBytes());</span><br><span class="line">                                            buffer.flip();</span><br><span class="line">                                            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                                                ((SocketChannel) key.channel()).write(buffer);</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                            System.out.print((<span class="keyword">char</span>) b);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    keyIter.remove();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Selector acceptSelector = Selector.open();</span><br><span class="line">        Selector[] readSelectors = <span class="keyword">new</span> Selector[]&#123;</span><br><span class="line">                Selector.open(),</span><br><span class="line">                Selector.open(),</span><br><span class="line">                Selector.open()</span><br><span class="line">        &#125;;  <span class="comment">// 假设我们是4核机器，于是开一个线程监听连接，开三个线程处理业务</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> AcceptListener(acceptSelector, readSelectors)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ReadListener(readSelectors[<span class="number">0</span>])).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ReadListener(readSelectors[<span class="number">1</span>])).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ReadListener(readSelectors[<span class="number">2</span>])).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在这里我们对数据的处理的耗时非常短暂，实际上只是读出数据，并把它输出出来而已。但还是要知道，这个处理的过程对于每个readSelector所在的线程来说，都是串行的。既然是串行的，自然会导致其他请求处理不了，假如我们的这个处理的耗时比较长，比如说再有个数据库操作、文件读写、$$n^3$$以上复杂度的计算等，那其他注册在该selector上的请求都必须等待这个处理完了再说。这也是个灾难。我们当然可以启动N个readSelector来缓解这个问题，但是如果你启动了非常多的Selector，那么线程太多导致的内存和CPU切换耗资源的问题不就又出现了吗？</p><p>这个问题的解决方案，老实说我暂时没想出来。是不是要走BIO的老路，再建一个连接池，每一个请求read以后把read的结果包装成一个Runnable，再让线程池去处理，这不就又回到了一个请求一个线程的老路上去了，唯一的优化就在于至少在创建线程时工作线程都是有事可干的。</p><p>我只能猜想，这种耗时巨大的一些线上运算，或许用一个请求一个连接的BIO模型更优。这样至少不会出现前请求完成不了，后请求必须排队的情况。要解决并发不够的问题的话，那就部署集群好一点，反正加硬件几乎总是能解千愁。而NIO这种一个线程处理很多连接的方式，似乎更适合做一些不怎么占CPU的处理。</p></li><li><p>上面的例子还有一些问题，比如说buffer是有capacity的，因此一条信息很有可能不能在一次读完，同一条连接会发过来很多个信息，我们肯定要对这些信息进行拼接、定界。在响应的时候，我们也不可能用一个while循环真的把数据写完才做其他工作，不然写入的话限于缓冲区和网络IO的慢速度，又是一种浪费CPU的阻塞了。</p></li><li><p>这里我们的客户端和服务器之间的通信简直过于简单了，没有用任何协议，直接字节流扔过去，手动写了一个<code>\0</code>作为结束标志。现实中的客户端和服务器的通信哪有这样的，各种通信不都得有个协议，HTTP、FTP等，而我们已经看到了，用这一套原生的NIO接口，我们处理的是一些基础类型，比如char、int之类的，你得自己去处理各种协议。这还不玩死自己。所以，用这套源生API真的处理业务问题，会导致非常难写、非常容易出错。</p></li><li><p>另外，epoll的某种实现似乎还有bug，可能导致cpu空转。</p></li></ol><p>要解决上面这些问题，需要有一个非常严谨和繁琐的设计，幸运的是我们不需要真的自己去设计这个系统，开源框架Netty已经帮我们封装好了NIO的原生接口，解决了很多问题。关于Netty会在后续的文章中予以介绍。</p><h3 id="NIO与内存管理"><a href="#NIO与内存管理" class="headerlink" title="NIO与内存管理"></a>NIO与内存管理</h3><p><a href="http://lovestblog.cn/blog/2015/05/12/direct-buffer/" target="_blank" rel="noopener">JVM源码分析之堆外内存完全解读</a></p><p><a href="https://www.zhihu.com/question/60892134" target="_blank" rel="noopener">Java NIO direct buffer的优势在哪儿？</a></p><p><a href="https://blog.csdn.net/u014590757/article/details/79856425" target="_blank" rel="noopener">JAVA的堆外内存(基于NIO的ByteBuffer类实现)</a></p><p>在读JVM内存管理相关的内容时，我们经常会读到一句话：NIO使用了本地内存，而不是堆内存，因此大量使用NIO可能造成与传统的堆内存OOM表现不太一致的OOM错误。那么这个到底是怎么回事呢？</p><p>先说答案的一部分：这是因为NIO中使用的Buffer，在直接分配到本地内存时的IO效率比分配到堆内存上的效率要高一点，所以框架大量使用了本地内存上分配Buffer，而这造成了OOM的隐患，而且与堆内存溢出的OOM表现不太一致。于是引出这么几个问题：</p><ol><li><p>怎么在本地内存上直接分配空间？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Buffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);<span class="comment">// 在本地内存分配空间</span></span><br><span class="line">Buffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);<span class="comment">// 在堆内存分配空间</span></span><br></pre></td></tr></table></figure></li><li><p>为什么在堆内存分配缓存空间要慢一点？</p><p>在调用IO的系统调用，将内存从用户空间复制到内核空间时，或者将内核空间的数据复制到用户空间的过程中，要求传入系统调用的内存地址必须满足两个条件：</p><ul><li>不能变；</li><li>必须是连续的。</li></ul><p>而因为GC的存在，java堆内存会在不确定的时间点发生变化，其实也不是不能pin住单个对象不让他变化，但这就增加了内存收集的复杂性，直接破坏了GC的基本模型不说，这样不可变的内存分配多了，还有可能把内存割裂成一块一块的，另外，GC的新生代回收非常频繁，这样的一些缓存pin在哪里，假如卡IO了，很容易短时间内耗光eden区，整体上来说，有一点得不偿失，所以JVM的作者普遍没有选择这么做。</p><p>此外，byte[]在java规范中并不要求是连续的，虽然绝大多数实现中他们确实是连续的。但并不能保证这一点。</p><p>综合以上两个原因，在堆中分配的Buffer，在真正进行IO的时候，需要复制到本地内存中去。因为对关联的这一块本地内存的清理只在Full GC时进行，频率要低得多，所以适合做这种需要等待的事情。</p></li><li><p>为什么不只提供直接分配在本地内存中的Buffer，取消分配在堆中的buffer。</p><p>不是不可以，但是直接分配在堆中有个好处，就是可以被GC，而分配在直接内存中的数据只有在fullGC时才能被回收（如果禁用了显式GC，那就回收不了了），容易引发堆内存明明还有挺多，但是却OOM的问题。</p></li></ol><p>那么，这部分内存到底在什么时候回收呢？可以参考:<a href="http://lovestblog.cn/blog/2015/05/12/direct-buffer/" target="_blank" rel="noopener">JVM源码分析之堆外内存完全解读</a></p><blockquote><p>DirectByteBuffer对象在创建的时候关联了一个PhantomReference，说到PhantomReference它其实主要是用来跟踪对象何时被回收的，它不能影响gc决策，但是gc过程中如果发现某个对象除了只有PhantomReference引用它之外，并没有其他的地方引用它了，那将会把这个引用放到java.lang.ref.Reference.pending队列里，在gc完毕的时候通知ReferenceHandler这个守护线程去执行一些后置处理，而DirectByteBuffer关联的PhantomReference是PhantomReference的一个子类，在最终的处理里会通过Unsafe的free接口来释放DirectByteBuffer对应的堆外内存块</p></blockquote><p>因此，假如你闲的没事，使用JVM参数<code>-XX:+DisableExplicitGC</code>关闭了显式GC，那么这部分内存永远不会释放了，时间长一点就等着OOM吧。</p><h2 id="AIO（Asynchronous-I-O）"><a href="#AIO（Asynchronous-I-O）" class="headerlink" title="AIO（Asynchronous I/O）"></a>AIO（Asynchronous I/O）</h2><p>如果我们仔细观察上面所说的Non-Blocking IO，我们会发现一个问题，即真正的<code>IO operation</code>，还是阻塞的。要理解这个问题，首先要精确定义<strong>IO operation</strong>，我们这里所说的<code>IO operation</code>，是指把数据从kernel内存中复制到user内存中的这个过程。</p><p>在BIO时，我们的线程在IO的整个过程，包括等待连接建立、等待数据就位、从内核态复制数据到用户态的过程中，全都都是阻塞等待的。</p><p>在NIO中，我们的线程在IO还没有准备好的时候不用阻塞，当IO的数据准备好了以后，从内核内存复制到用户内存的过程里，是阻塞的。因为这个阻塞过程，意味着用户如果要同时做其他工作，就要控制这个读写的过程不能阻塞太久，不然还是要放到单独的IO线程里面去执行。</p><p>那么有没有一种办法，把这个内核态到用户态的复制这个步骤也搞成非阻塞的，等到需要的数据都拷贝到用户内存里以后，再来通知我说复制好了。那这样岂不美哉？甚至更进一步，我直接把一个回调函数传给负责IO的线程，说等你复制完数据以后，直接帮我执行一下这个回调函数就好了。这样主线程写起来是不是就更快乐了？</p><p>用取包裹举个例子，BIO同步阻塞年代，是我站在门口痴痴地等待快递小哥到来，NIO时代，是快递小哥到了门口给我打电话我去取，而AIO时代，是快递小哥把东西直接搬到我指定的位置放好，然后给我打个电话说一声。</p><p>那么AIO到底解决了什么问题呢？大概就是在IO执行过程中彻底不需要阻塞了，只在数据完全准备好时才通知应用程序处理，而且回调方法的出现，多少简化了编程模型，并且它甚至增加了对线程池的源生支持，可以为回调方法的执行预先准备一个线程池。</p><p>多少有点美好。那我们首先来看一下AIO的主要接口。</p><h3 id="AIO的核心组件"><a href="#AIO的核心组件" class="headerlink" title="AIO的核心组件"></a>AIO的核心组件</h3><h4 id="AsynchronousChannel"><a href="#AsynchronousChannel" class="headerlink" title="AsynchronousChannel"></a>AsynchronousChannel</h4><p>我们可以看到，NIO和AIO在前半部分是很像的，所以这个Channel和NIO的Channel其实也是一样的，即代表了我们关注的一些连接。</p><p>他的子类包括：</p><ul><li>AsynchronousFileChannel</li><li>AsynchronousServerSocketChannel</li><li>AsynchronousSocketChannel</li></ul><h4 id="AsynchronousChannelGroup"><a href="#AsynchronousChannelGroup" class="headerlink" title="AsynchronousChannelGroup"></a>AsynchronousChannelGroup</h4><p>异步channel的分组管理机制，主要是一个Group可以绑定一个线程池，这个线程池用来处理IO事件和CompletionHandler。AsynchronousServerSocketChannel创建的时候可以传入一个AsynchronousChannelGroup，那么通过AsynchronousServerSocketChannel创建的 AsynchronousSocketChannel将同属于一个组，共享资源。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousChannelGroup group = AsynchronousChannelGroup.withThreadPool(Executors.newFixedThreadPool(<span class="number">4</span>));</span><br><span class="line">AsynchronousServerSocketChannel server = AsynchronousServerSocketChannel.open(group).bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"0.0.0.0"</span>, <span class="number">8013</span>));</span><br></pre></td></tr></table></figure><h4 id="CompletionHandler"><a href="#CompletionHandler" class="headerlink" title="CompletionHandler"></a>CompletionHandler</h4><p>回调借口。AIO的API允许两种方式来处理异步操作的结果：返回的Future模式或者注册CompletionHandler。返回Future的方式，因为<code>Future#get()</code>是阻塞接口，所以用的稍微不仔细一点，就成了异步阻塞的那一套了，所以可能用CompletionHandler要更好一些，这些handler的调用是由AsynchronousChannelGroup的线程池派发的。因此线程池的使用也与性能相关，线程池的使用不是这里的重点，在这里不详述。</p><p>其接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.nio.channels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompletionHandler</span>&lt;<span class="title">V</span>,<span class="title">A</span>&gt; </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">completed</span><span class="params">(V result, A attachment)</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, A attachment)</span></span>;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中Result表示IO调用的结果，而A是你需要使用的任意一个对象，在IO调用时传入。</p><p>抄一段代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousChannelGroup;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.CharsetEncoder;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Charset charset = StandardCharsets.US_ASCII;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CharsetEncoder encoder = charset.newEncoder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AsynchronousChannelGroup group = AsynchronousChannelGroup.withThreadPool(Executors.newFixedThreadPool(<span class="number">4</span>));</span><br><span class="line">        AsynchronousServerSocketChannel server = AsynchronousServerSocketChannel.open(group).bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"0.0.0.0"</span>, <span class="number">8013</span>));</span><br><span class="line">        server.accept(<span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel result, Void attachment)</span> </span>&#123;</span><br><span class="line">                server.accept(<span class="keyword">null</span>, <span class="keyword">this</span>); <span class="comment">// 接受下一个连接</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String now = <span class="keyword">new</span> Date().toString();</span><br><span class="line">                    ByteBuffer buffer = encoder.encode(CharBuffer.wrap(now + <span class="string">"\r\n"</span>));</span><br><span class="line">                    <span class="comment">//result.write(buffer, null, new CompletionHandler&lt;Integer,Void&gt;()&#123;...&#125;); //callback or</span></span><br><span class="line">                    Future&lt;Integer&gt; f = result.write(buffer);</span><br><span class="line">                    f.get();</span><br><span class="line">                    System.out.println(<span class="string">"sent to client: "</span> + now);</span><br><span class="line">                    result.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException | InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Void attachment)</span> </span>&#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        group.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子里用了两种方式，其中发送数据用了future。但这个Future其实也就是个数字，表明写了几个字符，没有实际意义。</p><p>Client实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AsynchronousSocketChannel client = AsynchronousSocketChannel.open();</span><br><span class="line">        Future&lt;Void&gt; future = client.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8013</span>));</span><br><span class="line">        future.get();</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">        client.read(buffer, <span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;Integer, Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Void attachment)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"client received: "</span> + <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Void attachment)</span> </span>&#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完美了吗？"><a href="#完美了吗？" class="headerlink" title="完美了吗？"></a>完美了吗？</h3><p>其实我们可以发现，上面的编程模型确实稍微简化了一点。只需要告诉系统IO完了之后执行哪些任务就可以了，Selector用不到了，因为不需要我们去轮询了，任务的分派系统可以自动利用线程池，心智负担确实小了一些。</p><p>但是这个也不是就没有问题了。其实他面对的主要问题，和NIO是一样的，就是协议的处理、拆包、定界等这些问题。一样繁琐，实际上还是依赖框架的包装心智负担更小一些。</p><h2 id="BIO-NIO-AIO的适用场景"><a href="#BIO-NIO-AIO的适用场景" class="headerlink" title="BIO NIO AIO的适用场景"></a>BIO NIO AIO的适用场景</h2><p>这个其实我也没有经验，只要直接COPY网上的东西了：</p><ul><li><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</p></li><li><p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</p></li><li><p>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>阻塞和同步异步相关<ul><li><a href="https://www.zhihu.com/question/19732473" target="_blank" rel="noopener">怎样理解阻塞非阻塞与同步异步的区别</a></li><li><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a></li></ul></li><li>BIO相关<ul><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/BIO-NIO-AIO.md" target="_blank" rel="noopener">githun:BIO-NIO-AIO</a></li></ul></li><li><p>NIO相关</p><ul><li><a href="https://tech.meituan.com/2016/11/04/nio.html" target="_blank" rel="noopener">Java NIO浅析</a></li><li><a href="https://www.cnblogs.com/pony1223/p/8138233.html" target="_blank" rel="noopener">JAVA NIO学习一：NIO简介、NIO&amp;IO的主要区别</a></li><li><a href="https://segmentfault.com/a/1190000017040893" target="_blank" rel="noopener">一文让你彻底理解 Java NIO 核心组件</a></li><li><a href="https://www.jianshu.com/p/a4e03835921a" target="_blank" rel="noopener">跟闪电侠学Netty</a></li><li><a href="https://stackoverflow.com/questions/3955250/why-filechannel-in-java-is-not-non-blocking" target="_blank" rel="noopener">Why FileChannel in Java is not non-blocking?</a></li></ul></li><li><p>AIO相关</p><ul><li><a href="https://zhuanlan.zhihu.com/p/51453522" target="_blank" rel="noopener">深入理解BIO、NIO、AIO</a></li><li><a href="https://colobu.com/2014/11/13/java-aio-introduction/" target="_blank" rel="noopener">java aio 编程</a></li><li><a href="https://www.cnblogs.com/duanxz/p/6782803.html" target="_blank" rel="noopener">Java NIO系列教程（八）JDK AIO编程</a></li></ul></li></ul><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>这些IO方式我们现实中可能都很少直接用到，但是IO方式的改进反映出的思想确实很有价值，值得我们参考借鉴。</p><p>另外：笔记仅用于自己学习和几位好友的内部技术交流，请勿转发给工作相关人员。如果承蒙错爱想发博客，注明一下作者即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;– 你有《时间简史》吗？&lt;/p&gt;
&lt;p&gt;– 你有病吧，我有时间也不去捡屎啊。&lt;/p&gt;
&lt;p&gt;好吧，上面是个冷笑话。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Don&#39;t Be So Serious</title>
    <link href="http://yoursite.com/2019/11/28/Don-t-Be-So-Serious/"/>
    <id>http://yoursite.com/2019/11/28/Don-t-Be-So-Serious/</id>
    <published>2019-11-28T03:34:30.000Z</published>
    <updated>2021-04-22T04:43:17.454Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><strong><em>“Don’t Be So Serious”</em></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;strong&gt;&lt;em&gt;“Don’t Be So Serious”</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://yoursite.com/tags/随笔/"/>
    
  </entry>
  
  <entry>
    <title>oracle技巧</title>
    <link href="http://yoursite.com/2019/07/23/oracle%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2019/07/23/oracle%E6%8A%80%E5%B7%A7/</id>
    <published>2019-07-23T03:17:03.000Z</published>
    <updated>2021-04-22T04:43:17.473Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-python3-中的cx-Oracle"><a href="#1-python3-中的cx-Oracle" class="headerlink" title="1. python3 中的cx_Oracle"></a>1. python3 中的cx_Oracle</h4><p>cx_Oracle 模块是没法直接通过pip install的,要想使用,需要配置好几个东西,此处默认已经安装了python3(离线的话需要配置好yum和pip源)</p><h5 id="1-oracle-instantclient"><a href="#1-oracle-instantclient" class="headerlink" title="1. oracle instantclient"></a>1. oracle instantclient</h5><p><a href="https://www.oracle.com/technetwork/cn/topics/linuxx86-64soft-095635-zhs.html" target="_blank" rel="noopener">oracle官网下载地址</a><br>官网下载需要注册,我把我用到的 instantclient-basic-linux.x64-12.1.0.2.0.zip <a href>放到了网盘可供下载</a><br>将zip包放置到/opt/下并解压</p><h5 id="2-cx-Oracle"><a href="#2-cx-Oracle" class="headerlink" title="2. cx_Oracle"></a>2. cx_Oracle</h5><p><a href="https://pypi.org/project/cx-Oracle/" target="_blank" rel="noopener">下载地址</a>,下载如图压缩包</p><img src="/2019/07/23/oracle技巧/cx.jpg"><p>下载完成后,解压并进入,然后 python36 setup.py install 等待完成</p><h5 id="3-环境变量"><a href="#3-环境变量" class="headerlink" title="3. 环境变量"></a>3. 环境变量</h5><p>配置环境变量 <code>vim /etc/profile</code><br>再文件最后加上两行内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ORACLE_HOME=/opt/instantclient_12_1</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:<span class="variable">$ORACLE_HOME</span></span><br></pre></td></tr></table></figure></p><p>如果当前用户进入python3后依然无法 import cx_Oracle,请在shell端在执行一下export操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Haozz:~ haozz$ <span class="built_in">export</span> ORACLE_HOME=/opt/instantclient_12_1</span><br><span class="line">Haozz:~ haozz$ <span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:<span class="variable">$ORACLE_HOME</span></span><br></pre></td></tr></table></figure><h4 id="2-merge-into"><a href="#2-merge-into" class="headerlink" title="2. merge into"></a>2. merge into</h4><p>在oracle中,我们经常会遇到一种情形,需要将B表中的数据插入A表的同时考虑数据是否在A表中存在,如果不存在则插入,存在则更新那条记录的某个字段值.<br>此时使用<code>merge into</code>是最好不过的了(mysql中是 <code>replace into</code>)</p><p>merge into的实例用法:假如我要把B表中的数据(姓名,身份证号码)插入 购房记录 表中,如果购房记录表中存在这个身份证号码则将标签字段修改为’多次’,如果没有则直接插入标签字段为’一次’<br>在merge into时有一个前提,源表中的身份证号码字段唯一,否则会报错 <code>ORA-30926</code>,可见<a href="http://besthao.cn/2018/12/19/oracle/" target="_blank" rel="noopener">我的文章 oracle异常中的介绍</a>,这里不再解释</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">merge</span> <span class="keyword">into</span> 购房记录 A <span class="keyword">using</span> (</span><br><span class="line">    <span class="keyword">select</span> </span><br><span class="line">    B.name,</span><br><span class="line">    B.idno </span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">    购房人员 B</span><br><span class="line">)C <span class="keyword">on</span> (A.idno=C.idno)</span><br><span class="line"><span class="keyword">when</span> <span class="keyword">matched</span> <span class="keyword">then</span> </span><br><span class="line"><span class="keyword">update</span> <span class="keyword">set</span> A.label=<span class="string">'多次'</span> </span><br><span class="line"><span class="keyword">when</span> <span class="keyword">not</span> <span class="keyword">matched</span> <span class="keyword">then</span> </span><br><span class="line"><span class="keyword">insert</span> (</span><br><span class="line">    A.name,</span><br><span class="line">    A.idno,</span><br><span class="line">    A.label</span><br><span class="line">)<span class="keyword">values</span>(</span><br><span class="line">    B.name,</span><br><span class="line">    B.idno,</span><br><span class="line">    <span class="string">'一次'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-python3-中的cx-Oracle&quot;&gt;&lt;a href=&quot;#1-python3-中的cx-Oracle&quot; class=&quot;headerlink&quot; title=&quot;1. python3 中的cx_Oracle&quot;&gt;&lt;/a&gt;1. python3 中的cx_Oracle</summary>
      
    
    
    
    
    <category term="oracle" scheme="http://yoursite.com/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>打倒反动派</title>
    <link href="http://yoursite.com/2019/07/04/%E6%89%93%E5%80%92%E5%8F%8D%E5%8A%A8%E6%B4%BE/"/>
    <id>http://yoursite.com/2019/07/04/%E6%89%93%E5%80%92%E5%8F%8D%E5%8A%A8%E6%B4%BE/</id>
    <published>2019-07-04T03:58:35.000Z</published>
    <updated>2021-04-22T04:43:17.487Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>任何反动派都是纸老虎</em></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;任何反动派都是纸老虎&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://yoursite.com/tags/随笔/"/>
    
  </entry>
  
  <entry>
    <title>kafka异常</title>
    <link href="http://yoursite.com/2019/06/17/kafka%E6%8B%93%E5%B1%95/"/>
    <id>http://yoursite.com/2019/06/17/kafka%E6%8B%93%E5%B1%95/</id>
    <published>2019-06-17T09:08:17.000Z</published>
    <updated>2021-04-22T04:43:17.470Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录kafka开发使用过程中遇到的问题</p><h5 id="1-远程无法访问"><a href="#1-远程无法访问" class="headerlink" title="1. 远程无法访问"></a>1. 远程无法访问</h5><p>kafka在启动之后,只能通过本地访问</p><p>修改kafka配置文件里的host,使用真实ip而不可使用localhost或者127.0.0.1</p><p>并且在 hosts文件中添加ip hostname的记录<br>例如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line"></span><br><span class="line">127.0.0.1 hao</span><br><span class="line"><span class="comment"># 添加下面一条记录</span></span><br><span class="line">192.168.1.1 hao</span><br></pre></td></tr></table></figure></p><ul><li>在使用开发工具本地调试的时候还是无法成功创建生产者生产数据<br>因为远程服务器没有公网ip,需要通过跳板机做内网端口转发,将zk端口和kafka端口在本地做映射,是能做到发送而无法接收到返回的数据请求,所以无法完成本地调试</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里记录kafka开发使用过程中遇到的问题&lt;/p&gt;
&lt;h5 id=&quot;1-远程无法访问&quot;&gt;&lt;a href=&quot;#1-远程无法访问&quot; class=&quot;headerlink&quot; title=&quot;1. 远程无法访问&quot;&gt;&lt;/a&gt;1. 远程无法访问&lt;/h5&gt;&lt;p&gt;kafka在启动之后,只能通过</summary>
      
    
    
    
    
    <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>kafka调优</title>
    <link href="http://yoursite.com/2019/06/17/kafka%E8%B0%83%E4%BC%98/"/>
    <id>http://yoursite.com/2019/06/17/kafka%E8%B0%83%E4%BC%98/</id>
    <published>2019-06-17T08:19:57.000Z</published>
    <updated>2021-04-22T04:43:17.470Z</updated>
    
    <content type="html"><![CDATA[<p>参考文章:<br><a href="https://blog.csdn.net/vegetable_bird_001/article/details/51858915" target="_blank" rel="noopener">kafka性能调优</a><br><a href="https://blog.csdn.net/shenshouniu/article/details/83515413" target="_blank" rel="noopener">kafka生产者Producer参数设置及参数调优建议</a></p><h5 id="1-压缩"><a href="#1-压缩" class="headerlink" title="1. 压缩"></a>1. 压缩</h5><p>producer压缩器,目前支持none（不压缩）,gzip,snappy和lz4.</p><p>商业环境推荐:<br>基于公司物联网平台,试验过目前lz4的效果最好.当然2016年8月,FaceBook开源了Ztandard.官网测试:Ztandard压缩率为2.8,snappy为2.091,LZ4 为2.10</p><p>修改producer配置<br><code>vim ../config/producer.properties</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment"># specify the compression codec for all data generated: none, gzip, snappy, lz4, zstd</span></span><br><span class="line">compression.type=lz4</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h5 id="2-数据清除"><a href="#2-数据清除" class="headerlink" title="2. 数据清除"></a>2. 数据清除</h5><p>kafka的数据都是落地到本地文件里的,定期删除日志<br><code>vim ../config/server.properties</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment"># 启用删除策略,删除后不可恢复</span></span><br><span class="line">log.cleanup.policy=delete</span><br><span class="line"><span class="comment"># 保留一天,默认7天,可以使用其他时间单位:hours,minutes和ms</span></span><br><span class="line">log.retention.hours=24</span><br><span class="line"><span class="comment"># 段文件配置1GB，有利于快速回收磁盘空间，重启kafka加载也会加快(如果文件过小，则文件数量比较多，</span></span><br><span class="line"><span class="comment"># kafka启动时是单线程扫描目录(log.dir)下所有数据文件)</span></span><br><span class="line">log.segment.bytes=1073741824</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考文章:&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/vegetable_bird_001/article/details/51858915&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kafka性能调优&lt;/a&gt;&lt;br&gt;&lt;a h</summary>
      
    
    
    
    
    <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>kafka安装</title>
    <link href="http://yoursite.com/2019/06/11/kafka%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/06/11/kafka%E5%AE%89%E8%A3%85/</id>
    <published>2019-06-11T06:22:37.000Z</published>
    <updated>2021-04-22T04:43:17.470Z</updated>
    
    <content type="html"><![CDATA[<p>Apache Kafka is a distributed streaming platform</p><p>ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services</p><a id="more"></a><blockquote><p>首先讲一下Kafka中涉及的一些名词概念</p></blockquote><ul><li>Broker: 服务代理.实质上就是kafka集群的一个物理节点.</li><li>Topic: 特定类型的消息流.”消息”是字节的有效负载(payload),话题是消息的分类的名或种子名</li><li>Partition: Topic的子概念.一个Topic可以有多个Partition,但一个Partition只属于一个Topic.此外,Partition则是Consumer消费的基本单元.消费时.每个消费线程最多只能使用一个Partition.一个topic中partition的数量,就是每个user group中消费该topic的最大并行数量.</li><li>UserGroup: 为了便于实现MQ中多播,重复消费等引入的概念.如果ConsumerA和ConsumerB属于同一个UserGroup,那么对于ConsumerA消费过的数据,ConsumerB就不能再消费了.也就是说,同一个user group中的consumer使用同一套offset</li><li>Offset: Offset是专门对于Partition和UserGroup而言的,用于记录某个UserGroup在某个Partition中当前已经消费到达的位置.</li><li>Producer: 生产者,能够发布消息到话题的任何对象.直接向某topic下的某partition发送数据.leader负责主备策略、写入数据、发送ack.</li><li>Consumer: 消费者.可以订阅一个或者多个话题,通过fetch的方式从Broker中拉取数据,从而消费这些已经发布的信息的对象.kafka server不直接负责每个consumer消费到了哪,所以需要client和zk联合维护每个partition读到了哪里,即offset</li></ul><blockquote><p>搭建Kafka集群</p></blockquote><h4 id="1-搭建"><a href="#1-搭建" class="headerlink" title="1. 搭建"></a>1. 搭建</h4><p>如果你的机器可以联机互联网的话就再好不过了,这将节省很多时间而且操作更简单,如果是离线环境则需要将用的tar包下载自行拷贝到目标机器.<br>我这里以linux的机器为例.</p><h5 id="首先安装zookeeper"><a href="#首先安装zookeeper" class="headerlink" title="首先安装zookeeper"></a>首先安装zookeeper</h5><p>因为是可以连接互联网,所以我们就不使用kafka自带的zk了,来安装一个吧,反正也很简单<br>在<a href="https://zookeeper.apache.org/index.html" target="_blank" rel="noopener">zookeeper官网</a>里我们找到了<a href="https://www.apache.org/dyn/closer.cgi/zookeeper/" target="_blank" rel="noopener">Download页面</a>,根据里面提供的镜像地址直接是有wget下载<br><code>wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.5.5/apache-zookeeper-3.5.5.tar.gz</code><br>等待zk下载并解压完毕后,进入zk的目录下面<code>cd apache-zookeeper-3.5.5/conf</code><br>这里包含了所有zk的配置文件(也就三个~)</p><img src="/2019/06/11/kafka安装/conf.png"><p>我们只需要拷贝一份zoo_sample.cfg并作出修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line">vim zoo.cfg</span><br></pre></td></tr></table></figure></p><p>编辑之后的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">#目录自行创建</span><br><span class="line">dataDir=/data/zookeeper/zk1/data</span><br><span class="line">dataLogDir=/data/zookeeper/zk1/log</span><br><span class="line">clientPort=2181</span><br><span class="line">server.1=[你的host]:2888:3888</span><br></pre></td></tr></table></figure></p><p>其中dataDir和dataLogDir根据你自己创建的目录来写.<br>如果你想要在一台机器上模拟一个集群启动多个zk节点的话,就重复以上操作多拷贝zoo.cfg文件,例如我需要三个节点的zk集群,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp zoo_sample.cfg zoo1.cfg</span><br><span class="line">cp zoo_sample.cfg zoo2.cfg</span><br><span class="line">cp zoo_sample.cfg zoo3.cfg</span><br></pre></td></tr></table></figure></p><p>并对每个cfg文件作出修改,数据与日志目录不要重复,并且在每一份文件中都要写入如下内容(端口可自定)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.1=192.168.178.22:2287:3387</span><br><span class="line">server.2=192.168.178.22:2288:3388</span><br><span class="line">server.3=192.168.178.22:2289:3389</span><br></pre></td></tr></table></figure></p><p>然后到每个zk节点的dataDir目录下面创建myid文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/zookeeper/zk1/data</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1"</span> &gt; myid</span><br></pre></td></tr></table></figure></p><p>三个节点都要创建对应的myid文件,值要根据上面cfg文件中写的server.id一一对应</p><p>接下来就是启动zk了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../zookeeper/bin</span><br><span class="line">./zkServer.sh start ../conf/zoo1.cfg</span><br><span class="line">./zkServer.sh start ../conf/zoo2.cfg</span><br><span class="line">./zkServer.sh start ../conf/zoo3.cfg</span><br><span class="line"><span class="comment"># 然后查看zk节点的状态</span></span><br><span class="line">./zkServer.sh status ../conf/zoo2.cfg</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: ../conf/zoo2.cfg</span><br><span class="line">Mode: leader</span><br></pre></td></tr></table></figure></p><p>三个节点的zk集群启动成功,id为2的zk节点是leader</p><h5 id="安装Kafka"><a href="#安装Kafka" class="headerlink" title="安装Kafka"></a>安装Kafka</h5><p>同样我们在<a href="http://kafka.apache.org/" target="_blank" rel="noopener">Kafka官网</a>里找到<a href="http://kafka.apache.org/downloads" target="_blank" rel="noopener">下载页面</a>,然后找到最新的<a href="https://www.apache.org/dyn/closer.cgi?path=/kafka/2.2.1/kafka_2.11-2.2.1.tgz" target="_blank" rel="noopener">镜像地址</a>直接下载压缩包<br><code>wget http://mirrors.tuna.tsinghua.edu.cn/apache/kafka/2.2.1/kafka_2.11-2.2.1.tgz</code><br>下载并解压完成后进到目录里<code>cd kafka/config</code></p><img src="/2019/06/11/kafka安装/config.png"><p>同样我们假设启动两个broker的kafka集群,拷贝两份<code>server.properties文件</code>并做修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cp server.properties server1.properties</span><br><span class="line"># 修改以下内容</span><br><span class="line">broker.id=1</span><br><span class="line">listeners=PLAINTEXT://192.168.178.22:9092</span><br><span class="line">log.dirs=/data/kafka/logs/kafka-logs-1</span><br><span class="line">zookeeper.connect=192.168.178.22:2182,192.168.178.22:2181,192.168.178.22:2183</span><br><span class="line">...</span><br><span class="line"># 配置直接删除topic</span><br><span class="line">delete.topic.enable=true</span><br><span class="line"># 虽然不明白原因,但是不加这两个启动不起来..</span><br><span class="line">advertised.host.name=192.168.178.22</span><br><span class="line">advertised.port=9092</span><br><span class="line"></span><br><span class="line">cp server.properties server2.properties</span><br><span class="line"># 修改以下内容</span><br><span class="line">broker.id=2</span><br><span class="line">listeners=PLAINTEXT://192.168.178.22:9093</span><br><span class="line">log.dirs=/data/kafka/logs/kafka-logs-2</span><br><span class="line">zookeeper.connect=192.168.178.22:2182,192.168.178.22:2181,192.168.178.22:2183</span><br><span class="line">...</span><br><span class="line">delete.topic.enable=true</span><br><span class="line">advertised.host.name=192.168.178.24</span><br><span class="line">advertised.port=9093</span><br></pre></td></tr></table></figure></p><p>启动两个kafka的broker<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/kafka/kafka-2.11/bin</span><br><span class="line"><span class="comment"># 将日志写入文件并置于后台启动</span></span><br><span class="line">kafka-server-start.sh ../config/server1.properties &gt; broker1.log 2&gt;&amp;1 &amp;</span><br><span class="line">kafka-server-start.sh ../config/server2.properties &gt; broker2.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></p><p>至此,kafka搭建完成,可以使用<code>jobs</code>命令查看一下任务状况<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="built_in">test</span>-hao config]<span class="comment"># jobs</span></span><br><span class="line">[1]-  Running                 kafka-server-start.sh ../config/server2.properties &gt; broker2.log 2&gt;&amp;1 &amp;  (wd: /data/kafka/kafka_2.11-2.2.1/bin)</span><br><span class="line">[2]+  Running                 kafka-server-start.sh ../config/server1.properties &gt; broker1.log 2&gt;&amp;1 &amp;  (wd: /data/kafka/kafka_2.11-2.2.1/bin)</span><br></pre></td></tr></table></figure></p><h4 id="2-测试Kafka"><a href="#2-测试Kafka" class="headerlink" title="2. 测试Kafka"></a>2. 测试Kafka</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">cd /data/kafka/kafka-2.11/bin</span><br><span class="line">#创建主题</span><br><span class="line">./kafka-topics.sh \</span><br><span class="line">--create \</span><br><span class="line">--bootstrap-server 192.168.178.22:9092,192.168.178.22:9093 \</span><br><span class="line">--replication-factor 2 \</span><br><span class="line">--partitions 3 \</span><br><span class="line">--topic test</span><br><span class="line"></span><br><span class="line"># 查看broker的情况</span><br><span class="line">./kafka-topics.sh --describe \</span><br><span class="line">--zookeeper 10.4.121.218:3333 \</span><br><span class="line">--topic my-replicated-topic</span><br><span class="line">Topic:my-replicated-topicPartitionCount:1ReplicationFactor:3Configs:</span><br><span class="line">    # 配置情况：分区数据在节点broker.id=0、主节点是broker.id=1、副本集是broker.id=1,0,2、isr是broker.id=1,0,2</span><br><span class="line">Topic: my-replicated-topicPartition: 0Leader: 1Replicas: 1,0,2Isr: 1,0,2</span><br><span class="line"></span><br><span class="line"># 生产者</span><br><span class="line">./kafka-console-producer.sh \</span><br><span class="line">--broker-list 192.168.178.22:9092,192.168.178.22:9093 \</span><br><span class="line">--topic test</span><br><span class="line">...</span><br><span class="line">test1</span><br><span class="line">test2</span><br><span class="line">^C</span><br><span class="line"></span><br><span class="line"># 消费者</span><br><span class="line"># 在开启一个窗口启动消费者可以看到在实时消费数据</span><br><span class="line">./kafka-console-consumer.sh \</span><br><span class="line">--bootstrap-server 192.168.178.22:9092,192.168.178.22:9093 \</span><br><span class="line">--from-beginning \</span><br><span class="line">--topic test</span><br><span class="line">...</span><br><span class="line">test1</span><br><span class="line">test2</span><br><span class="line">^C</span><br><span class="line"></span><br><span class="line"># 删除</span><br><span class="line">./kafka-topics.sh --delete \</span><br><span class="line">--zookeeper 192.168.178.22:2181 \</span><br><span class="line">--topic test</span><br><span class="line"># 如果在server.properties文件中没有添加 delete.topic.enable=true 这一项,topic只是被标记了删除,并没有真正被删除,还需要去zk里进行手动删除,所以我一般是添加这一项的(也不会经常出现需要去删除一个topic的情况)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Apache Kafka is a distributed streaming platform&lt;/p&gt;
&lt;p&gt;ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services&lt;/p&gt;</summary>
    
    
    
    
    <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>测试评论系统专用贴</title>
    <link href="http://yoursite.com/2019/06/06/%E6%B5%8B%E8%AF%95%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E4%B8%93%E7%94%A8%E8%B4%B4/"/>
    <id>http://yoursite.com/2019/06/06/%E6%B5%8B%E8%AF%95%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E4%B8%93%E7%94%A8%E8%B4%B4/</id>
    <published>2019-06-06T10:52:18.000Z</published>
    <updated>2021-04-22T04:43:17.487Z</updated>
    
    <content type="html"><![CDATA[<p>来这里评论吧~~~~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;来这里评论吧~~~~&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="博客" scheme="http://yoursite.com/tags/博客/"/>
    
  </entry>
  
</feed>
